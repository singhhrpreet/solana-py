{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Solana.py \ud83d\udc0d The Solana Python SDK \ud83d\udc0d Solana.py is the base Python library for interacting with Solana. You can use it to build transactions and interact with the Solana JSON RPC API , much like you would do with solana-web3.js It also covers the SPL Token Program . Latest Documentation . Note: This library uses many core types from the Solders package which used to be provided by solana-py itself. If you are upgrading from an old version and you're looking for something that was deleted, it's probably in solders now. \u2693\ufe0e See also: AnchorPy , a Python client for Anchor -based programs on Solana. \u2693\ufe0e \u26a1 Quickstart Installation pip install solana General Usage Note: check out the Solana Cookbook for more detailed examples! import solana API Client from solana.rpc.api import Client http_client = Client ( \"https://api.devnet.solana.com\" ) Async API Client import asyncio from solana.rpc.async_api import AsyncClient async def main (): async with AsyncClient ( \"https://api.devnet.solana.com\" ) as client : res = await client . is_connected () print ( res ) # True # Alternatively, close the client explicitly instead of using a context manager: client = AsyncClient ( \"https://api.devnet.solana.com\" ) res = await client . is_connected () print ( res ) # True await client . close () asyncio . run ( main ()) Websockets Client import asyncio from asyncstdlib import enumerate from solana.rpc.websocket_api import connect async def main (): async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : await websocket . logs_subscribe () first_resp = await websocket . recv () subscription_id = first_resp [ 0 ] . result next_resp = await websocket . recv () print ( next_resp ) await websocket . logs_unsubscribe ( subscription_id ) # Alternatively, use the client as an infinite asynchronous iterator: async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : await websocket . logs_subscribe () first_resp = await websocket . recv () subscription_id = first_resp [ 0 ] . result async for idx , msg in enumerate ( websocket ): if idx == 3 : break print ( msg ) await websocket . logs_unsubscribe ( subscription_id ) asyncio . run ( main ()) \ud83d\udd28 Development Setup Install poetry Install dev dependencies: poetry install Activate the poetry shell. poetry shell Lint make lint Tests # All tests make tests # Unit tests only make unit-tests # Integration tests only make int-tests","title":"Home"},{"location":"#solanapy","text":"\ud83d\udc0d The Solana Python SDK \ud83d\udc0d Solana.py is the base Python library for interacting with Solana. You can use it to build transactions and interact with the Solana JSON RPC API , much like you would do with solana-web3.js It also covers the SPL Token Program . Latest Documentation . Note: This library uses many core types from the Solders package which used to be provided by solana-py itself. If you are upgrading from an old version and you're looking for something that was deleted, it's probably in solders now. \u2693\ufe0e See also: AnchorPy , a Python client for Anchor -based programs on Solana. \u2693\ufe0e","title":"Solana.py"},{"location":"#quickstart","text":"","title":"\u26a1 Quickstart"},{"location":"#installation","text":"pip install solana","title":"Installation"},{"location":"#general-usage","text":"Note: check out the Solana Cookbook for more detailed examples! import solana","title":"General Usage"},{"location":"#api-client","text":"from solana.rpc.api import Client http_client = Client ( \"https://api.devnet.solana.com\" )","title":"API Client"},{"location":"#async-api-client","text":"import asyncio from solana.rpc.async_api import AsyncClient async def main (): async with AsyncClient ( \"https://api.devnet.solana.com\" ) as client : res = await client . is_connected () print ( res ) # True # Alternatively, close the client explicitly instead of using a context manager: client = AsyncClient ( \"https://api.devnet.solana.com\" ) res = await client . is_connected () print ( res ) # True await client . close () asyncio . run ( main ())","title":"Async API Client"},{"location":"#websockets-client","text":"import asyncio from asyncstdlib import enumerate from solana.rpc.websocket_api import connect async def main (): async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : await websocket . logs_subscribe () first_resp = await websocket . recv () subscription_id = first_resp [ 0 ] . result next_resp = await websocket . recv () print ( next_resp ) await websocket . logs_unsubscribe ( subscription_id ) # Alternatively, use the client as an infinite asynchronous iterator: async with connect ( \"wss://api.devnet.solana.com\" ) as websocket : await websocket . logs_subscribe () first_resp = await websocket . recv () subscription_id = first_resp [ 0 ] . result async for idx , msg in enumerate ( websocket ): if idx == 3 : break print ( msg ) await websocket . logs_unsubscribe ( subscription_id ) asyncio . run ( main ())","title":"Websockets Client"},{"location":"#development","text":"","title":"\ud83d\udd28 Development"},{"location":"#setup","text":"Install poetry Install dev dependencies: poetry install Activate the poetry shell. poetry shell","title":"Setup"},{"location":"#lint","text":"make lint","title":"Lint"},{"location":"#tests","text":"# All tests make tests # Unit tests only make unit-tests # Integration tests only make int-tests","title":"Tests"},{"location":"core/blockhash/","text":"Blockhash solana.blockhash Blockhash utils. BlockhashCache A recent blockhash cache that expires after a given number of seconds. Parameters: Name Type Description Default ttl int Seconds until cached blockhash expires. 60 Source code in solana/blockhash.py class BlockhashCache : \"\"\"A recent blockhash cache that expires after a given number of seconds. Args: ttl: Seconds until cached blockhash expires. \"\"\" def __init__ ( self , ttl : int = 60 ) -> None : \"\"\"Instantiate the cache (you only need to do this once).\"\"\" maxsize = 300 self . unused_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) self . used_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) def set ( self , blockhash : Hash , slot : int , used_immediately : bool = False ) -> None : \"\"\"Update the cache. Args: blockhash: new blockhash value. slot: the slot which the blockhash came from. used_immediately: whether the client used the blockhash immediately after fetching it. \"\"\" if used_immediately : if slot not in self . used_blockhashes : self . used_blockhashes [ slot ] = blockhash return if slot in self . used_blockhashes or slot in self . unused_blockhashes : return self . unused_blockhashes [ slot ] = blockhash def get ( self ) -> Hash : \"\"\"Get the cached blockhash. Raises KeyError if cache has expired. Returns: cached blockhash. \"\"\" try : slot , blockhash = self . unused_blockhashes . popitem () self . used_blockhashes [ slot ] = blockhash except KeyError : with self . used_blockhashes . timer : # type: ignore blockhash = self . used_blockhashes [ min ( self . used_blockhashes )] # raises ValueError if used_blockhashes is empty return blockhash __init__ ( self , ttl = 60 ) special Instantiate the cache (you only need to do this once). Source code in solana/blockhash.py def __init__ ( self , ttl : int = 60 ) -> None : \"\"\"Instantiate the cache (you only need to do this once).\"\"\" maxsize = 300 self . unused_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) self . used_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) get ( self ) Get the cached blockhash. Raises KeyError if cache has expired. Returns: Type Description Hash cached blockhash. Source code in solana/blockhash.py def get ( self ) -> Hash : \"\"\"Get the cached blockhash. Raises KeyError if cache has expired. Returns: cached blockhash. \"\"\" try : slot , blockhash = self . unused_blockhashes . popitem () self . used_blockhashes [ slot ] = blockhash except KeyError : with self . used_blockhashes . timer : # type: ignore blockhash = self . used_blockhashes [ min ( self . used_blockhashes )] # raises ValueError if used_blockhashes is empty return blockhash set ( self , blockhash , slot , used_immediately = False ) Update the cache. Parameters: Name Type Description Default blockhash Hash new blockhash value. required slot int the slot which the blockhash came from. required used_immediately bool whether the client used the blockhash immediately after fetching it. False Source code in solana/blockhash.py def set ( self , blockhash : Hash , slot : int , used_immediately : bool = False ) -> None : \"\"\"Update the cache. Args: blockhash: new blockhash value. slot: the slot which the blockhash came from. used_immediately: whether the client used the blockhash immediately after fetching it. \"\"\" if used_immediately : if slot not in self . used_blockhashes : self . used_blockhashes [ slot ] = blockhash return if slot in self . used_blockhashes or slot in self . unused_blockhashes : return self . unused_blockhashes [ slot ] = blockhash","title":"Blockhash"},{"location":"core/blockhash/#blockhash","text":"","title":"Blockhash"},{"location":"core/blockhash/#solana.blockhash","text":"Blockhash utils.","title":"blockhash"},{"location":"core/blockhash/#solana.blockhash.BlockhashCache","text":"A recent blockhash cache that expires after a given number of seconds. Parameters: Name Type Description Default ttl int Seconds until cached blockhash expires. 60 Source code in solana/blockhash.py class BlockhashCache : \"\"\"A recent blockhash cache that expires after a given number of seconds. Args: ttl: Seconds until cached blockhash expires. \"\"\" def __init__ ( self , ttl : int = 60 ) -> None : \"\"\"Instantiate the cache (you only need to do this once).\"\"\" maxsize = 300 self . unused_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) self . used_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) def set ( self , blockhash : Hash , slot : int , used_immediately : bool = False ) -> None : \"\"\"Update the cache. Args: blockhash: new blockhash value. slot: the slot which the blockhash came from. used_immediately: whether the client used the blockhash immediately after fetching it. \"\"\" if used_immediately : if slot not in self . used_blockhashes : self . used_blockhashes [ slot ] = blockhash return if slot in self . used_blockhashes or slot in self . unused_blockhashes : return self . unused_blockhashes [ slot ] = blockhash def get ( self ) -> Hash : \"\"\"Get the cached blockhash. Raises KeyError if cache has expired. Returns: cached blockhash. \"\"\" try : slot , blockhash = self . unused_blockhashes . popitem () self . used_blockhashes [ slot ] = blockhash except KeyError : with self . used_blockhashes . timer : # type: ignore blockhash = self . used_blockhashes [ min ( self . used_blockhashes )] # raises ValueError if used_blockhashes is empty return blockhash","title":"BlockhashCache"},{"location":"core/blockhash/#solana.blockhash.BlockhashCache.__init__","text":"Instantiate the cache (you only need to do this once). Source code in solana/blockhash.py def __init__ ( self , ttl : int = 60 ) -> None : \"\"\"Instantiate the cache (you only need to do this once).\"\"\" maxsize = 300 self . unused_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl ) self . used_blockhashes : TTLCache = TTLCache ( maxsize = maxsize , ttl = ttl )","title":"__init__()"},{"location":"core/blockhash/#solana.blockhash.BlockhashCache.get","text":"Get the cached blockhash. Raises KeyError if cache has expired. Returns: Type Description Hash cached blockhash. Source code in solana/blockhash.py def get ( self ) -> Hash : \"\"\"Get the cached blockhash. Raises KeyError if cache has expired. Returns: cached blockhash. \"\"\" try : slot , blockhash = self . unused_blockhashes . popitem () self . used_blockhashes [ slot ] = blockhash except KeyError : with self . used_blockhashes . timer : # type: ignore blockhash = self . used_blockhashes [ min ( self . used_blockhashes )] # raises ValueError if used_blockhashes is empty return blockhash","title":"get()"},{"location":"core/blockhash/#solana.blockhash.BlockhashCache.set","text":"Update the cache. Parameters: Name Type Description Default blockhash Hash new blockhash value. required slot int the slot which the blockhash came from. required used_immediately bool whether the client used the blockhash immediately after fetching it. False Source code in solana/blockhash.py def set ( self , blockhash : Hash , slot : int , used_immediately : bool = False ) -> None : \"\"\"Update the cache. Args: blockhash: new blockhash value. slot: the slot which the blockhash came from. used_immediately: whether the client used the blockhash immediately after fetching it. \"\"\" if used_immediately : if slot not in self . used_blockhashes : self . used_blockhashes [ slot ] = blockhash return if slot in self . used_blockhashes or slot in self . unused_blockhashes : return self . unused_blockhashes [ slot ] = blockhash","title":"set()"},{"location":"core/transaction/","text":"Transaction solana.transaction Library to package an atomic sequence of instructions to a transaction. PACKET_DATA_SIZE Constant for maximum over-the-wire size of a Transaction. NonceInformation NonceInformation to be used to build a Transaction. Source code in solana/transaction.py class NonceInformation ( NamedTuple ): \"\"\"NonceInformation to be used to build a Transaction.\"\"\" nonce : Blockhash \"\"\"The current Nonce blockhash.\"\"\" nonce_instruction : Instruction \"\"\"AdvanceNonceAccount Instruction.\"\"\" nonce : Hash The current Nonce blockhash. nonce_instruction : Instruction AdvanceNonceAccount Instruction. Transaction Transaction class to represent an atomic transaction. Parameters: Name Type Description Default recent_blockhash Optional[Blockhash] A recent transaction id. None nonce_info Optional[NonceInformation] Nonce information. If populated, transaction will use a durable Nonce hash instead of a recent_blockhash . None fee_payer Optional[Pubkey] The transaction fee payer. None instructions Optional[Sequence[Instruction]] The instructions to be executed in this transaction. None Source code in solana/transaction.py class Transaction : \"\"\"Transaction class to represent an atomic transaction. Args: recent_blockhash: A recent transaction id. nonce_info: Nonce information. If populated, transaction will use a durable Nonce hash instead of a `recent_blockhash`. fee_payer: The transaction fee payer. instructions: The instructions to be executed in this transaction. \"\"\" # Default (empty) signature __DEFAULT_SIG = bytes ( 64 ) def __init__ ( self , recent_blockhash : Optional [ Blockhash ] = None , nonce_info : Optional [ NonceInformation ] = None , fee_payer : Optional [ Pubkey ] = None , instructions : Optional [ Sequence [ Instruction ]] = None , ) -> None : \"\"\"Init transaction object.\"\"\" self . _solders = _build_solders_tx ( recent_blockhash = recent_blockhash , nonce_info = nonce_info , fee_payer = fee_payer , instructions = instructions , ) @classmethod def from_solders ( cls , txn : SoldersTx ) -> Transaction : \"\"\"Convert from a `solders` transaction. Args: txn: The `solders` transaction. Returns: The `solana-py` transaction. \"\"\" new_tx = cls () new_tx . _solders = txn return new_tx def to_solders ( self ) -> SoldersTx : \"\"\"Convert to a `solders` transaction. Returns: The `solders` transaction. \"\"\" return self . _solders def __eq__ ( self , other : Any ) -> bool : \"\"\"Equality defintion for Transactions.\"\"\" if not isinstance ( other , Transaction ): return False return self . to_solders () == other . to_solders () @property def recent_blockhash ( self ) -> Optional [ Blockhash ]: \"\"\"Optional[Blockhash]: The blockhash assigned to this transaction.\"\"\" return self . _solders . message . recent_blockhash @recent_blockhash . setter def recent_blockhash ( self , blockhash : Optional [ Blockhash ]) -> None : # noqa: D102 self . _solders = _build_solders_tx ( recent_blockhash = blockhash , nonce_info = None , fee_payer = self . fee_payer , instructions = self . instructions , ) @property def fee_payer ( self ) -> Optional [ Pubkey ]: \"\"\"Optional[Pubkey]: The transaction fee payer.\"\"\" account_keys = self . _solders . message . account_keys return account_keys [ 0 ] if account_keys else None @fee_payer . setter def fee_payer ( self , payer : Optional [ Pubkey ]) -> None : # noqa: D102 self . _solders = _build_solders_tx ( recent_blockhash = self . recent_blockhash , nonce_info = None , fee_payer = payer , instructions = self . instructions , ) @property def instructions ( self ) -> Tuple [ Instruction , ... ]: \"\"\"Tuple[Instruction]: The instructions contained in this transaction.\"\"\" msg = self . _solders . message return tuple ( _decompile_instructions ( msg )) @instructions . setter def instructions ( self , ixns : Sequence [ Instruction ]) -> None : # noqa: D102 self . _solders = _build_solders_tx ( recent_blockhash = self . recent_blockhash , nonce_info = None , fee_payer = self . fee_payer , instructions = ixns , ) @property def signatures ( self ) -> Tuple [ Signature , ... ]: \"\"\"Tuple[Signature]: Signatures for the transaction.\"\"\" return tuple ( self . _solders . signatures ) def signature ( self ) -> Signature : \"\"\"The first (payer) Transaction signature. Returns: The payer signature. \"\"\" return self . _solders . signatures [ 0 ] def add ( self , * args : Union [ Transaction , Instruction ]) -> Transaction : \"\"\"Add one or more instructions to this Transaction. Args: *args: The instructions to add to this Transaction. If a `Transaction` is passsed, the instructions will be extracted from it. Returns: The transaction with the added instructions. \"\"\" for arg in args : if isinstance ( arg , Transaction ): self . instructions = self . instructions + arg . instructions elif isinstance ( arg , Instruction ): self . instructions = ( * self . instructions , arg ) else : raise ValueError ( \"invalid instruction:\" , arg ) return self def compile_message ( self ) -> Message : # pylint: disable=too-many-locals \"\"\"Compile transaction data. Returns: The compiled message. \"\"\" return self . _solders . message def serialize_message ( self ) -> bytes : \"\"\"Get raw transaction data that need to be covered by signatures. Returns: The serialized message. \"\"\" return bytes ( self . compile_message ()) def sign_partial ( self , * partial_signers : Keypair ) -> None : \"\"\"Partially sign a Transaction with the specified keypairs. All the caveats from the `sign` method apply to `sign_partial` \"\"\" self . _solders . partial_sign ( partial_signers , self . _solders . message . recent_blockhash ) def sign ( self , * signers : Keypair ) -> None : \"\"\"Sign the Transaction with the specified accounts. Multiple signatures may be applied to a Transaction. The first signature is considered \"primary\" and is used when testing for Transaction confirmation. Transaction fields should not be modified after the first call to `sign`, as doing so may invalidate the signature and cause the Transaction to be rejected. The Transaction must be assigned a valid `recent_blockhash` before invoking this method. \"\"\" self . _solders . sign ( signers , self . _solders . message . recent_blockhash ) def add_signature ( self , pubkey : Pubkey , signature : Signature ) -> None : \"\"\"Add an externally created signature to a transaction. Args: pubkey: The public key that created the signature. signature: The signature to add. \"\"\" presigner = Presigner ( pubkey , signature ) self . _solders . partial_sign ([ presigner ], self . _solders . message . recent_blockhash ) def verify_signatures ( self ) -> bool : \"\"\"Verify signatures of a complete, signed Transaction. Returns: a bool indicating if the signatures are correct or not. \"\"\" try : self . _solders . verify () except TransactionError : return False return True def serialize ( self , verify_signatures : bool = True ) -> bytes : \"\"\"Serialize the Transaction in the wire format. The Transaction must have a valid `signature` before invoking this method. verify_signatures can be added if the signature does not require to be verified. Args: verify_signatures: a bool indicating to verify the signature or not. Defaults to True Example: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solders.hash import Hash >>> from solders.system_program import transfer, TransferParams >>> leading_zeros = [0] * 31 >>> seed = bytes(leading_zeros + [1]) >>> sender, receiver = Keypair.from_seed(seed), Pubkey(leading_zeros + [2]) >>> transfer_tx = Transaction().add(transfer(TransferParams(from_pubkey=sender.pubkey(), to_pubkey=receiver, lamports=1000))) >>> transfer_tx.recent_blockhash = Hash(leading_zeros + [3]) >>> transfer_tx.sign(sender) >>> transfer_tx.serialize().hex() '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa275a23ba504674c8fbbb724827b23b42dc8e08019e23120f1b6f40f9799355ce54185b4415be37ca2cee6e0e010001034cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba2900000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301020200010c02000000e803000000000000' Returns: The serialized transaction. \"\"\" # noqa: E501 pylint: disable=line-too-long if self . signatures == [ Signature . default () for sig in self . signatures ]: raise AttributeError ( \"transaction has not been signed\" ) if verify_signatures and not self . verify_signatures (): raise AttributeError ( \"transaction has not been signed correctly\" ) return bytes ( self . _solders ) @classmethod def deserialize ( cls , raw_transaction : bytes ) -> Transaction : \"\"\"Parse a wire transaction into a Transaction object. Example: >>> raw_transaction = bytes.fromhex( ... '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa2' ... '75a23ba504674c8fbbb724827b23b42dc8e08019e23' ... '120f1b6f40f9799355ce54185b4415be37ca2cee6e0' ... 'e010001034cb5abf6ad79fbf5abbccafcc269d85cd2' ... '651ed4b885b5869f241aedf0a5ba290000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000200000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '000000301020200010c02000000e803000000000000' ... ) >>> type(Transaction.deserialize(raw_transaction)) <class 'solana.transaction.Transaction'> Returns: The deserialized transaction. \"\"\" return cls . from_solders ( SoldersTx . from_bytes ( raw_transaction )) @classmethod def populate ( cls , message : Message , signatures : List [ Signature ]) -> Transaction : \"\"\"Populate Transaction object from message and signatures. Example: >>> raw_message = bytes.fromhex( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> from solders.message import Message >>> from solders.signature import Signature >>> msg = Message.from_bytes(raw_message) >>> signatures = [Signature(bytes([1] * Signature.LENGTH)), Signature(bytes([2] * Signature.LENGTH))] >>> type(Transaction.populate(msg, signatures)) <class 'solana.transaction.Transaction'> Returns: The populated transaction. \"\"\" return cls . from_solders ( SoldersTx . populate ( message , signatures )) fee_payer : Optional [ Pubkey ] property writable Optional[Pubkey]: The transaction fee payer. instructions : Tuple [ Instruction , ... ] property writable Tuple[Instruction]: The instructions contained in this transaction. recent_blockhash : Optional [ Blockhash ] property writable Optional[Blockhash]: The blockhash assigned to this transaction. signatures : Tuple [ Signature , ... ] property readonly Tuple[Signature]: Signatures for the transaction. __init__ ( self , recent_blockhash = None , nonce_info = None , fee_payer = None , instructions = None ) special Init transaction object. Source code in solana/transaction.py def __init__ ( self , recent_blockhash : Optional [ Blockhash ] = None , nonce_info : Optional [ NonceInformation ] = None , fee_payer : Optional [ Pubkey ] = None , instructions : Optional [ Sequence [ Instruction ]] = None , ) -> None : \"\"\"Init transaction object.\"\"\" self . _solders = _build_solders_tx ( recent_blockhash = recent_blockhash , nonce_info = nonce_info , fee_payer = fee_payer , instructions = instructions , ) add ( self , * args ) Add one or more instructions to this Transaction. Parameters: Name Type Description Default *args Union[Transaction, Instruction] The instructions to add to this Transaction. If a Transaction is passsed, the instructions will be extracted from it. () Returns: Type Description Transaction The transaction with the added instructions. Source code in solana/transaction.py def add ( self , * args : Union [ Transaction , Instruction ]) -> Transaction : \"\"\"Add one or more instructions to this Transaction. Args: *args: The instructions to add to this Transaction. If a `Transaction` is passsed, the instructions will be extracted from it. Returns: The transaction with the added instructions. \"\"\" for arg in args : if isinstance ( arg , Transaction ): self . instructions = self . instructions + arg . instructions elif isinstance ( arg , Instruction ): self . instructions = ( * self . instructions , arg ) else : raise ValueError ( \"invalid instruction:\" , arg ) return self add_signature ( self , pubkey , signature ) Add an externally created signature to a transaction. Parameters: Name Type Description Default pubkey Pubkey The public key that created the signature. required signature Signature The signature to add. required Source code in solana/transaction.py def add_signature ( self , pubkey : Pubkey , signature : Signature ) -> None : \"\"\"Add an externally created signature to a transaction. Args: pubkey: The public key that created the signature. signature: The signature to add. \"\"\" presigner = Presigner ( pubkey , signature ) self . _solders . partial_sign ([ presigner ], self . _solders . message . recent_blockhash ) compile_message ( self ) Compile transaction data. Returns: Type Description Message The compiled message. Source code in solana/transaction.py def compile_message ( self ) -> Message : # pylint: disable=too-many-locals \"\"\"Compile transaction data. Returns: The compiled message. \"\"\" return self . _solders . message deserialize ( raw_transaction ) classmethod Parse a wire transaction into a Transaction object. Examples: >>> raw_transaction = bytes . fromhex ( ... '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa2' ... '75a23ba504674c8fbbb724827b23b42dc8e08019e23' ... '120f1b6f40f9799355ce54185b4415be37ca2cee6e0' ... 'e010001034cb5abf6ad79fbf5abbccafcc269d85cd2' ... '651ed4b885b5869f241aedf0a5ba290000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000200000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '000000301020200010c02000000e803000000000000' ... ) >>> type ( Transaction . deserialize ( raw_transaction )) < class ' solana . transaction . Transaction '> Returns: Type Description Transaction The deserialized transaction. Source code in solana/transaction.py @classmethod def deserialize ( cls , raw_transaction : bytes ) -> Transaction : \"\"\"Parse a wire transaction into a Transaction object. Example: >>> raw_transaction = bytes.fromhex( ... '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa2' ... '75a23ba504674c8fbbb724827b23b42dc8e08019e23' ... '120f1b6f40f9799355ce54185b4415be37ca2cee6e0' ... 'e010001034cb5abf6ad79fbf5abbccafcc269d85cd2' ... '651ed4b885b5869f241aedf0a5ba290000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000200000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '000000301020200010c02000000e803000000000000' ... ) >>> type(Transaction.deserialize(raw_transaction)) <class 'solana.transaction.Transaction'> Returns: The deserialized transaction. \"\"\" return cls . from_solders ( SoldersTx . from_bytes ( raw_transaction )) from_solders ( txn ) classmethod Convert from a solders transaction. Parameters: Name Type Description Default txn SoldersTx The solders transaction. required Returns: Type Description Transaction The solana-py transaction. Source code in solana/transaction.py @classmethod def from_solders ( cls , txn : SoldersTx ) -> Transaction : \"\"\"Convert from a `solders` transaction. Args: txn: The `solders` transaction. Returns: The `solana-py` transaction. \"\"\" new_tx = cls () new_tx . _solders = txn return new_tx populate ( message , signatures ) classmethod Populate Transaction object from message and signatures. Examples: >>> raw_message = bytes . fromhex ( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> from solders.message import Message >>> from solders.signature import Signature >>> msg = Message . from_bytes ( raw_message ) >>> signatures = [ Signature ( bytes ([ 1 ] * Signature . LENGTH )), Signature ( bytes ([ 2 ] * Signature . LENGTH ))] >>> type ( Transaction . populate ( msg , signatures )) < class ' solana . transaction . Transaction '> Returns: Type Description Transaction The populated transaction. Source code in solana/transaction.py @classmethod def populate ( cls , message : Message , signatures : List [ Signature ]) -> Transaction : \"\"\"Populate Transaction object from message and signatures. Example: >>> raw_message = bytes.fromhex( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> from solders.message import Message >>> from solders.signature import Signature >>> msg = Message.from_bytes(raw_message) >>> signatures = [Signature(bytes([1] * Signature.LENGTH)), Signature(bytes([2] * Signature.LENGTH))] >>> type(Transaction.populate(msg, signatures)) <class 'solana.transaction.Transaction'> Returns: The populated transaction. \"\"\" return cls . from_solders ( SoldersTx . populate ( message , signatures )) serialize ( self , verify_signatures = True ) Serialize the Transaction in the wire format. The Transaction must have a valid signature before invoking this method. verify_signatures can be added if the signature does not require to be verified. Parameters: Name Type Description Default verify_signatures bool a bool indicating to verify the signature or not. Defaults to True True Examples: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solders.hash import Hash >>> from solders.system_program import transfer , TransferParams >>> leading_zeros = [ 0 ] * 31 >>> seed = bytes ( leading_zeros + [ 1 ]) >>> sender , receiver = Keypair . from_seed ( seed ), Pubkey ( leading_zeros + [ 2 ]) >>> transfer_tx = Transaction () . add ( transfer ( TransferParams ( from_pubkey = sender . pubkey (), to_pubkey = receiver , lamports = 1000 ))) >>> transfer_tx . recent_blockhash = Hash ( leading_zeros + [ 3 ]) >>> transfer_tx . sign ( sender ) >>> transfer_tx . serialize () . hex () '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa275a23ba504674c8fbbb724827b23b42dc8e08019e23120f1b6f40f9799355ce54185b4415be37ca2cee6e0e010001034cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba2900000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301020200010c02000000e803000000000000' Returns: Type Description bytes The serialized transaction. Source code in solana/transaction.py def serialize ( self , verify_signatures : bool = True ) -> bytes : \"\"\"Serialize the Transaction in the wire format. The Transaction must have a valid `signature` before invoking this method. verify_signatures can be added if the signature does not require to be verified. Args: verify_signatures: a bool indicating to verify the signature or not. Defaults to True Example: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solders.hash import Hash >>> from solders.system_program import transfer, TransferParams >>> leading_zeros = [0] * 31 >>> seed = bytes(leading_zeros + [1]) >>> sender, receiver = Keypair.from_seed(seed), Pubkey(leading_zeros + [2]) >>> transfer_tx = Transaction().add(transfer(TransferParams(from_pubkey=sender.pubkey(), to_pubkey=receiver, lamports=1000))) >>> transfer_tx.recent_blockhash = Hash(leading_zeros + [3]) >>> transfer_tx.sign(sender) >>> transfer_tx.serialize().hex() '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa275a23ba504674c8fbbb724827b23b42dc8e08019e23120f1b6f40f9799355ce54185b4415be37ca2cee6e0e010001034cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba2900000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301020200010c02000000e803000000000000' Returns: The serialized transaction. \"\"\" # noqa: E501 pylint: disable=line-too-long if self . signatures == [ Signature . default () for sig in self . signatures ]: raise AttributeError ( \"transaction has not been signed\" ) if verify_signatures and not self . verify_signatures (): raise AttributeError ( \"transaction has not been signed correctly\" ) return bytes ( self . _solders ) serialize_message ( self ) Get raw transaction data that need to be covered by signatures. Returns: Type Description bytes The serialized message. Source code in solana/transaction.py def serialize_message ( self ) -> bytes : \"\"\"Get raw transaction data that need to be covered by signatures. Returns: The serialized message. \"\"\" return bytes ( self . compile_message ()) sign ( self , * signers ) Sign the Transaction with the specified accounts. Multiple signatures may be applied to a Transaction. The first signature is considered \"primary\" and is used when testing for Transaction confirmation. Transaction fields should not be modified after the first call to sign , as doing so may invalidate the signature and cause the Transaction to be rejected. The Transaction must be assigned a valid recent_blockhash before invoking this method. Source code in solana/transaction.py def sign ( self , * signers : Keypair ) -> None : \"\"\"Sign the Transaction with the specified accounts. Multiple signatures may be applied to a Transaction. The first signature is considered \"primary\" and is used when testing for Transaction confirmation. Transaction fields should not be modified after the first call to `sign`, as doing so may invalidate the signature and cause the Transaction to be rejected. The Transaction must be assigned a valid `recent_blockhash` before invoking this method. \"\"\" self . _solders . sign ( signers , self . _solders . message . recent_blockhash ) sign_partial ( self , * partial_signers ) Partially sign a Transaction with the specified keypairs. All the caveats from the sign method apply to sign_partial Source code in solana/transaction.py def sign_partial ( self , * partial_signers : Keypair ) -> None : \"\"\"Partially sign a Transaction with the specified keypairs. All the caveats from the `sign` method apply to `sign_partial` \"\"\" self . _solders . partial_sign ( partial_signers , self . _solders . message . recent_blockhash ) signature ( self ) The first (payer) Transaction signature. Returns: Type Description Signature The payer signature. Source code in solana/transaction.py def signature ( self ) -> Signature : \"\"\"The first (payer) Transaction signature. Returns: The payer signature. \"\"\" return self . _solders . signatures [ 0 ] to_solders ( self ) Convert to a solders transaction. Returns: Type Description SoldersTx The solders transaction. Source code in solana/transaction.py def to_solders ( self ) -> SoldersTx : \"\"\"Convert to a `solders` transaction. Returns: The `solders` transaction. \"\"\" return self . _solders verify_signatures ( self ) Verify signatures of a complete, signed Transaction. Returns: Type Description bool a bool indicating if the signatures are correct or not. Source code in solana/transaction.py def verify_signatures ( self ) -> bool : \"\"\"Verify signatures of a complete, signed Transaction. Returns: a bool indicating if the signatures are correct or not. \"\"\" try : self . _solders . verify () except TransactionError : return False return True","title":"Transaction"},{"location":"core/transaction/#transaction","text":"","title":"Transaction"},{"location":"core/transaction/#solana.transaction","text":"Library to package an atomic sequence of instructions to a transaction.","title":"transaction"},{"location":"core/transaction/#solana.transaction.PACKET_DATA_SIZE","text":"Constant for maximum over-the-wire size of a Transaction.","title":"PACKET_DATA_SIZE"},{"location":"core/transaction/#solana.transaction.NonceInformation","text":"NonceInformation to be used to build a Transaction. Source code in solana/transaction.py class NonceInformation ( NamedTuple ): \"\"\"NonceInformation to be used to build a Transaction.\"\"\" nonce : Blockhash \"\"\"The current Nonce blockhash.\"\"\" nonce_instruction : Instruction \"\"\"AdvanceNonceAccount Instruction.\"\"\"","title":"NonceInformation"},{"location":"core/transaction/#solana.transaction.NonceInformation.nonce","text":"The current Nonce blockhash.","title":"nonce"},{"location":"core/transaction/#solana.transaction.NonceInformation.nonce_instruction","text":"AdvanceNonceAccount Instruction.","title":"nonce_instruction"},{"location":"core/transaction/#solana.transaction.Transaction","text":"Transaction class to represent an atomic transaction. Parameters: Name Type Description Default recent_blockhash Optional[Blockhash] A recent transaction id. None nonce_info Optional[NonceInformation] Nonce information. If populated, transaction will use a durable Nonce hash instead of a recent_blockhash . None fee_payer Optional[Pubkey] The transaction fee payer. None instructions Optional[Sequence[Instruction]] The instructions to be executed in this transaction. None Source code in solana/transaction.py class Transaction : \"\"\"Transaction class to represent an atomic transaction. Args: recent_blockhash: A recent transaction id. nonce_info: Nonce information. If populated, transaction will use a durable Nonce hash instead of a `recent_blockhash`. fee_payer: The transaction fee payer. instructions: The instructions to be executed in this transaction. \"\"\" # Default (empty) signature __DEFAULT_SIG = bytes ( 64 ) def __init__ ( self , recent_blockhash : Optional [ Blockhash ] = None , nonce_info : Optional [ NonceInformation ] = None , fee_payer : Optional [ Pubkey ] = None , instructions : Optional [ Sequence [ Instruction ]] = None , ) -> None : \"\"\"Init transaction object.\"\"\" self . _solders = _build_solders_tx ( recent_blockhash = recent_blockhash , nonce_info = nonce_info , fee_payer = fee_payer , instructions = instructions , ) @classmethod def from_solders ( cls , txn : SoldersTx ) -> Transaction : \"\"\"Convert from a `solders` transaction. Args: txn: The `solders` transaction. Returns: The `solana-py` transaction. \"\"\" new_tx = cls () new_tx . _solders = txn return new_tx def to_solders ( self ) -> SoldersTx : \"\"\"Convert to a `solders` transaction. Returns: The `solders` transaction. \"\"\" return self . _solders def __eq__ ( self , other : Any ) -> bool : \"\"\"Equality defintion for Transactions.\"\"\" if not isinstance ( other , Transaction ): return False return self . to_solders () == other . to_solders () @property def recent_blockhash ( self ) -> Optional [ Blockhash ]: \"\"\"Optional[Blockhash]: The blockhash assigned to this transaction.\"\"\" return self . _solders . message . recent_blockhash @recent_blockhash . setter def recent_blockhash ( self , blockhash : Optional [ Blockhash ]) -> None : # noqa: D102 self . _solders = _build_solders_tx ( recent_blockhash = blockhash , nonce_info = None , fee_payer = self . fee_payer , instructions = self . instructions , ) @property def fee_payer ( self ) -> Optional [ Pubkey ]: \"\"\"Optional[Pubkey]: The transaction fee payer.\"\"\" account_keys = self . _solders . message . account_keys return account_keys [ 0 ] if account_keys else None @fee_payer . setter def fee_payer ( self , payer : Optional [ Pubkey ]) -> None : # noqa: D102 self . _solders = _build_solders_tx ( recent_blockhash = self . recent_blockhash , nonce_info = None , fee_payer = payer , instructions = self . instructions , ) @property def instructions ( self ) -> Tuple [ Instruction , ... ]: \"\"\"Tuple[Instruction]: The instructions contained in this transaction.\"\"\" msg = self . _solders . message return tuple ( _decompile_instructions ( msg )) @instructions . setter def instructions ( self , ixns : Sequence [ Instruction ]) -> None : # noqa: D102 self . _solders = _build_solders_tx ( recent_blockhash = self . recent_blockhash , nonce_info = None , fee_payer = self . fee_payer , instructions = ixns , ) @property def signatures ( self ) -> Tuple [ Signature , ... ]: \"\"\"Tuple[Signature]: Signatures for the transaction.\"\"\" return tuple ( self . _solders . signatures ) def signature ( self ) -> Signature : \"\"\"The first (payer) Transaction signature. Returns: The payer signature. \"\"\" return self . _solders . signatures [ 0 ] def add ( self , * args : Union [ Transaction , Instruction ]) -> Transaction : \"\"\"Add one or more instructions to this Transaction. Args: *args: The instructions to add to this Transaction. If a `Transaction` is passsed, the instructions will be extracted from it. Returns: The transaction with the added instructions. \"\"\" for arg in args : if isinstance ( arg , Transaction ): self . instructions = self . instructions + arg . instructions elif isinstance ( arg , Instruction ): self . instructions = ( * self . instructions , arg ) else : raise ValueError ( \"invalid instruction:\" , arg ) return self def compile_message ( self ) -> Message : # pylint: disable=too-many-locals \"\"\"Compile transaction data. Returns: The compiled message. \"\"\" return self . _solders . message def serialize_message ( self ) -> bytes : \"\"\"Get raw transaction data that need to be covered by signatures. Returns: The serialized message. \"\"\" return bytes ( self . compile_message ()) def sign_partial ( self , * partial_signers : Keypair ) -> None : \"\"\"Partially sign a Transaction with the specified keypairs. All the caveats from the `sign` method apply to `sign_partial` \"\"\" self . _solders . partial_sign ( partial_signers , self . _solders . message . recent_blockhash ) def sign ( self , * signers : Keypair ) -> None : \"\"\"Sign the Transaction with the specified accounts. Multiple signatures may be applied to a Transaction. The first signature is considered \"primary\" and is used when testing for Transaction confirmation. Transaction fields should not be modified after the first call to `sign`, as doing so may invalidate the signature and cause the Transaction to be rejected. The Transaction must be assigned a valid `recent_blockhash` before invoking this method. \"\"\" self . _solders . sign ( signers , self . _solders . message . recent_blockhash ) def add_signature ( self , pubkey : Pubkey , signature : Signature ) -> None : \"\"\"Add an externally created signature to a transaction. Args: pubkey: The public key that created the signature. signature: The signature to add. \"\"\" presigner = Presigner ( pubkey , signature ) self . _solders . partial_sign ([ presigner ], self . _solders . message . recent_blockhash ) def verify_signatures ( self ) -> bool : \"\"\"Verify signatures of a complete, signed Transaction. Returns: a bool indicating if the signatures are correct or not. \"\"\" try : self . _solders . verify () except TransactionError : return False return True def serialize ( self , verify_signatures : bool = True ) -> bytes : \"\"\"Serialize the Transaction in the wire format. The Transaction must have a valid `signature` before invoking this method. verify_signatures can be added if the signature does not require to be verified. Args: verify_signatures: a bool indicating to verify the signature or not. Defaults to True Example: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solders.hash import Hash >>> from solders.system_program import transfer, TransferParams >>> leading_zeros = [0] * 31 >>> seed = bytes(leading_zeros + [1]) >>> sender, receiver = Keypair.from_seed(seed), Pubkey(leading_zeros + [2]) >>> transfer_tx = Transaction().add(transfer(TransferParams(from_pubkey=sender.pubkey(), to_pubkey=receiver, lamports=1000))) >>> transfer_tx.recent_blockhash = Hash(leading_zeros + [3]) >>> transfer_tx.sign(sender) >>> transfer_tx.serialize().hex() '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa275a23ba504674c8fbbb724827b23b42dc8e08019e23120f1b6f40f9799355ce54185b4415be37ca2cee6e0e010001034cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba2900000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301020200010c02000000e803000000000000' Returns: The serialized transaction. \"\"\" # noqa: E501 pylint: disable=line-too-long if self . signatures == [ Signature . default () for sig in self . signatures ]: raise AttributeError ( \"transaction has not been signed\" ) if verify_signatures and not self . verify_signatures (): raise AttributeError ( \"transaction has not been signed correctly\" ) return bytes ( self . _solders ) @classmethod def deserialize ( cls , raw_transaction : bytes ) -> Transaction : \"\"\"Parse a wire transaction into a Transaction object. Example: >>> raw_transaction = bytes.fromhex( ... '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa2' ... '75a23ba504674c8fbbb724827b23b42dc8e08019e23' ... '120f1b6f40f9799355ce54185b4415be37ca2cee6e0' ... 'e010001034cb5abf6ad79fbf5abbccafcc269d85cd2' ... '651ed4b885b5869f241aedf0a5ba290000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000200000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '000000301020200010c02000000e803000000000000' ... ) >>> type(Transaction.deserialize(raw_transaction)) <class 'solana.transaction.Transaction'> Returns: The deserialized transaction. \"\"\" return cls . from_solders ( SoldersTx . from_bytes ( raw_transaction )) @classmethod def populate ( cls , message : Message , signatures : List [ Signature ]) -> Transaction : \"\"\"Populate Transaction object from message and signatures. Example: >>> raw_message = bytes.fromhex( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> from solders.message import Message >>> from solders.signature import Signature >>> msg = Message.from_bytes(raw_message) >>> signatures = [Signature(bytes([1] * Signature.LENGTH)), Signature(bytes([2] * Signature.LENGTH))] >>> type(Transaction.populate(msg, signatures)) <class 'solana.transaction.Transaction'> Returns: The populated transaction. \"\"\" return cls . from_solders ( SoldersTx . populate ( message , signatures ))","title":"Transaction"},{"location":"core/transaction/#solana.transaction.Transaction.fee_payer","text":"Optional[Pubkey]: The transaction fee payer.","title":"fee_payer"},{"location":"core/transaction/#solana.transaction.Transaction.instructions","text":"Tuple[Instruction]: The instructions contained in this transaction.","title":"instructions"},{"location":"core/transaction/#solana.transaction.Transaction.recent_blockhash","text":"Optional[Blockhash]: The blockhash assigned to this transaction.","title":"recent_blockhash"},{"location":"core/transaction/#solana.transaction.Transaction.signatures","text":"Tuple[Signature]: Signatures for the transaction.","title":"signatures"},{"location":"core/transaction/#solana.transaction.Transaction.__init__","text":"Init transaction object. Source code in solana/transaction.py def __init__ ( self , recent_blockhash : Optional [ Blockhash ] = None , nonce_info : Optional [ NonceInformation ] = None , fee_payer : Optional [ Pubkey ] = None , instructions : Optional [ Sequence [ Instruction ]] = None , ) -> None : \"\"\"Init transaction object.\"\"\" self . _solders = _build_solders_tx ( recent_blockhash = recent_blockhash , nonce_info = nonce_info , fee_payer = fee_payer , instructions = instructions , )","title":"__init__()"},{"location":"core/transaction/#solana.transaction.Transaction.add","text":"Add one or more instructions to this Transaction. Parameters: Name Type Description Default *args Union[Transaction, Instruction] The instructions to add to this Transaction. If a Transaction is passsed, the instructions will be extracted from it. () Returns: Type Description Transaction The transaction with the added instructions. Source code in solana/transaction.py def add ( self , * args : Union [ Transaction , Instruction ]) -> Transaction : \"\"\"Add one or more instructions to this Transaction. Args: *args: The instructions to add to this Transaction. If a `Transaction` is passsed, the instructions will be extracted from it. Returns: The transaction with the added instructions. \"\"\" for arg in args : if isinstance ( arg , Transaction ): self . instructions = self . instructions + arg . instructions elif isinstance ( arg , Instruction ): self . instructions = ( * self . instructions , arg ) else : raise ValueError ( \"invalid instruction:\" , arg ) return self","title":"add()"},{"location":"core/transaction/#solana.transaction.Transaction.add_signature","text":"Add an externally created signature to a transaction. Parameters: Name Type Description Default pubkey Pubkey The public key that created the signature. required signature Signature The signature to add. required Source code in solana/transaction.py def add_signature ( self , pubkey : Pubkey , signature : Signature ) -> None : \"\"\"Add an externally created signature to a transaction. Args: pubkey: The public key that created the signature. signature: The signature to add. \"\"\" presigner = Presigner ( pubkey , signature ) self . _solders . partial_sign ([ presigner ], self . _solders . message . recent_blockhash )","title":"add_signature()"},{"location":"core/transaction/#solana.transaction.Transaction.compile_message","text":"Compile transaction data. Returns: Type Description Message The compiled message. Source code in solana/transaction.py def compile_message ( self ) -> Message : # pylint: disable=too-many-locals \"\"\"Compile transaction data. Returns: The compiled message. \"\"\" return self . _solders . message","title":"compile_message()"},{"location":"core/transaction/#solana.transaction.Transaction.deserialize","text":"Parse a wire transaction into a Transaction object. Examples: >>> raw_transaction = bytes . fromhex ( ... '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa2' ... '75a23ba504674c8fbbb724827b23b42dc8e08019e23' ... '120f1b6f40f9799355ce54185b4415be37ca2cee6e0' ... 'e010001034cb5abf6ad79fbf5abbccafcc269d85cd2' ... '651ed4b885b5869f241aedf0a5ba290000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000200000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '000000301020200010c02000000e803000000000000' ... ) >>> type ( Transaction . deserialize ( raw_transaction )) < class ' solana . transaction . Transaction '> Returns: Type Description Transaction The deserialized transaction. Source code in solana/transaction.py @classmethod def deserialize ( cls , raw_transaction : bytes ) -> Transaction : \"\"\"Parse a wire transaction into a Transaction object. Example: >>> raw_transaction = bytes.fromhex( ... '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa2' ... '75a23ba504674c8fbbb724827b23b42dc8e08019e23' ... '120f1b6f40f9799355ce54185b4415be37ca2cee6e0' ... 'e010001034cb5abf6ad79fbf5abbccafcc269d85cd2' ... '651ed4b885b5869f241aedf0a5ba290000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000200000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '0000000000000000000000000000000000000000000' ... '000000301020200010c02000000e803000000000000' ... ) >>> type(Transaction.deserialize(raw_transaction)) <class 'solana.transaction.Transaction'> Returns: The deserialized transaction. \"\"\" return cls . from_solders ( SoldersTx . from_bytes ( raw_transaction ))","title":"deserialize()"},{"location":"core/transaction/#solana.transaction.Transaction.from_solders","text":"Convert from a solders transaction. Parameters: Name Type Description Default txn SoldersTx The solders transaction. required Returns: Type Description Transaction The solana-py transaction. Source code in solana/transaction.py @classmethod def from_solders ( cls , txn : SoldersTx ) -> Transaction : \"\"\"Convert from a `solders` transaction. Args: txn: The `solders` transaction. Returns: The `solana-py` transaction. \"\"\" new_tx = cls () new_tx . _solders = txn return new_tx","title":"from_solders()"},{"location":"core/transaction/#solana.transaction.Transaction.populate","text":"Populate Transaction object from message and signatures. Examples: >>> raw_message = bytes . fromhex ( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> from solders.message import Message >>> from solders.signature import Signature >>> msg = Message . from_bytes ( raw_message ) >>> signatures = [ Signature ( bytes ([ 1 ] * Signature . LENGTH )), Signature ( bytes ([ 2 ] * Signature . LENGTH ))] >>> type ( Transaction . populate ( msg , signatures )) < class ' solana . transaction . Transaction '> Returns: Type Description Transaction The populated transaction. Source code in solana/transaction.py @classmethod def populate ( cls , message : Message , signatures : List [ Signature ]) -> Transaction : \"\"\"Populate Transaction object from message and signatures. Example: >>> raw_message = bytes.fromhex( ... '0200030500000000000000000000000000000000000000000000' ... '0000000000000000000100000000000000000000000000000000' ... '0000000000000000000000000000000200000000000000000000' ... '0000000000000000000000000000000000000000000300000000' ... '0000000000000000000000000000000000000000000000000000' ... '0004000000000000000000000000000000000000000000000000' ... '0000000000000005c49ae77603782054f17a9decea43b444eba0' ... 'edb12c6f1d31c6e0e4a84bf052eb010403010203050909090909' ... ) >>> from solders.message import Message >>> from solders.signature import Signature >>> msg = Message.from_bytes(raw_message) >>> signatures = [Signature(bytes([1] * Signature.LENGTH)), Signature(bytes([2] * Signature.LENGTH))] >>> type(Transaction.populate(msg, signatures)) <class 'solana.transaction.Transaction'> Returns: The populated transaction. \"\"\" return cls . from_solders ( SoldersTx . populate ( message , signatures ))","title":"populate()"},{"location":"core/transaction/#solana.transaction.Transaction.serialize","text":"Serialize the Transaction in the wire format. The Transaction must have a valid signature before invoking this method. verify_signatures can be added if the signature does not require to be verified. Parameters: Name Type Description Default verify_signatures bool a bool indicating to verify the signature or not. Defaults to True True Examples: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solders.hash import Hash >>> from solders.system_program import transfer , TransferParams >>> leading_zeros = [ 0 ] * 31 >>> seed = bytes ( leading_zeros + [ 1 ]) >>> sender , receiver = Keypair . from_seed ( seed ), Pubkey ( leading_zeros + [ 2 ]) >>> transfer_tx = Transaction () . add ( transfer ( TransferParams ( from_pubkey = sender . pubkey (), to_pubkey = receiver , lamports = 1000 ))) >>> transfer_tx . recent_blockhash = Hash ( leading_zeros + [ 3 ]) >>> transfer_tx . sign ( sender ) >>> transfer_tx . serialize () . hex () '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa275a23ba504674c8fbbb724827b23b42dc8e08019e23120f1b6f40f9799355ce54185b4415be37ca2cee6e0e010001034cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba2900000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301020200010c02000000e803000000000000' Returns: Type Description bytes The serialized transaction. Source code in solana/transaction.py def serialize ( self , verify_signatures : bool = True ) -> bytes : \"\"\"Serialize the Transaction in the wire format. The Transaction must have a valid `signature` before invoking this method. verify_signatures can be added if the signature does not require to be verified. Args: verify_signatures: a bool indicating to verify the signature or not. Defaults to True Example: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solders.hash import Hash >>> from solders.system_program import transfer, TransferParams >>> leading_zeros = [0] * 31 >>> seed = bytes(leading_zeros + [1]) >>> sender, receiver = Keypair.from_seed(seed), Pubkey(leading_zeros + [2]) >>> transfer_tx = Transaction().add(transfer(TransferParams(from_pubkey=sender.pubkey(), to_pubkey=receiver, lamports=1000))) >>> transfer_tx.recent_blockhash = Hash(leading_zeros + [3]) >>> transfer_tx.sign(sender) >>> transfer_tx.serialize().hex() '019d53be8af3a7c30f86c1092d2c3ea61d270c0cfa275a23ba504674c8fbbb724827b23b42dc8e08019e23120f1b6f40f9799355ce54185b4415be37ca2cee6e0e010001034cb5abf6ad79fbf5abbccafcc269d85cd2651ed4b885b5869f241aedf0a5ba2900000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000301020200010c02000000e803000000000000' Returns: The serialized transaction. \"\"\" # noqa: E501 pylint: disable=line-too-long if self . signatures == [ Signature . default () for sig in self . signatures ]: raise AttributeError ( \"transaction has not been signed\" ) if verify_signatures and not self . verify_signatures (): raise AttributeError ( \"transaction has not been signed correctly\" ) return bytes ( self . _solders )","title":"serialize()"},{"location":"core/transaction/#solana.transaction.Transaction.serialize_message","text":"Get raw transaction data that need to be covered by signatures. Returns: Type Description bytes The serialized message. Source code in solana/transaction.py def serialize_message ( self ) -> bytes : \"\"\"Get raw transaction data that need to be covered by signatures. Returns: The serialized message. \"\"\" return bytes ( self . compile_message ())","title":"serialize_message()"},{"location":"core/transaction/#solana.transaction.Transaction.sign","text":"Sign the Transaction with the specified accounts. Multiple signatures may be applied to a Transaction. The first signature is considered \"primary\" and is used when testing for Transaction confirmation. Transaction fields should not be modified after the first call to sign , as doing so may invalidate the signature and cause the Transaction to be rejected. The Transaction must be assigned a valid recent_blockhash before invoking this method. Source code in solana/transaction.py def sign ( self , * signers : Keypair ) -> None : \"\"\"Sign the Transaction with the specified accounts. Multiple signatures may be applied to a Transaction. The first signature is considered \"primary\" and is used when testing for Transaction confirmation. Transaction fields should not be modified after the first call to `sign`, as doing so may invalidate the signature and cause the Transaction to be rejected. The Transaction must be assigned a valid `recent_blockhash` before invoking this method. \"\"\" self . _solders . sign ( signers , self . _solders . message . recent_blockhash )","title":"sign()"},{"location":"core/transaction/#solana.transaction.Transaction.sign_partial","text":"Partially sign a Transaction with the specified keypairs. All the caveats from the sign method apply to sign_partial Source code in solana/transaction.py def sign_partial ( self , * partial_signers : Keypair ) -> None : \"\"\"Partially sign a Transaction with the specified keypairs. All the caveats from the `sign` method apply to `sign_partial` \"\"\" self . _solders . partial_sign ( partial_signers , self . _solders . message . recent_blockhash )","title":"sign_partial()"},{"location":"core/transaction/#solana.transaction.Transaction.signature","text":"The first (payer) Transaction signature. Returns: Type Description Signature The payer signature. Source code in solana/transaction.py def signature ( self ) -> Signature : \"\"\"The first (payer) Transaction signature. Returns: The payer signature. \"\"\" return self . _solders . signatures [ 0 ]","title":"signature()"},{"location":"core/transaction/#solana.transaction.Transaction.to_solders","text":"Convert to a solders transaction. Returns: Type Description SoldersTx The solders transaction. Source code in solana/transaction.py def to_solders ( self ) -> SoldersTx : \"\"\"Convert to a `solders` transaction. Returns: The `solders` transaction. \"\"\" return self . _solders","title":"to_solders()"},{"location":"core/transaction/#solana.transaction.Transaction.verify_signatures","text":"Verify signatures of a complete, signed Transaction. Returns: Type Description bool a bool indicating if the signatures are correct or not. Source code in solana/transaction.py def verify_signatures ( self ) -> bool : \"\"\"Verify signatures of a complete, signed Transaction. Returns: a bool indicating if the signatures are correct or not. \"\"\" try : self . _solders . verify () except TransactionError : return False return True","title":"verify_signatures()"},{"location":"core/utils/","text":"Utils solana.utils special Utility functions for solanaweb3. cluster Tools for getting RPC cluster information. ClusterUrls A collection of urls for each cluster. Source code in solana/utils/cluster.py class ClusterUrls ( NamedTuple ): \"\"\"A collection of urls for each cluster.\"\"\" devnet : str testnet : str mainnet_beta : str Endpoint Container for http and https cluster urls. Source code in solana/utils/cluster.py class Endpoint ( NamedTuple ): \"\"\"Container for http and https cluster urls.\"\"\" http : ClusterUrls https : ClusterUrls cluster_api_url ( cluster = None , tls = True ) Retrieve the RPC API URL for the specified cluster. :param cluster: The name of the cluster to use. :param tls: If True, use https. Defaults to True. Source code in solana/utils/cluster.py def cluster_api_url ( cluster : Optional [ Cluster ] = None , tls : bool = True ) -> str : \"\"\"Retrieve the RPC API URL for the specified cluster. :param cluster: The name of the cluster to use. :param tls: If True, use https. Defaults to True. \"\"\" urls = ENDPOINT . https if tls else ENDPOINT . http if cluster is None : return urls . devnet return getattr ( urls , cluster ) security_txt Utils for security.txt. FOOTER Footer of the security.txt. HEADER Header of the security.txt. NoSecurityTxtFoundError Raise when security text is not found. Source code in solana/utils/security_txt.py class NoSecurityTxtFoundError ( Exception ): \"\"\"Raise when security text is not found.\"\"\" SecurityTxt dataclass Security txt data. Source code in solana/utils/security_txt.py @dataclass class SecurityTxt : \"\"\"Security txt data.\"\"\" # pylint: disable=too-many-instance-attributes name : str project_url : str contacts : str policy : str preferred_languages : Optional [ str ] = None source_code : Optional [ str ] = None encryption : Optional [ str ] = None auditors : Optional [ str ] = None acknowledgements : Optional [ str ] = None expiry : Optional [ str ] = None parse_security_txt ( data ) Parse and extract security.txt section from the data section of the compiled program. Parameters: Name Type Description Default data bytes Program data in bytes from the ProgramAccount. required Returns: Type Description SecurityTxt The Security Txt. Source code in solana/utils/security_txt.py def parse_security_txt ( data : bytes ) -> SecurityTxt : \"\"\"Parse and extract security.txt section from the data section of the compiled program. Args: data: Program data in bytes from the ProgramAccount. Returns: The Security Txt. \"\"\" if not isinstance ( data , bytes ): raise TypeError ( f \"data provided in parse(data) must be bytes, found: { type ( data ) } \" ) s_idx = data . find ( bytes ( HEADER , \"utf-8\" )) e_idx = data . find ( bytes ( FOOTER , \"utf-8\" )) if s_idx == - 1 : raise NoSecurityTxtFoundError ( \"Program doesn't have security.txt section\" ) content_arr = data [ s_idx + len ( HEADER ) : e_idx ] content_da : List [ Any ] = [[]] for char in content_arr : if char == 0 : content_da . append ([]) else : content_da [ len ( content_da ) - 1 ] . append ( chr ( char )) content_da . pop () content_dict = {} for idx , content in enumerate ( content_da ): content_da [ idx ] = \"\" . join ( content ) for iidx , idata in enumerate ( content_da ): if any ( idata == x . name for x in fields ( SecurityTxt )): next_key = iidx + 1 content_dict . update ({ str ( idata ): content_da [ next_key ]}) try : security_txt = SecurityTxt ( ** content_dict ) except TypeError as err : raise err return security_txt validate Validation utilities. validate_instruction_keys ( instruction , expected ) Verify length of AccountMeta list of a transaction instruction is at least the expected length. Parameters: Name Type Description Default instruction Instruction A Instruction object. required expected int The expected length. required Source code in solana/utils/validate.py def validate_instruction_keys ( instruction : Instruction , expected : int ) -> None : \"\"\"Verify length of AccountMeta list of a transaction instruction is at least the expected length. Args: instruction: A Instruction object. expected: The expected length. \"\"\" if len ( instruction . accounts ) < expected : raise ValueError ( f \"invalid instruction: found { len ( instruction . accounts ) } keys, expected at least { expected } \" ) validate_instruction_type ( parsed_data , expected_type ) Check that the instruction type of the parsed data matches the expected instruction type. Parameters: Name Type Description Default parsed_data Any Parsed instruction data object with instruction_type field. required expected_type IntEnum The expected instruction type. required Source code in solana/utils/validate.py def validate_instruction_type ( parsed_data : Any , expected_type : IntEnum ) -> None : \"\"\"Check that the instruction type of the parsed data matches the expected instruction type. Args: parsed_data: Parsed instruction data object with `instruction_type` field. expected_type: The expected instruction type. \"\"\" if parsed_data . instruction_type != expected_type : raise ValueError ( f \"invalid instruction; instruction index mismatch { parsed_data . instruction_type } != { expected_type } \" )","title":"Utils"},{"location":"core/utils/#utils","text":"","title":"Utils"},{"location":"core/utils/#solana.utils","text":"Utility functions for solanaweb3.","title":"utils"},{"location":"core/utils/#solana.utils.cluster","text":"Tools for getting RPC cluster information.","title":"cluster"},{"location":"core/utils/#solana.utils.cluster.ClusterUrls","text":"A collection of urls for each cluster. Source code in solana/utils/cluster.py class ClusterUrls ( NamedTuple ): \"\"\"A collection of urls for each cluster.\"\"\" devnet : str testnet : str mainnet_beta : str","title":"ClusterUrls"},{"location":"core/utils/#solana.utils.cluster.Endpoint","text":"Container for http and https cluster urls. Source code in solana/utils/cluster.py class Endpoint ( NamedTuple ): \"\"\"Container for http and https cluster urls.\"\"\" http : ClusterUrls https : ClusterUrls","title":"Endpoint"},{"location":"core/utils/#solana.utils.cluster.cluster_api_url","text":"Retrieve the RPC API URL for the specified cluster. :param cluster: The name of the cluster to use. :param tls: If True, use https. Defaults to True. Source code in solana/utils/cluster.py def cluster_api_url ( cluster : Optional [ Cluster ] = None , tls : bool = True ) -> str : \"\"\"Retrieve the RPC API URL for the specified cluster. :param cluster: The name of the cluster to use. :param tls: If True, use https. Defaults to True. \"\"\" urls = ENDPOINT . https if tls else ENDPOINT . http if cluster is None : return urls . devnet return getattr ( urls , cluster )","title":"cluster_api_url()"},{"location":"core/utils/#solana.utils.security_txt","text":"Utils for security.txt.","title":"security_txt"},{"location":"core/utils/#solana.utils.security_txt.FOOTER","text":"Footer of the security.txt.","title":"FOOTER"},{"location":"core/utils/#solana.utils.security_txt.HEADER","text":"Header of the security.txt.","title":"HEADER"},{"location":"core/utils/#solana.utils.security_txt.NoSecurityTxtFoundError","text":"Raise when security text is not found. Source code in solana/utils/security_txt.py class NoSecurityTxtFoundError ( Exception ): \"\"\"Raise when security text is not found.\"\"\"","title":"NoSecurityTxtFoundError"},{"location":"core/utils/#solana.utils.security_txt.SecurityTxt","text":"Security txt data. Source code in solana/utils/security_txt.py @dataclass class SecurityTxt : \"\"\"Security txt data.\"\"\" # pylint: disable=too-many-instance-attributes name : str project_url : str contacts : str policy : str preferred_languages : Optional [ str ] = None source_code : Optional [ str ] = None encryption : Optional [ str ] = None auditors : Optional [ str ] = None acknowledgements : Optional [ str ] = None expiry : Optional [ str ] = None","title":"SecurityTxt"},{"location":"core/utils/#solana.utils.security_txt.parse_security_txt","text":"Parse and extract security.txt section from the data section of the compiled program. Parameters: Name Type Description Default data bytes Program data in bytes from the ProgramAccount. required Returns: Type Description SecurityTxt The Security Txt. Source code in solana/utils/security_txt.py def parse_security_txt ( data : bytes ) -> SecurityTxt : \"\"\"Parse and extract security.txt section from the data section of the compiled program. Args: data: Program data in bytes from the ProgramAccount. Returns: The Security Txt. \"\"\" if not isinstance ( data , bytes ): raise TypeError ( f \"data provided in parse(data) must be bytes, found: { type ( data ) } \" ) s_idx = data . find ( bytes ( HEADER , \"utf-8\" )) e_idx = data . find ( bytes ( FOOTER , \"utf-8\" )) if s_idx == - 1 : raise NoSecurityTxtFoundError ( \"Program doesn't have security.txt section\" ) content_arr = data [ s_idx + len ( HEADER ) : e_idx ] content_da : List [ Any ] = [[]] for char in content_arr : if char == 0 : content_da . append ([]) else : content_da [ len ( content_da ) - 1 ] . append ( chr ( char )) content_da . pop () content_dict = {} for idx , content in enumerate ( content_da ): content_da [ idx ] = \"\" . join ( content ) for iidx , idata in enumerate ( content_da ): if any ( idata == x . name for x in fields ( SecurityTxt )): next_key = iidx + 1 content_dict . update ({ str ( idata ): content_da [ next_key ]}) try : security_txt = SecurityTxt ( ** content_dict ) except TypeError as err : raise err return security_txt","title":"parse_security_txt()"},{"location":"core/utils/#solana.utils.validate","text":"Validation utilities.","title":"validate"},{"location":"core/utils/#solana.utils.validate.validate_instruction_keys","text":"Verify length of AccountMeta list of a transaction instruction is at least the expected length. Parameters: Name Type Description Default instruction Instruction A Instruction object. required expected int The expected length. required Source code in solana/utils/validate.py def validate_instruction_keys ( instruction : Instruction , expected : int ) -> None : \"\"\"Verify length of AccountMeta list of a transaction instruction is at least the expected length. Args: instruction: A Instruction object. expected: The expected length. \"\"\" if len ( instruction . accounts ) < expected : raise ValueError ( f \"invalid instruction: found { len ( instruction . accounts ) } keys, expected at least { expected } \" )","title":"validate_instruction_keys()"},{"location":"core/utils/#solana.utils.validate.validate_instruction_type","text":"Check that the instruction type of the parsed data matches the expected instruction type. Parameters: Name Type Description Default parsed_data Any Parsed instruction data object with instruction_type field. required expected_type IntEnum The expected instruction type. required Source code in solana/utils/validate.py def validate_instruction_type ( parsed_data : Any , expected_type : IntEnum ) -> None : \"\"\"Check that the instruction type of the parsed data matches the expected instruction type. Args: parsed_data: Parsed instruction data object with `instruction_type` field. expected_type: The expected instruction type. \"\"\" if parsed_data . instruction_type != expected_type : raise ValueError ( f \"invalid instruction; instruction index mismatch { parsed_data . instruction_type } != { expected_type } \" )","title":"validate_instruction_type()"},{"location":"core/vote_program/","text":"Vote Program solana.vote_program Library to interface with the vote program. VOTE_PROGRAM_ID : Pubkey Public key that identifies the Vote program. WithdrawFromVoteAccountParams Transfer SOL from vote account to identity. Source code in solana/vote_program.py class WithdrawFromVoteAccountParams ( NamedTuple ): \"\"\"Transfer SOL from vote account to identity.\"\"\" vote_account_from_pubkey : Pubkey \"\"\"\"\"\" to_pubkey : Pubkey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" withdrawer : Pubkey \"\"\"\"\"\" withdraw_from_vote_account ( params ) Generate an instruction that transfers lamports from a vote account to any other. Examples: >>> from solders.pubkey import Pubkey >>> from solders.keypair import Keypair >>> vote = Pubkey ([ 0 ] * 31 + [ 1 ]) >>> withdrawer = Keypair . from_seed ( bytes ([ 0 ] * 32 )) >>> instruction = withdraw_from_vote_account ( ... WithdrawFromVoteAccountParams ( ... vote_account_from_pubkey = vote , ... to_pubkey = withdrawer . pubkey (), ... withdrawer = withdrawer . pubkey (), ... lamports = 3_000_000_000 , ... ) ... ) >>> type ( instruction ) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The generated instruction. Source code in solana/vote_program.py def withdraw_from_vote_account ( params : WithdrawFromVoteAccountParams ) -> Instruction : \"\"\"Generate an instruction that transfers lamports from a vote account to any other. Example: >>> from solders.pubkey import Pubkey >>> from solders.keypair import Keypair >>> vote = Pubkey([0] * 31 + [1]) >>> withdrawer = Keypair.from_seed(bytes([0]*32)) >>> instruction = withdraw_from_vote_account( ... WithdrawFromVoteAccountParams( ... vote_account_from_pubkey=vote, ... to_pubkey=withdrawer.pubkey(), ... withdrawer=withdrawer.pubkey(), ... lamports=3_000_000_000, ... ) ... ) >>> type(instruction) <class 'solders.instruction.Instruction'> Returns: The generated instruction. \"\"\" data = VOTE_INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . WITHDRAW_FROM_VOTE_ACCOUNT , \"args\" : { \"lamports\" : params . lamports }, } ) return Instruction ( accounts = [ AccountMeta ( pubkey = params . vote_account_from_pubkey , is_signer = False , is_writable = True , ), AccountMeta ( pubkey = params . to_pubkey , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . withdrawer , is_signer = True , is_writable = True ), ], program_id = VOTE_PROGRAM_ID , data = data , )","title":"Vote Program"},{"location":"core/vote_program/#vote-program","text":"","title":"Vote Program"},{"location":"core/vote_program/#solana.vote_program","text":"Library to interface with the vote program.","title":"vote_program"},{"location":"core/vote_program/#solana.vote_program.VOTE_PROGRAM_ID","text":"Public key that identifies the Vote program.","title":"VOTE_PROGRAM_ID"},{"location":"core/vote_program/#solana.vote_program.WithdrawFromVoteAccountParams","text":"Transfer SOL from vote account to identity. Source code in solana/vote_program.py class WithdrawFromVoteAccountParams ( NamedTuple ): \"\"\"Transfer SOL from vote account to identity.\"\"\" vote_account_from_pubkey : Pubkey \"\"\"\"\"\" to_pubkey : Pubkey \"\"\"\"\"\" lamports : int \"\"\"\"\"\" withdrawer : Pubkey \"\"\"\"\"\"","title":"WithdrawFromVoteAccountParams"},{"location":"core/vote_program/#solana.vote_program.withdraw_from_vote_account","text":"Generate an instruction that transfers lamports from a vote account to any other. Examples: >>> from solders.pubkey import Pubkey >>> from solders.keypair import Keypair >>> vote = Pubkey ([ 0 ] * 31 + [ 1 ]) >>> withdrawer = Keypair . from_seed ( bytes ([ 0 ] * 32 )) >>> instruction = withdraw_from_vote_account ( ... WithdrawFromVoteAccountParams ( ... vote_account_from_pubkey = vote , ... to_pubkey = withdrawer . pubkey (), ... withdrawer = withdrawer . pubkey (), ... lamports = 3_000_000_000 , ... ) ... ) >>> type ( instruction ) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The generated instruction. Source code in solana/vote_program.py def withdraw_from_vote_account ( params : WithdrawFromVoteAccountParams ) -> Instruction : \"\"\"Generate an instruction that transfers lamports from a vote account to any other. Example: >>> from solders.pubkey import Pubkey >>> from solders.keypair import Keypair >>> vote = Pubkey([0] * 31 + [1]) >>> withdrawer = Keypair.from_seed(bytes([0]*32)) >>> instruction = withdraw_from_vote_account( ... WithdrawFromVoteAccountParams( ... vote_account_from_pubkey=vote, ... to_pubkey=withdrawer.pubkey(), ... withdrawer=withdrawer.pubkey(), ... lamports=3_000_000_000, ... ) ... ) >>> type(instruction) <class 'solders.instruction.Instruction'> Returns: The generated instruction. \"\"\" data = VOTE_INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . WITHDRAW_FROM_VOTE_ACCOUNT , \"args\" : { \"lamports\" : params . lamports }, } ) return Instruction ( accounts = [ AccountMeta ( pubkey = params . vote_account_from_pubkey , is_signer = False , is_writable = True , ), AccountMeta ( pubkey = params . to_pubkey , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . withdrawer , is_signer = True , is_writable = True ), ], program_id = VOTE_PROGRAM_ID , data = data , )","title":"withdraw_from_vote_account()"},{"location":"rpc/api/","text":"API Client solana.rpc.api API client to interact with the Solana JSON RPC Endpoint. Client Client class. Parameters: Name Type Description Default endpoint Optional[str] URL of the RPC endpoint. None commitment Optional[Commitment] Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None blockhash_cache Union[BlockhashCache, bool] (Experimental) If True, keep a cache of recent blockhashes to make send_transaction calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: Retrieve the oldest unused cached blockhash that is younger than ttl seconds, where ttl is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than ttl seconds. Fetch a new recent blockhash after sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your .send_transaction calls. False timeout float HTTP request timeout in seconds. 10 extra_headers Optional[Dict[str, str]] Extra headers to pass for HTTP request. None Source code in solana/rpc/api.py class Client ( _ClientCore ): # pylint: disable=too-many-public-methods \"\"\"Client class. Args: endpoint: URL of the RPC endpoint. commitment: Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". blockhash_cache: (Experimental) If True, keep a cache of recent blockhashes to make `send_transaction` calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: 1. Retrieve the oldest unused cached blockhash that is younger than `ttl` seconds, where `ttl` is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). 2. If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than `ttl` seconds. 3. Fetch a new recent blockhash *after* sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your `.send_transaction` calls. timeout: HTTP request timeout in seconds. extra_headers: Extra headers to pass for HTTP request. \"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , ): \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = http . HTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers ) def is_connected ( self ) -> bool : \"\"\"Health check. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.is_connected() # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return self . _provider . is_connected () def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_balance(Pubkey([0] * 31 + [1])).value # doctest: +SKIP 4104230290 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetBalanceResp ) def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key, encoded in either base58 or base64. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info(Pubkey([0] * 31 + [1])).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetAccountInfoResp ) def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key in parsed JSON format. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1])).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp ) def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_commitment(0).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return self . _provider . make_request ( body , GetBlockCommitmentResp ) def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_time(5).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return self . _provider . make_request ( body , GetBlockTimeResp ) def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_cluster_nodes().value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp ) def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : int = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block(1).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return self . _provider . make_request ( body , GetBlockResp ) def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_performance_samples(1).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return self . _provider . make_request ( body , GetRecentPerformanceSamplesResp ) def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_height().value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return self . _provider . make_request ( body , GetBlockHeightResp ) def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_blocks(5, 10).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return self . _provider . make_request ( body , GetBlocksResp ) def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> solana_client.get_signatures_for_address(pubkey, limit=1).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return self . _provider . make_request ( body , GetSignaturesForAddressResp ) def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> solana_client.get_transaction(sig).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return self . _provider . make_request ( body , GetTransactionResp ) def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_info().value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return self . _provider . make_request ( body , GetEpochInfoResp ) def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_schedule().value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp ) def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_for_message(txn.compile_message()).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return self . _provider . make_request ( body , GetFeeForMessageResp ) def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_first_available_block().value # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp ) def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_genesis_hash().value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp ) def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_identity().value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return self . _provider . make_request ( self . _get_identity , GetIdentityResp ) def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_governor().value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return self . _provider . make_request ( body , GetInflationGovernorResp ) def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_rate().value.epoch # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp ) def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_largest_accounts().value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return self . _provider . make_request ( body , GetLargestAccountsResp ) def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> list(solana_client.get_leader_schedule().value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return self . _provider . make_request ( body , GetLeaderScheduleResp ) def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_balance_for_rent_exemption(50).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp ) def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetMultipleAccountsResp ) def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys, in jsonParsed format if possible. If a parser cannot be found, the RPC server falls back to base64 encoding, Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts_json_parsed(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return self . _provider . make_request ( body , GetMultipleAccountsMaybeJsonParsedResp ) def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either \"base58\" (slow) or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsResp ) def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp ) def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_latest_blockhash().value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return self . _provider . make_request ( body , GetLatestBlockhashResp ) def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> solana_client.get_signature_statuses(sigs).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return self . _provider . make_request ( body , GetSignatureStatusesResp ) def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot().value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return self . _provider . make_request ( body , GetSlotResp ) def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot_leader().value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return self . _provider . make_request ( body , GetSlotLeaderResp ) def get_stake_activation ( self , pubkey : Pubkey , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetStakeActivationResp : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_stake_activation().value.active # doctest: +SKIP 124429280 \"\"\" body = self . _get_stake_activation_body ( pubkey , epoch , commitment ) return self . _provider . make_request ( body , GetStakeActivationResp ) def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_supply().value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return self . _provider . make_request ( body , GetSupplyResp ) def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> solana_client.get_token_account_balance(pubkey).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenAccountBalanceResp ) def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateResp ) def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp ) def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerResp ) def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp ) def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenLargestAccountsResp ) def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenSupplyResp ) def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction_count().value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return self . _provider . make_request ( body , GetTransactionCountResp ) def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_ledger_slot().value # doctest: +SKIP 1234 \"\"\" return self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp ) def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_version().value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return self . _provider . make_request ( self . _get_version , GetVersionResp ) def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_vote_accounts().value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( commitment ) return self . _provider . make_request ( body , GetVoteAccountsResp ) def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amout of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return self . _provider . make_request ( body , RequestAirdropResp ) def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return self . __post_send_with_confirm ( * post_send_args ) def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. signers: Signers to sign the transaction. Only supported for legacy Transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Only supported for legacy Transaction. Example: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solana.rpc.api import Client >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.send_transaction(txn, sender).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" if isinstance ( txn , VersionedTransaction ): if signers : msg = \"*signers args are not used when sending VersionedTransaction.\" raise ValueError ( msg ) if recent_blockhash is not None : msg = \"recent_blockhash arg is not used when sending VersionedTransaction.\" raise ValueError ( msg ) versioned_tx_opts = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts return self . send_raw_transaction ( bytes ( txn ), opts = versioned_tx_opts ) last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp . value . last_valid_block_height else : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp . value . last_valid_block_height txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height , ) if opts is None else opts ) txn_resp = self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = self . get_latest_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A transaction object. The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.deserialize(bytes.fromhex(full_signed_tx_hex)) >>> solana_client.simulate_transaction(tx).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment ) return self . _provider . make_request ( body , SimulateTransactionResp ) def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.validator_exit().value # doctest: +SKIP True \"\"\" return self . _provider . make_request ( self . _validator_exit , ValidatorExitResp ) def __post_send_with_confirm ( self , resp : SendTransactionResp , conf_comm : Commitment , last_valid_block_height : Optional [ int ], ) -> SendTransactionResp : resp = self . _post_send ( resp ) sig = resp . value self . _provider . logger . info ( \"Transaction sent to %s . Signature %s : \" , self . _provider . endpoint_uri , sig ) self . confirm_transaction ( sig , conf_comm , last_valid_block_height = last_valid_block_height ) return resp def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" timeout = time () + 90 commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = self . get_signature_statuses ([ tx_sig ]) if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( self . get_block_height ( commitment )) . value sleep ( sleep_seconds ) else : if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : while time () < timeout : resp = self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp __init__ ( self , endpoint = None , commitment = None , blockhash_cache = False , timeout = 10 , extra_headers = None ) special Init API client. Source code in solana/rpc/api.py def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , ): \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = http . HTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers ) confirm_transaction ( self , tx_sig , commitment = None , sleep_seconds = 0.5 , last_valid_block_height = None ) Confirm the transaction identified by the specified signature. Parameters: Name Type Description Default tx_sig Signature the transaction signature to confirm. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None sleep_seconds float The number of seconds to sleep when polling the signature status. 0.5 last_valid_block_height Optional[int] The block height by which the transaction would become invalid. None Source code in solana/rpc/api.py def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" timeout = time () + 90 commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = self . get_signature_statuses ([ tx_sig ]) if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( self . get_block_height ( commitment )) . value sleep ( sleep_seconds ) else : if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : while time () < timeout : resp = self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp get_account_info ( self , pubkey , commitment = None , encoding = 'base64' , data_slice = None ) Returns all the account info for the specified public key, encoded in either base58 or base64. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. 'base64' data_slice Optional[types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_account_info ( Pubkey ([ 0 ] * 31 + [ 1 ])) . value Account ( Account { lamports : 4104230290 , data . len : 0 , owner : 11111111111111111111111111111111 , executable : false , rent_epoch : 371 , }, ) Source code in solana/rpc/api.py def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key, encoded in either base58 or base64. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info(Pubkey([0] * 31 + [1])).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetAccountInfoResp ) get_account_info_json_parsed ( self , pubkey , commitment = None ) Returns all the account info for the specified public key in parsed JSON format. If JSON formatting is not available for this account, base64 is returned. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_account_info_json_parsed ( Pubkey ([ 0 ] * 31 + [ 1 ])) . value . owner Pubkey ( 11111111111111111111111111111111 , ) Source code in solana/rpc/api.py def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key in parsed JSON format. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1])).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp ) get_balance ( self , pubkey , commitment = None ) Returns the balance of the account of provided Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_balance ( Pubkey ([ 0 ] * 31 + [ 1 ])) . value 4104230290 Source code in solana/rpc/api.py def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_balance(Pubkey([0] * 31 + [1])).value # doctest: +SKIP 4104230290 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetBalanceResp ) get_block ( self , slot , encoding = 'json' , max_supported_transaction_version = None ) Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' max_supported_transaction_version int (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block ( 1 ) . value . blockhash Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/api.py def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : int = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block(1).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return self . _provider . make_request ( body , GetBlockResp ) get_block_commitment ( self , slot ) Fetch the commitment for particular block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_commitment ( 0 ) . total_stake 497717120 Source code in solana/rpc/api.py def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_commitment(0).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return self . _provider . make_request ( body , GetBlockCommitmentResp ) get_block_height ( self , commitment = None ) Returns the current block height of the node. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_height () . value 1233 Source code in solana/rpc/api.py def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_height().value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return self . _provider . make_request ( body , GetBlockHeightResp ) get_block_time ( self , slot ) Fetch the estimated production time of a block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_time ( 5 ) . value 1598400007 Source code in solana/rpc/api.py def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_time(5).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return self . _provider . make_request ( body , GetBlockTimeResp ) get_blocks ( self , start_slot , end_slot = None ) Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_blocks ( 5 , 10 ) . value [ 5 , 6 , 7 , 8 , 9 , 10 ] Source code in solana/rpc/api.py def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_blocks(5, 10).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return self . _provider . make_request ( body , GetBlocksResp ) get_cluster_nodes ( self ) Returns information about all the nodes participating in the cluster. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_cluster_nodes () . value [ 0 ] . tpu '139.178.65.155:8004' Source code in solana/rpc/api.py def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_cluster_nodes().value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp ) get_epoch_info ( self , commitment = None ) Returns information about the current epoch. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_epoch_info () . value . epoch 0 Source code in solana/rpc/api.py def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_info().value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return self . _provider . make_request ( body , GetEpochInfoResp ) get_epoch_schedule ( self ) Returns epoch schedule information from this cluster's genesis config. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_epoch_schedule () . value . slots_per_epoch 8192 Source code in solana/rpc/api.py def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_schedule().value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp ) get_fee_for_message ( self , message , commitment = None ) Returns the fee for a message. Parameters: Name Type Description Default message VersionedMessage Message that the fee is requested for. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))) >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_fee_for_message ( txn . compile_message ()) . value 5000 Source code in solana/rpc/api.py def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_for_message(txn.compile_message()).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return self . _provider . make_request ( body , GetFeeForMessageResp ) get_first_available_block ( self ) Returns the slot of the lowest confirmed block that has not been purged from the ledger. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_first_available_block () . value 1 Source code in solana/rpc/api.py def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_first_available_block().value # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp ) get_genesis_hash ( self ) Returns the genesis hash. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_genesis_hash () . value Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/api.py def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_genesis_hash().value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp ) get_identity ( self ) Returns the identity pubkey for the current node. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_identity () . value . identity Pubkey ( 2 LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv , ) Source code in solana/rpc/api.py def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_identity().value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return self . _provider . make_request ( self . _get_identity , GetIdentityResp ) get_inflation_governor ( self , commitment = None ) Returns the current inflation governor. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_governor () . value . foundation 0.05 Source code in solana/rpc/api.py def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_governor().value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return self . _provider . make_request ( body , GetInflationGovernorResp ) get_inflation_rate ( self ) Returns the specific inflation values for the current epoch. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_rate () . value . epoch 1 Source code in solana/rpc/api.py def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_rate().value.epoch # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp ) get_largest_accounts ( self , filter_opt = None , commitment = None ) Returns the 20 largest accounts, by lamport balance. Parameters: Name Type Description Default filter_opt Optional[str] Filter results by account type; currently supported: circulating|nonCirculating. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_largest_accounts () . value [ 0 ] . lamports 500000000000000000 Source code in solana/rpc/api.py def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_largest_accounts().value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return self . _provider . make_request ( body , GetLargestAccountsResp ) get_latest_blockhash ( self , commitment = None ) Returns the latest block hash from the ledger. Response also includes the last valid block height. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_latest_blockhash () . value RpcBlockhash { blockhash : Hash ( 4 TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT , ), last_valid_block_height : 158286487 , } Source code in solana/rpc/api.py def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_latest_blockhash().value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return self . _provider . make_request ( body , GetLatestBlockhashResp ) get_leader_schedule ( self , epoch = None , commitment = None ) Returns the leader schedule for an epoch. Parameters: Name Type Description Default epoch Optional[int] Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> list ( solana_client . get_leader_schedule () . value . items ())[ 0 ] ( Pubkey ( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr , ), [ 346448 , 346449 , 346450 , 346451 , 369140 , 369141 , 369142 , 369143 , 384204 , 384205 , 384206 , 384207 ]) Source code in solana/rpc/api.py def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> list(solana_client.get_leader_schedule().value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return self . _provider . make_request ( body , GetLeaderScheduleResp ) get_minimum_balance_for_rent_exemption ( self , usize , commitment = None ) Returns minimum balance required to make account rent exempt. Parameters: Name Type Description Default usize int Account data length. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_minimum_balance_for_rent_exemption ( 50 ) . value 1238880 Source code in solana/rpc/api.py def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_balance_for_rent_exemption(50).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp ) get_minimum_ledger_slot ( self ) Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_minimum_ledger_slot () . value 1234 Source code in solana/rpc/api.py def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_ledger_slot().value # doctest: +SKIP 1234 \"\"\" return self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp ) get_multiple_accounts ( self , pubkeys , commitment = None , encoding = 'base64' , data_slice = None ) Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. 'base64' data_slice Optional[types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> solana_client . get_multiple_accounts ( pubkeys ) . value [ 0 ] . lamports 1 Source code in solana/rpc/api.py def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetMultipleAccountsResp ) get_multiple_accounts_json_parsed ( self , pubkeys , commitment = None ) Returns all the account info for a list of public keys, in jsonParsed format if possible. If a parser cannot be found, the RPC server falls back to base64 encoding, Parameters: Name Type Description Default pubkeys List[Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> solana_client . get_multiple_accounts_json_parsed ( pubkeys ) . value [ 0 ] . lamports 1 Source code in solana/rpc/api.py def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys, in jsonParsed format if possible. If a parser cannot be found, the RPC server falls back to base64 encoding, Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts_json_parsed(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return self . _provider . make_request ( body , GetMultipleAccountsMaybeJsonParsedResp ) get_program_accounts ( self , pubkey , commitment = None , encoding = 'base64' , data_slice = None , filters = None ) Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for the returned Transaction, either \"base58\" (slow) or \"base64\". 'base64' data_slice Optional[types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and None ` length` fields; only available for \"base58\" or \"base64\" encoding. required filters Optional[Sequence[Union[int, types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List , Union >>> solana_client = Client ( \"http://localhost:8899\" ) >>> memcmp_opts = MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> solana_client . get_program_accounts ( pubkey , filters = filters ) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/api.py def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either \"base58\" (slow) or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsResp ) get_program_accounts_json_parsed ( self , pubkey , commitment = None , filters = None ) Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None filters Optional[Sequence[Union[int, types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List , Union >>> solana_client = Client ( \"http://localhost:8899\" ) >>> memcmp_opts = MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> solana_client . get_program_accounts ( pubkey , filters = filters ) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/api.py def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp ) get_recent_performance_samples ( self , limit = None ) Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: Name Type Description Default limit Optional[int] Limit (optional) number of samples to return (maximum 720) None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_recent_performance_samples ( 1 ) . value [ 0 ] RpcPerfSample ( RpcPerfSample { slot : 168036172 , num_transactions : 7159 , num_slots : 158 , sample_period_secs : 60 , }, ) Source code in solana/rpc/api.py def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_performance_samples(1).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return self . _provider . make_request ( body , GetRecentPerformanceSamplesResp ) get_signature_statuses ( self , signatures , search_transaction_history = False ) Returns the statuses of a list of signatures. Unless the search_transaction_history configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus MAX_RECENT_BLOCKHASHES rooted slots. Parameters: Name Type Description Default signatures List[Signature] An array of transaction signatures to confirm. required search_transaction_history bool If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. False Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\" , ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\" ] >>> sigs = [ Signature . from_string ( sig ) for sig in raw_sigs ] >>> solana_client . get_signature_statuses ( sigs ) . value [ 0 ] . confirmations 10 Source code in solana/rpc/api.py def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> solana_client.get_signature_statuses(sigs).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return self . _provider . make_request ( body , GetSignatureStatusesResp ) get_signatures_for_address ( self , account , before = None , until = None , limit = None , commitment = None ) Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Pubkey Account to be queried. required before Optional[Signature] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[Signature] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey . from_string ( \"Vote111111111111111111111111111111111111111\" ) >>> solana_client . get_signatures_for_address ( pubkey , limit = 1 ) . value [ 0 ] . signature Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> solana_client.get_signatures_for_address(pubkey, limit=1).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return self . _provider . make_request ( body , GetSignaturesForAddressResp ) get_slot ( self , commitment = None ) Returns the current slot the node is processing. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_slot () . value 7515 Source code in solana/rpc/api.py def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot().value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return self . _provider . make_request ( body , GetSlotResp ) get_slot_leader ( self , commitment = None ) Returns the current slot leader. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_slot_leader () . value Pubkey ( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV , ) Source code in solana/rpc/api.py def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot_leader().value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return self . _provider . make_request ( body , GetSlotLeaderResp ) get_stake_activation ( self , pubkey , epoch = None , commitment = None ) Returns epoch activation information for a stake account. Parameters: Name Type Description Default pubkey Pubkey Pubkey of stake account to query required epoch Optional[int] (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_stake_activation () . value . active 124429280 Source code in solana/rpc/api.py def get_stake_activation ( self , pubkey : Pubkey , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetStakeActivationResp : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_stake_activation().value.active # doctest: +SKIP 124429280 \"\"\" body = self . _get_stake_activation_body ( pubkey , epoch , commitment ) return self . _provider . make_request ( body , GetStakeActivationResp ) get_supply ( self , commitment = None ) Returns information about the current supply. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_supply () . value . circulating 683635192454157660 Source code in solana/rpc/api.py def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_supply().value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return self . _provider . make_request ( body , GetSupplyResp ) get_token_account_balance ( self , pubkey , commitment = None ) Returns the token balance of an SPL Token account (UNSTABLE). Parameters: Name Type Description Default pubkey Pubkey Pubkey of Token account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkey = Pubkey . from_string ( \"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\" ) >>> solana_client . get_token_account_balance ( pubkey ) . value . amount # noqa: E501 '9864' Source code in solana/rpc/api.py def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> solana_client.get_token_account_balance(pubkey).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenAccountBalanceResp ) get_token_accounts_by_delegate ( self , delegate , opts , commitment = None ) Returns all SPL Token accounts by approved Delegate (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateResp ) get_token_accounts_by_delegate_json_parsed ( self , delegate , opts , commitment = None ) Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp ) get_token_accounts_by_owner ( self , owner , opts , commitment = None ) Returns all SPL Token accounts by token owner (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerResp ) get_token_accounts_by_owner_json_parsed ( self , owner , opts , commitment = None ) Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp ) get_token_largest_accounts ( self , pubkey , commitment = None ) Returns the 20 largest accounts of a particular SPL Token type. Source code in solana/rpc/api.py def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenLargestAccountsResp ) get_token_supply ( self , pubkey , commitment = None ) Returns the total supply of an SPL Token type. Source code in solana/rpc/api.py def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenSupplyResp ) get_transaction ( self , tx_sig , encoding = 'json' , commitment = None , max_supported_transaction_version = None ) Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig Signature Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None max_supported_transaction_version Optional[int] (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> from solders.signature import Signature >>> sig = Signature . from_string ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" ) >>> solana_client . get_transaction ( sig ) . value . block_time 1234 Source code in solana/rpc/api.py def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> solana_client.get_transaction(sig).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return self . _provider . make_request ( body , GetTransactionResp ) get_transaction_count ( self , commitment = None ) Returns the current Transaction count from the ledger. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_transaction_count () . value 4554 Source code in solana/rpc/api.py def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction_count().value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return self . _provider . make_request ( body , GetTransactionCountResp ) get_version ( self ) Returns the current solana versions running on the node. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_version () . value . solana_core '1.13.2' Source code in solana/rpc/api.py def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_version().value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return self . _provider . make_request ( self . _get_version , GetVersionResp ) get_vote_accounts ( self , commitment = None ) Returns the account info and associated stake for all the voting accounts in the current bank. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_vote_accounts () . value . current [ 0 ] . commission 100 Source code in solana/rpc/api.py def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_vote_accounts().value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( commitment ) return self . _provider . make_request ( body , GetVoteAccountsResp ) is_connected ( self ) Health check. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . is_connected () True Returns: Type Description bool True if the client is connected. Source code in solana/rpc/api.py def is_connected ( self ) -> bool : \"\"\"Health check. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.is_connected() # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return self . _provider . is_connected () request_airdrop ( self , pubkey , lamports , commitment = None ) Requests an airdrop of lamports to a Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to receive lamports, as base-58 encoded string or public key object. required lamports int Amout of lamports. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . request_airdrop ( Pubkey ([ 0 ] * 31 + [ 1 ]), 10000 ) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amout of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return self . _provider . make_request ( body , RequestAirdropResp ) send_raw_transaction ( self , txn , opts = None ) Send a transaction that has already been signed and serialized into the wire format. Parameters: Name Type Description Default txn bytes Transaction bytes. required opts Optional[types.TxOpts] (optional) Transaction options. None Before submitting, the following preflight checks are performed (unless disabled with the skip_preflight option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> solana_client . send_raw_transaction ( bytes . fromhex ( full_signed_tx_hex )) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return self . __post_send_with_confirm ( * post_send_args ) send_transaction ( self , txn , * signers , * , opts = None , recent_blockhash = None ) Send a transaction. Parameters: Name Type Description Default txn Union[VersionedTransaction, Transaction] transaction object. required signers Keypair Signers to sign the transaction. Only supported for legacy Transaction. () opts Optional[types.TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Only supported for legacy Transaction. None Examples: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solana.rpc.api import Client >>> from solders.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))) >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . send_transaction ( txn , sender ) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. signers: Signers to sign the transaction. Only supported for legacy Transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Only supported for legacy Transaction. Example: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solana.rpc.api import Client >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.send_transaction(txn, sender).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" if isinstance ( txn , VersionedTransaction ): if signers : msg = \"*signers args are not used when sending VersionedTransaction.\" raise ValueError ( msg ) if recent_blockhash is not None : msg = \"recent_blockhash arg is not used when sending VersionedTransaction.\" raise ValueError ( msg ) versioned_tx_opts = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts return self . send_raw_transaction ( bytes ( txn ), opts = versioned_tx_opts ) last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp . value . last_valid_block_height else : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp . value . last_valid_block_height txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height , ) if opts is None else opts ) txn_resp = self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = self . get_latest_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp simulate_transaction ( self , txn , sig_verify = False , commitment = None ) Simulate sending a transaction. Parameters: Name Type Description Default txn Union[Transaction, VersionedTransaction] A transaction object. The transaction must have a valid blockhash, but is not required to be signed. required sig_verify bool If true the transaction signatures will be verified (default: false). False commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction . deserialize ( bytes . fromhex ( full_signed_tx_hex )) >>> solana_client . simulate_transaction ( tx ) . value . logs [ 'BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success' ] Source code in solana/rpc/api.py def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A transaction object. The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.deserialize(bytes.fromhex(full_signed_tx_hex)) >>> solana_client.simulate_transaction(tx).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment ) return self . _provider . make_request ( body , SimulateTransactionResp ) validator_exit ( self ) Request to have the validator exit. Validator must have booted with RPC exit enabled ( --enable-rpc-exit parameter). Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . validator_exit () . value True Source code in solana/rpc/api.py def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.validator_exit().value # doctest: +SKIP True \"\"\" return self . _provider . make_request ( self . _validator_exit , ValidatorExitResp )","title":"API Client"},{"location":"rpc/api/#api-client","text":"","title":"API Client"},{"location":"rpc/api/#solana.rpc.api","text":"API client to interact with the Solana JSON RPC Endpoint.","title":"api"},{"location":"rpc/api/#solana.rpc.api.Client","text":"Client class. Parameters: Name Type Description Default endpoint Optional[str] URL of the RPC endpoint. None commitment Optional[Commitment] Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None blockhash_cache Union[BlockhashCache, bool] (Experimental) If True, keep a cache of recent blockhashes to make send_transaction calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: Retrieve the oldest unused cached blockhash that is younger than ttl seconds, where ttl is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than ttl seconds. Fetch a new recent blockhash after sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your .send_transaction calls. False timeout float HTTP request timeout in seconds. 10 extra_headers Optional[Dict[str, str]] Extra headers to pass for HTTP request. None Source code in solana/rpc/api.py class Client ( _ClientCore ): # pylint: disable=too-many-public-methods \"\"\"Client class. Args: endpoint: URL of the RPC endpoint. commitment: Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". blockhash_cache: (Experimental) If True, keep a cache of recent blockhashes to make `send_transaction` calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: 1. Retrieve the oldest unused cached blockhash that is younger than `ttl` seconds, where `ttl` is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). 2. If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than `ttl` seconds. 3. Fetch a new recent blockhash *after* sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your `.send_transaction` calls. timeout: HTTP request timeout in seconds. extra_headers: Extra headers to pass for HTTP request. \"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , ): \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = http . HTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers ) def is_connected ( self ) -> bool : \"\"\"Health check. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.is_connected() # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return self . _provider . is_connected () def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_balance(Pubkey([0] * 31 + [1])).value # doctest: +SKIP 4104230290 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetBalanceResp ) def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key, encoded in either base58 or base64. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info(Pubkey([0] * 31 + [1])).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetAccountInfoResp ) def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key in parsed JSON format. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1])).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp ) def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_commitment(0).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return self . _provider . make_request ( body , GetBlockCommitmentResp ) def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_time(5).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return self . _provider . make_request ( body , GetBlockTimeResp ) def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_cluster_nodes().value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp ) def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : int = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block(1).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return self . _provider . make_request ( body , GetBlockResp ) def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_performance_samples(1).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return self . _provider . make_request ( body , GetRecentPerformanceSamplesResp ) def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_height().value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return self . _provider . make_request ( body , GetBlockHeightResp ) def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_blocks(5, 10).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return self . _provider . make_request ( body , GetBlocksResp ) def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> solana_client.get_signatures_for_address(pubkey, limit=1).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return self . _provider . make_request ( body , GetSignaturesForAddressResp ) def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> solana_client.get_transaction(sig).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return self . _provider . make_request ( body , GetTransactionResp ) def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_info().value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return self . _provider . make_request ( body , GetEpochInfoResp ) def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_schedule().value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp ) def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_for_message(txn.compile_message()).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return self . _provider . make_request ( body , GetFeeForMessageResp ) def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_first_available_block().value # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp ) def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_genesis_hash().value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp ) def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_identity().value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return self . _provider . make_request ( self . _get_identity , GetIdentityResp ) def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_governor().value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return self . _provider . make_request ( body , GetInflationGovernorResp ) def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_rate().value.epoch # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp ) def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_largest_accounts().value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return self . _provider . make_request ( body , GetLargestAccountsResp ) def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> list(solana_client.get_leader_schedule().value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return self . _provider . make_request ( body , GetLeaderScheduleResp ) def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_balance_for_rent_exemption(50).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp ) def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetMultipleAccountsResp ) def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys, in jsonParsed format if possible. If a parser cannot be found, the RPC server falls back to base64 encoding, Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts_json_parsed(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return self . _provider . make_request ( body , GetMultipleAccountsMaybeJsonParsedResp ) def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either \"base58\" (slow) or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsResp ) def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp ) def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_latest_blockhash().value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return self . _provider . make_request ( body , GetLatestBlockhashResp ) def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> solana_client.get_signature_statuses(sigs).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return self . _provider . make_request ( body , GetSignatureStatusesResp ) def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot().value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return self . _provider . make_request ( body , GetSlotResp ) def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot_leader().value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return self . _provider . make_request ( body , GetSlotLeaderResp ) def get_stake_activation ( self , pubkey : Pubkey , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetStakeActivationResp : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_stake_activation().value.active # doctest: +SKIP 124429280 \"\"\" body = self . _get_stake_activation_body ( pubkey , epoch , commitment ) return self . _provider . make_request ( body , GetStakeActivationResp ) def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_supply().value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return self . _provider . make_request ( body , GetSupplyResp ) def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> solana_client.get_token_account_balance(pubkey).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenAccountBalanceResp ) def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateResp ) def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp ) def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerResp ) def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp ) def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenLargestAccountsResp ) def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenSupplyResp ) def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction_count().value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return self . _provider . make_request ( body , GetTransactionCountResp ) def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_ledger_slot().value # doctest: +SKIP 1234 \"\"\" return self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp ) def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_version().value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return self . _provider . make_request ( self . _get_version , GetVersionResp ) def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_vote_accounts().value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( commitment ) return self . _provider . make_request ( body , GetVoteAccountsResp ) def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amout of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return self . _provider . make_request ( body , RequestAirdropResp ) def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return self . __post_send_with_confirm ( * post_send_args ) def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. signers: Signers to sign the transaction. Only supported for legacy Transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Only supported for legacy Transaction. Example: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solana.rpc.api import Client >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.send_transaction(txn, sender).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" if isinstance ( txn , VersionedTransaction ): if signers : msg = \"*signers args are not used when sending VersionedTransaction.\" raise ValueError ( msg ) if recent_blockhash is not None : msg = \"recent_blockhash arg is not used when sending VersionedTransaction.\" raise ValueError ( msg ) versioned_tx_opts = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts return self . send_raw_transaction ( bytes ( txn ), opts = versioned_tx_opts ) last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp . value . last_valid_block_height else : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp . value . last_valid_block_height txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height , ) if opts is None else opts ) txn_resp = self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = self . get_latest_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A transaction object. The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.deserialize(bytes.fromhex(full_signed_tx_hex)) >>> solana_client.simulate_transaction(tx).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment ) return self . _provider . make_request ( body , SimulateTransactionResp ) def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.validator_exit().value # doctest: +SKIP True \"\"\" return self . _provider . make_request ( self . _validator_exit , ValidatorExitResp ) def __post_send_with_confirm ( self , resp : SendTransactionResp , conf_comm : Commitment , last_valid_block_height : Optional [ int ], ) -> SendTransactionResp : resp = self . _post_send ( resp ) sig = resp . value self . _provider . logger . info ( \"Transaction sent to %s . Signature %s : \" , self . _provider . endpoint_uri , sig ) self . confirm_transaction ( sig , conf_comm , last_valid_block_height = last_valid_block_height ) return resp def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" timeout = time () + 90 commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = self . get_signature_statuses ([ tx_sig ]) if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( self . get_block_height ( commitment )) . value sleep ( sleep_seconds ) else : if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : while time () < timeout : resp = self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp","title":"Client"},{"location":"rpc/api/#solana.rpc.api.Client.__init__","text":"Init API client. Source code in solana/rpc/api.py def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , ): \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = http . HTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers )","title":"__init__()"},{"location":"rpc/api/#solana.rpc.api.Client.confirm_transaction","text":"Confirm the transaction identified by the specified signature. Parameters: Name Type Description Default tx_sig Signature the transaction signature to confirm. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None sleep_seconds float The number of seconds to sleep when polling the signature status. 0.5 last_valid_block_height Optional[int] The block height by which the transaction would become invalid. None Source code in solana/rpc/api.py def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" timeout = time () + 90 commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = self . get_signature_statuses ([ tx_sig ]) if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( self . get_block_height ( commitment )) . value sleep ( sleep_seconds ) else : if isinstance ( resp , RPCError . __args__ ): # type: ignore raise RPCException ( resp ) raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : while time () < timeout : resp = self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp","title":"confirm_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.get_account_info","text":"Returns all the account info for the specified public key, encoded in either base58 or base64. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. 'base64' data_slice Optional[types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_account_info ( Pubkey ([ 0 ] * 31 + [ 1 ])) . value Account ( Account { lamports : 4104230290 , data . len : 0 , owner : 11111111111111111111111111111111 , executable : false , rent_epoch : 371 , }, ) Source code in solana/rpc/api.py def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key, encoded in either base58 or base64. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info(Pubkey([0] * 31 + [1])).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetAccountInfoResp )","title":"get_account_info()"},{"location":"rpc/api/#solana.rpc.api.Client.get_account_info_json_parsed","text":"Returns all the account info for the specified public key in parsed JSON format. If JSON formatting is not available for this account, base64 is returned. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_account_info_json_parsed ( Pubkey ([ 0 ] * 31 + [ 1 ])) . value . owner Pubkey ( 11111111111111111111111111111111 , ) Source code in solana/rpc/api.py def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key in parsed JSON format. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1])).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp )","title":"get_account_info_json_parsed()"},{"location":"rpc/api/#solana.rpc.api.Client.get_balance","text":"Returns the balance of the account of provided Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_balance ( Pubkey ([ 0 ] * 31 + [ 1 ])) . value 4104230290 Source code in solana/rpc/api.py def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_balance(Pubkey([0] * 31 + [1])).value # doctest: +SKIP 4104230290 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetBalanceResp )","title":"get_balance()"},{"location":"rpc/api/#solana.rpc.api.Client.get_block","text":"Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' max_supported_transaction_version int (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block ( 1 ) . value . blockhash Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/api.py def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : int = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block(1).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return self . _provider . make_request ( body , GetBlockResp )","title":"get_block()"},{"location":"rpc/api/#solana.rpc.api.Client.get_block_commitment","text":"Fetch the commitment for particular block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_commitment ( 0 ) . total_stake 497717120 Source code in solana/rpc/api.py def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_commitment(0).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return self . _provider . make_request ( body , GetBlockCommitmentResp )","title":"get_block_commitment()"},{"location":"rpc/api/#solana.rpc.api.Client.get_block_height","text":"Returns the current block height of the node. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_height () . value 1233 Source code in solana/rpc/api.py def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_height().value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return self . _provider . make_request ( body , GetBlockHeightResp )","title":"get_block_height()"},{"location":"rpc/api/#solana.rpc.api.Client.get_block_time","text":"Fetch the estimated production time of a block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_block_time ( 5 ) . value 1598400007 Source code in solana/rpc/api.py def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_block_time(5).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return self . _provider . make_request ( body , GetBlockTimeResp )","title":"get_block_time()"},{"location":"rpc/api/#solana.rpc.api.Client.get_blocks","text":"Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_blocks ( 5 , 10 ) . value [ 5 , 6 , 7 , 8 , 9 , 10 ] Source code in solana/rpc/api.py def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_blocks(5, 10).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return self . _provider . make_request ( body , GetBlocksResp )","title":"get_blocks()"},{"location":"rpc/api/#solana.rpc.api.Client.get_cluster_nodes","text":"Returns information about all the nodes participating in the cluster. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_cluster_nodes () . value [ 0 ] . tpu '139.178.65.155:8004' Source code in solana/rpc/api.py def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_cluster_nodes().value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp )","title":"get_cluster_nodes()"},{"location":"rpc/api/#solana.rpc.api.Client.get_epoch_info","text":"Returns information about the current epoch. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_epoch_info () . value . epoch 0 Source code in solana/rpc/api.py def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_info().value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return self . _provider . make_request ( body , GetEpochInfoResp )","title":"get_epoch_info()"},{"location":"rpc/api/#solana.rpc.api.Client.get_epoch_schedule","text":"Returns epoch schedule information from this cluster's genesis config. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_epoch_schedule () . value . slots_per_epoch 8192 Source code in solana/rpc/api.py def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_epoch_schedule().value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp )","title":"get_epoch_schedule()"},{"location":"rpc/api/#solana.rpc.api.Client.get_fee_for_message","text":"Returns the fee for a message. Parameters: Name Type Description Default message VersionedMessage Message that the fee is requested for. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))) >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_fee_for_message ( txn . compile_message ()) . value 5000 Source code in solana/rpc/api.py def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_fee_for_message(txn.compile_message()).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return self . _provider . make_request ( body , GetFeeForMessageResp )","title":"get_fee_for_message()"},{"location":"rpc/api/#solana.rpc.api.Client.get_first_available_block","text":"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_first_available_block () . value 1 Source code in solana/rpc/api.py def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_first_available_block().value # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp )","title":"get_first_available_block()"},{"location":"rpc/api/#solana.rpc.api.Client.get_genesis_hash","text":"Returns the genesis hash. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_genesis_hash () . value Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/api.py def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_genesis_hash().value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp )","title":"get_genesis_hash()"},{"location":"rpc/api/#solana.rpc.api.Client.get_identity","text":"Returns the identity pubkey for the current node. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_identity () . value . identity Pubkey ( 2 LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv , ) Source code in solana/rpc/api.py def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_identity().value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return self . _provider . make_request ( self . _get_identity , GetIdentityResp )","title":"get_identity()"},{"location":"rpc/api/#solana.rpc.api.Client.get_inflation_governor","text":"Returns the current inflation governor. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_governor () . value . foundation 0.05 Source code in solana/rpc/api.py def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_governor().value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return self . _provider . make_request ( body , GetInflationGovernorResp )","title":"get_inflation_governor()"},{"location":"rpc/api/#solana.rpc.api.Client.get_inflation_rate","text":"Returns the specific inflation values for the current epoch. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_inflation_rate () . value . epoch 1 Source code in solana/rpc/api.py def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_inflation_rate().value.epoch # doctest: +SKIP 1 \"\"\" return self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp )","title":"get_inflation_rate()"},{"location":"rpc/api/#solana.rpc.api.Client.get_largest_accounts","text":"Returns the 20 largest accounts, by lamport balance. Parameters: Name Type Description Default filter_opt Optional[str] Filter results by account type; currently supported: circulating|nonCirculating. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_largest_accounts () . value [ 0 ] . lamports 500000000000000000 Source code in solana/rpc/api.py def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_largest_accounts().value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return self . _provider . make_request ( body , GetLargestAccountsResp )","title":"get_largest_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.get_latest_blockhash","text":"Returns the latest block hash from the ledger. Response also includes the last valid block height. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_latest_blockhash () . value RpcBlockhash { blockhash : Hash ( 4 TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT , ), last_valid_block_height : 158286487 , } Source code in solana/rpc/api.py def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_latest_blockhash().value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return self . _provider . make_request ( body , GetLatestBlockhashResp )","title":"get_latest_blockhash()"},{"location":"rpc/api/#solana.rpc.api.Client.get_leader_schedule","text":"Returns the leader schedule for an epoch. Parameters: Name Type Description Default epoch Optional[int] Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> list ( solana_client . get_leader_schedule () . value . items ())[ 0 ] ( Pubkey ( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr , ), [ 346448 , 346449 , 346450 , 346451 , 369140 , 369141 , 369142 , 369143 , 384204 , 384205 , 384206 , 384207 ]) Source code in solana/rpc/api.py def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> list(solana_client.get_leader_schedule().value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return self . _provider . make_request ( body , GetLeaderScheduleResp )","title":"get_leader_schedule()"},{"location":"rpc/api/#solana.rpc.api.Client.get_minimum_balance_for_rent_exemption","text":"Returns minimum balance required to make account rent exempt. Parameters: Name Type Description Default usize int Account data length. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_minimum_balance_for_rent_exemption ( 50 ) . value 1238880 Source code in solana/rpc/api.py def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_balance_for_rent_exemption(50).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp )","title":"get_minimum_balance_for_rent_exemption()"},{"location":"rpc/api/#solana.rpc.api.Client.get_minimum_ledger_slot","text":"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_minimum_ledger_slot () . value 1234 Source code in solana/rpc/api.py def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_minimum_ledger_slot().value # doctest: +SKIP 1234 \"\"\" return self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp )","title":"get_minimum_ledger_slot()"},{"location":"rpc/api/#solana.rpc.api.Client.get_multiple_accounts","text":"Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. 'base64' data_slice Optional[types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> solana_client . get_multiple_accounts ( pubkeys ) . value [ 0 ] . lamports 1 Source code in solana/rpc/api.py def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return self . _provider . make_request ( body , GetMultipleAccountsResp )","title":"get_multiple_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.get_multiple_accounts_json_parsed","text":"Returns all the account info for a list of public keys, in jsonParsed format if possible. If a parser cannot be found, the RPC server falls back to base64 encoding, Parameters: Name Type Description Default pubkeys List[Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> solana_client . get_multiple_accounts_json_parsed ( pubkeys ) . value [ 0 ] . lamports 1 Source code in solana/rpc/api.py def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys, in jsonParsed format if possible. If a parser cannot be found, the RPC server falls back to base64 encoding, Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> solana_client.get_multiple_accounts_json_parsed(pubkeys).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return self . _provider . make_request ( body , GetMultipleAccountsMaybeJsonParsedResp )","title":"get_multiple_accounts_json_parsed()"},{"location":"rpc/api/#solana.rpc.api.Client.get_program_accounts","text":"Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for the returned Transaction, either \"base58\" (slow) or \"base64\". 'base64' data_slice Optional[types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and None ` length` fields; only available for \"base58\" or \"base64\" encoding. required filters Optional[Sequence[Union[int, types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List , Union >>> solana_client = Client ( \"http://localhost:8899\" ) >>> memcmp_opts = MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> solana_client . get_program_accounts ( pubkey , filters = filters ) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/api.py def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either \"base58\" (slow) or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsResp )","title":"get_program_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.get_program_accounts_json_parsed","text":"Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None filters Optional[Sequence[Union[int, types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List , Union >>> solana_client = Client ( \"http://localhost:8899\" ) >>> memcmp_opts = MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> solana_client . get_program_accounts ( pubkey , filters = filters ) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/api.py def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from solana.rpc.types import MemcmpOpts >>> from typing import List, Union >>> solana_client = Client(\"http://localhost:8899\") >>> memcmp_opts = MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, MemcmpOpts]] = [17, memcmp_opts] >>> solana_client.get_program_accounts(pubkey, filters=filters).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp )","title":"get_program_accounts_json_parsed()"},{"location":"rpc/api/#solana.rpc.api.Client.get_recent_performance_samples","text":"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: Name Type Description Default limit Optional[int] Limit (optional) number of samples to return (maximum 720) None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_recent_performance_samples ( 1 ) . value [ 0 ] RpcPerfSample ( RpcPerfSample { slot : 168036172 , num_transactions : 7159 , num_slots : 158 , sample_period_secs : 60 , }, ) Source code in solana/rpc/api.py def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_recent_performance_samples(1).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return self . _provider . make_request ( body , GetRecentPerformanceSamplesResp )","title":"get_recent_performance_samples()"},{"location":"rpc/api/#solana.rpc.api.Client.get_signature_statuses","text":"Returns the statuses of a list of signatures. Unless the search_transaction_history configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus MAX_RECENT_BLOCKHASHES rooted slots. Parameters: Name Type Description Default signatures List[Signature] An array of transaction signatures to confirm. required search_transaction_history bool If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. False Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\" , ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\" ] >>> sigs = [ Signature . from_string ( sig ) for sig in raw_sigs ] >>> solana_client . get_signature_statuses ( sigs ) . value [ 0 ] . confirmations 10 Source code in solana/rpc/api.py def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> solana_client.get_signature_statuses(sigs).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return self . _provider . make_request ( body , GetSignatureStatusesResp )","title":"get_signature_statuses()"},{"location":"rpc/api/#solana.rpc.api.Client.get_signatures_for_address","text":"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Pubkey Account to be queried. required before Optional[Signature] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[Signature] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey . from_string ( \"Vote111111111111111111111111111111111111111\" ) >>> solana_client . get_signatures_for_address ( pubkey , limit = 1 ) . value [ 0 ] . signature Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> solana_client.get_signatures_for_address(pubkey, limit=1).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return self . _provider . make_request ( body , GetSignaturesForAddressResp )","title":"get_signatures_for_address()"},{"location":"rpc/api/#solana.rpc.api.Client.get_slot","text":"Returns the current slot the node is processing. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_slot () . value 7515 Source code in solana/rpc/api.py def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot().value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return self . _provider . make_request ( body , GetSlotResp )","title":"get_slot()"},{"location":"rpc/api/#solana.rpc.api.Client.get_slot_leader","text":"Returns the current slot leader. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_slot_leader () . value Pubkey ( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV , ) Source code in solana/rpc/api.py def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_slot_leader().value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return self . _provider . make_request ( body , GetSlotLeaderResp )","title":"get_slot_leader()"},{"location":"rpc/api/#solana.rpc.api.Client.get_stake_activation","text":"Returns epoch activation information for a stake account. Parameters: Name Type Description Default pubkey Pubkey Pubkey of stake account to query required epoch Optional[int] (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_stake_activation () . value . active 124429280 Source code in solana/rpc/api.py def get_stake_activation ( self , pubkey : Pubkey , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetStakeActivationResp : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_stake_activation().value.active # doctest: +SKIP 124429280 \"\"\" body = self . _get_stake_activation_body ( pubkey , epoch , commitment ) return self . _provider . make_request ( body , GetStakeActivationResp )","title":"get_stake_activation()"},{"location":"rpc/api/#solana.rpc.api.Client.get_supply","text":"Returns information about the current supply. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_supply () . value . circulating 683635192454157660 Source code in solana/rpc/api.py def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_supply().value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return self . _provider . make_request ( body , GetSupplyResp )","title":"get_supply()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_account_balance","text":"Returns the token balance of an SPL Token account (UNSTABLE). Parameters: Name Type Description Default pubkey Pubkey Pubkey of Token account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> pubkey = Pubkey . from_string ( \"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\" ) >>> solana_client . get_token_account_balance ( pubkey ) . value . amount # noqa: E501 '9864' Source code in solana/rpc/api.py def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> solana_client.get_token_account_balance(pubkey).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenAccountBalanceResp )","title":"get_token_account_balance()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_accounts_by_delegate","text":"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateResp )","title":"get_token_accounts_by_delegate()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_accounts_by_delegate_json_parsed","text":"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp )","title":"get_token_accounts_by_delegate_json_parsed()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_accounts_by_owner","text":"Returns all SPL Token accounts by token owner (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerResp )","title":"get_token_accounts_by_owner()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_accounts_by_owner_json_parsed","text":"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts types.TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/api.py def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp )","title":"get_token_accounts_by_owner_json_parsed()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_largest_accounts","text":"Returns the 20 largest accounts of a particular SPL Token type. Source code in solana/rpc/api.py def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenLargestAccountsResp )","title":"get_token_largest_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.get_token_supply","text":"Returns the total supply of an SPL Token type. Source code in solana/rpc/api.py def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return self . _provider . make_request ( body , GetTokenSupplyResp )","title":"get_token_supply()"},{"location":"rpc/api/#solana.rpc.api.Client.get_transaction","text":"Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig Signature Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None max_supported_transaction_version Optional[int] (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> from solders.signature import Signature >>> sig = Signature . from_string ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" ) >>> solana_client . get_transaction ( sig ) . value . block_time 1234 Source code in solana/rpc/api.py def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = Client(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> solana_client.get_transaction(sig).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return self . _provider . make_request ( body , GetTransactionResp )","title":"get_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.get_transaction_count","text":"Returns the current Transaction count from the ledger. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_transaction_count () . value 4554 Source code in solana/rpc/api.py def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_transaction_count().value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return self . _provider . make_request ( body , GetTransactionCountResp )","title":"get_transaction_count()"},{"location":"rpc/api/#solana.rpc.api.Client.get_version","text":"Returns the current solana versions running on the node. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_version () . value . solana_core '1.13.2' Source code in solana/rpc/api.py def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_version().value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return self . _provider . make_request ( self . _get_version , GetVersionResp )","title":"get_version()"},{"location":"rpc/api/#solana.rpc.api.Client.get_vote_accounts","text":"Returns the account info and associated stake for all the voting accounts in the current bank. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . get_vote_accounts () . value . current [ 0 ] . commission 100 Source code in solana/rpc/api.py def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.get_vote_accounts().value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( commitment ) return self . _provider . make_request ( body , GetVoteAccountsResp )","title":"get_vote_accounts()"},{"location":"rpc/api/#solana.rpc.api.Client.is_connected","text":"Health check. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . is_connected () True Returns: Type Description bool True if the client is connected. Source code in solana/rpc/api.py def is_connected ( self ) -> bool : \"\"\"Health check. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.is_connected() # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return self . _provider . is_connected ()","title":"is_connected()"},{"location":"rpc/api/#solana.rpc.api.Client.request_airdrop","text":"Requests an airdrop of lamports to a Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to receive lamports, as base-58 encoded string or public key object. required lamports int Amout of lamports. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . request_airdrop ( Pubkey ([ 0 ] * 31 + [ 1 ]), 10000 ) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amout of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return self . _provider . make_request ( body , RequestAirdropResp )","title":"request_airdrop()"},{"location":"rpc/api/#solana.rpc.api.Client.send_raw_transaction","text":"Send a transaction that has already been signed and serialized into the wire format. Parameters: Name Type Description Default txn bytes Transaction bytes. required opts Optional[types.TxOpts] (optional) Transaction options. None Before submitting, the following preflight checks are performed (unless disabled with the skip_preflight option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> solana_client . send_raw_transaction ( bytes . fromhex ( full_signed_tx_hex )) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return self . __post_send_with_confirm ( * post_send_args )","title":"send_raw_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.send_transaction","text":"Send a transaction. Parameters: Name Type Description Default txn Union[VersionedTransaction, Transaction] transaction object. required signers Keypair Signers to sign the transaction. Only supported for legacy Transaction. () opts Optional[types.TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Only supported for legacy Transaction. None Examples: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solana.rpc.api import Client >>> from solders.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))) >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . send_transaction ( txn , sender ) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/api.py def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. signers: Signers to sign the transaction. Only supported for legacy Transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Only supported for legacy Transaction. Example: >>> from solders.keypair import Keypair >>> from solders.pubkey import Pubkey >>> from solana.rpc.api import Client >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.send_transaction(txn, sender).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" if isinstance ( txn , VersionedTransaction ): if signers : msg = \"*signers args are not used when sending VersionedTransaction.\" raise ValueError ( msg ) if recent_blockhash is not None : msg = \"recent_blockhash arg is not used when sending VersionedTransaction.\" raise ValueError ( msg ) versioned_tx_opts = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts return self . send_raw_transaction ( bytes ( txn ), opts = versioned_tx_opts ) last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp . value . last_valid_block_height else : blockhash_resp = self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp . value . last_valid_block_height txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height , ) if opts is None else opts ) txn_resp = self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = self . get_latest_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp","title":"send_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.simulate_transaction","text":"Simulate sending a transaction. Parameters: Name Type Description Default txn Union[Transaction, VersionedTransaction] A transaction object. The transaction must have a valid blockhash, but is not required to be signed. required sig_verify bool If true the transaction signatures will be verified (default: false). False commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction . deserialize ( bytes . fromhex ( full_signed_tx_hex )) >>> solana_client . simulate_transaction ( tx ) . value . logs [ 'BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success' ] Source code in solana/rpc/api.py def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A transaction object. The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = Client(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.deserialize(bytes.fromhex(full_signed_tx_hex)) >>> solana_client.simulate_transaction(tx).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment ) return self . _provider . make_request ( body , SimulateTransactionResp )","title":"simulate_transaction()"},{"location":"rpc/api/#solana.rpc.api.Client.validator_exit","text":"Request to have the validator exit. Validator must have booted with RPC exit enabled ( --enable-rpc-exit parameter). Examples: >>> solana_client = Client ( \"http://localhost:8899\" ) >>> solana_client . validator_exit () . value True Source code in solana/rpc/api.py def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = Client(\"http://localhost:8899\") >>> solana_client.validator_exit().value # doctest: +SKIP True \"\"\" return self . _provider . make_request ( self . _validator_exit , ValidatorExitResp )","title":"validator_exit()"},{"location":"rpc/async_api/","text":"Async API Client solana.rpc.async_api Async API client to interact with the Solana JSON RPC Endpoint. AsyncClient Async client class. Parameters: Name Type Description Default endpoint Optional[str] URL of the RPC endpoint. None commitment Optional[Commitment] Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None blockhash_cache Union[solana.blockhash.BlockhashCache, bool] (Experimental) If True, keep a cache of recent blockhashes to make send_transaction calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: Retrieve the oldest unused cached blockhash that is younger than ttl seconds, where ttl is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than ttl seconds. Fetch a new recent blockhash after sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your .send_transaction calls. False timeout float HTTP request timeout in seconds. 10 extra_headers Optional[Dict[str, str]] Extra headers to pass for HTTP request. None Source code in solana/rpc/async_api.py class AsyncClient ( _ClientCore ): # pylint: disable=too-many-public-methods \"\"\"Async client class. Args: endpoint: URL of the RPC endpoint. commitment: Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". blockhash_cache: (Experimental) If True, keep a cache of recent blockhashes to make `send_transaction` calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: 1. Retrieve the oldest unused cached blockhash that is younger than `ttl` seconds, where `ttl` is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). 2. If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than `ttl` seconds. 3. Fetch a new recent blockhash *after* sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your `.send_transaction` calls. timeout: HTTP request timeout in seconds. extra_headers: Extra headers to pass for HTTP request. \"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , ) -> None : \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = async_http . AsyncHTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers ) async def __aenter__ ( self ) -> \"AsyncClient\" : \"\"\"Use as a context manager.\"\"\" await self . _provider . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . _provider . close () async def is_connected ( self ) -> bool : \"\"\"Health check. >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return await self . _provider . is_connected () async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_balance(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP 0 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetBalanceResp ) async def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetAccountInfoResp ) async def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1]))).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return await self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp ) async def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_commitment(0)).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return await self . _provider . make_request ( body , GetBlockCommitmentResp ) async def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_time(5)).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return await self . _provider . make_request ( body , GetBlockTimeResp ) async def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_cluster_nodes()).value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return await self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp ) async def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : int = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block(1)).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetBlockResp ) async def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_recent_performance_samples(1)).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return await self . _provider . make_request ( body , GetRecentPerformanceSamplesResp ) async def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_height()).value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return await self . _provider . make_request ( body , GetBlockHeightResp ) async def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_blocks(5, 10)).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return await self . _provider . make_request ( body , GetBlocksResp ) async def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> (await solana_client.get_signatures_for_address(pubkey, limit=1)).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return await self . _provider . make_request ( body , GetSignaturesForAddressResp ) async def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> (await solana_client.get_transaction(sig)).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetTransactionResp ) async def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_info()).value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return await self . _provider . make_request ( body , GetEpochInfoResp ) async def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_schedule()).value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return await self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp ) async def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_fee_for_message(txn.compile_message())).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return await self . _provider . make_request ( body , GetFeeForMessageResp ) async def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_first_available_block()).value # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp ) async def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_genesis_hash()).value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return await self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp ) async def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_identity()).value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return await self . _provider . make_request ( self . _get_identity , GetIdentityResp ) async def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> await (solana_client.get_inflation_governor()).value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return await self . _provider . make_request ( body , GetInflationGovernorResp ) async def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_inflation_rate()).value.epoch # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp ) async def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_largest_accounts()).value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return await self . _provider . make_request ( body , GetLargestAccountsResp ) async def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> resp = await solana_client.get_leader_schedule() # doctest: +SKIP >>> list(resp.value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return await self . _provider . make_request ( body , GetLeaderScheduleResp ) async def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_balance_for_rent_exemption(50)).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return await self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp ) async def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> (await solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetMultipleAccountsResp ) async def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> asyncio.run(solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return await self . _provider . make_request ( body , GetMultipleAccountsResp ) async def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsResp ) async def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp ) async def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_latest_blockhash()).value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return await self . _provider . make_request ( body , GetLatestBlockhashResp ) async def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> (await solana_client.get_signature_statuses(sigs)).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return await self . _provider . make_request ( body , GetSignatureStatusesResp ) async def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot()).value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return await self . _provider . make_request ( body , GetSlotResp ) async def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot_leader()).value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return await self . _provider . make_request ( body , GetSlotLeaderResp ) async def get_stake_activation ( self , pubkey : Pubkey , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetStakeActivationResp : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_stake_activation()).value.active # doctest: +SKIP 124429280 \"\"\" body = self . _get_stake_activation_body ( pubkey , epoch , commitment ) return await self . _provider . make_request ( body , GetStakeActivationResp ) async def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_supply()).value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return await self . _provider . make_request ( body , GetSupplyResp ) async def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> (await solana_client.get_token_account_balance(pubkey)).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenAccountBalanceResp ) async def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateResp ) async def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp ) async def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp ) async def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerResp ) async def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenLargestAccountsResp ) async def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenSupplyResp ) async def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_transaction_count()).value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return await self . _provider . make_request ( body , GetTransactionCountResp ) async def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_ledger_slot()).value # doctest: +SKIP 1234 \"\"\" return await self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp ) async def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_version()).value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return await self . _provider . make_request ( self . _get_version , GetVersionResp ) async def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_vote_accounts()).value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( commitment ) return await self . _provider . make_request ( body , GetVoteAccountsResp ) async def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amount of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return await self . _provider . make_request ( body , RequestAirdropResp ) async def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> (await solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex))).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = await self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return await self . __post_send_with_confirm ( * post_send_args ) async def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. signers: Signers to sign the transaction. Only supported for legacy Transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Only supported for legacy Transaction. Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.send_transaction(txn, sender)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" if isinstance ( txn , VersionedTransaction ): if signers : msg = \"*signers args are not used when sending VersionedTransaction.\" raise ValueError ( msg ) if recent_blockhash is not None : msg = \"recent_blockhash arg is not used when sending VersionedTransaction.\" raise ValueError ( msg ) versioned_tx_opts = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts return await self . send_raw_transaction ( bytes ( txn ), opts = versioned_tx_opts ) last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp . value . last_valid_block_height else : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp . value . last_valid_block_height txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height , ) if opts is None else opts ) txn_resp = await self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = await self . get_latest_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp async def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.deserialize(bytes.fromhex(full_signed_tx_hex)) >>> (await solana_client.simulate_transaction(tx)).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment ) return await self . _provider . make_request ( body , SimulateTransactionResp ) async def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.validator_exit()).value # doctest: +SKIP True \"\"\" return await self . _provider . make_request ( self . _validator_exit , ValidatorExitResp ) async def __post_send_with_confirm ( self , resp : SendTransactionResp , conf_comm : Commitment , last_valid_block_height : Optional [ int ], ) -> SendTransactionResp : resp = self . _post_send ( resp ) sig = resp . value self . _provider . logger . info ( \"Transaction sent to %s . Signature %s : \" , self . _provider . endpoint_uri , sig ) await self . confirm_transaction ( sig , conf_comm , last_valid_block_height = last_valid_block_height ) return resp async def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( await self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( await self . get_block_height ( commitment )) . value await asyncio . sleep ( sleep_seconds ) else : raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : timeout = time () + 90 while time () < timeout : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break await asyncio . sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp __init__ ( self , endpoint = None , commitment = None , blockhash_cache = False , timeout = 10 , extra_headers = None ) special Init API client. Source code in solana/rpc/async_api.py def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , ) -> None : \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = async_http . AsyncHTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers ) close ( self ) async Use this when you are done with the client. Source code in solana/rpc/async_api.py async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . _provider . close () confirm_transaction ( self , tx_sig , commitment = None , sleep_seconds = 0.5 , last_valid_block_height = None ) async Confirm the transaction identified by the specified signature. Parameters: Name Type Description Default tx_sig Signature the transaction signature to confirm. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None sleep_seconds float The number of seconds to sleep when polling the signature status. 0.5 last_valid_block_height Optional[int] The block height by which the transaction would become invalid. None Source code in solana/rpc/async_api.py async def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( await self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( await self . get_block_height ( commitment )) . value await asyncio . sleep ( sleep_seconds ) else : raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : timeout = time () + 90 while time () < timeout : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break await asyncio . sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp get_account_info ( self , pubkey , commitment = None , encoding = 'base64' , data_slice = None ) async Returns all the account info for the specified public key. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). 'base64' data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_account_info ( Pubkey ([ 0 ] * 31 + [ 1 ]))) . value Account ( Account { lamports : 4104230290 , data . len : 0 , owner : 11111111111111111111111111111111 , executable : false , rent_epoch : 371 , }, ) Source code in solana/rpc/async_api.py async def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetAccountInfoResp ) get_account_info_json_parsed ( self , pubkey , commitment = None ) async Returns all the account info for the specified public key. If JSON formatting is not available for this account, base64 is returned. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_account_info_json_parsed ( Pubkey ([ 0 ] * 31 + [ 1 ]))) . value . owner Pubkey ( 11111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1]))).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return await self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp ) get_balance ( self , pubkey , commitment = None ) async Returns the balance of the account of provided Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_balance ( Pubkey ([ 0 ] * 31 + [ 1 ]))) . value 0 Source code in solana/rpc/async_api.py async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_balance(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP 0 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetBalanceResp ) get_block ( self , slot , encoding = 'json' , max_supported_transaction_version = None ) async Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' max_supported_transaction_version int (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block ( 1 )) . value . blockhash Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/async_api.py async def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : int = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block(1)).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetBlockResp ) get_block_commitment ( self , slot ) async Fetch the commitment for particular block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block_commitment ( 0 )) . total_stake 497717120 Source code in solana/rpc/async_api.py async def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_commitment(0)).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return await self . _provider . make_request ( body , GetBlockCommitmentResp ) get_block_height ( self , commitment = None ) async Returns the current block height of the node. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block_height ()) . value 1233 Source code in solana/rpc/async_api.py async def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_height()).value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return await self . _provider . make_request ( body , GetBlockHeightResp ) get_block_time ( self , slot ) async Fetch the estimated production time of a block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block_time ( 5 )) . value 1598400007 Source code in solana/rpc/async_api.py async def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_time(5)).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return await self . _provider . make_request ( body , GetBlockTimeResp ) get_blocks ( self , start_slot , end_slot = None ) async Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_blocks ( 5 , 10 )) . value [ 5 , 6 , 7 , 8 , 9 , 10 ] Source code in solana/rpc/async_api.py async def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_blocks(5, 10)).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return await self . _provider . make_request ( body , GetBlocksResp ) get_cluster_nodes ( self ) async Returns information about all the nodes participating in the cluster. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_cluster_nodes ()) . value [ 0 ] . tpu '139.178.65.155:8004' Source code in solana/rpc/async_api.py async def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_cluster_nodes()).value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return await self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp ) get_epoch_info ( self , commitment = None ) async Returns information about the current epoch. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_epoch_info ()) . value . epoch 0 Source code in solana/rpc/async_api.py async def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_info()).value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return await self . _provider . make_request ( body , GetEpochInfoResp ) get_epoch_schedule ( self ) async Returns epoch schedule information from this cluster's genesis config. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_epoch_schedule ()) . value . slots_per_epoch 8192 Source code in solana/rpc/async_api.py async def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_schedule()).value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return await self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp ) get_fee_for_message ( self , message , commitment = None ) async Returns the fee for a message. Parameters: Name Type Description Default message Union[solders.message.MessageV0, solders.message.Message] Message that the fee is requested for. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))) >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_fee_for_message ( txn . compile_message ())) . value 5000 Source code in solana/rpc/async_api.py async def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_fee_for_message(txn.compile_message())).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return await self . _provider . make_request ( body , GetFeeForMessageResp ) get_first_available_block ( self ) async Returns the slot of the lowest confirmed block that has not been purged from the ledger. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_first_available_block ()) . value 1 Source code in solana/rpc/async_api.py async def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_first_available_block()).value # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp ) get_genesis_hash ( self ) async Returns the genesis hash. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_genesis_hash ()) . value Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/async_api.py async def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_genesis_hash()).value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return await self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp ) get_identity ( self ) async Returns the identity pubkey for the current node. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_identity ()) . value . identity Pubkey ( 2 LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv , ) Source code in solana/rpc/async_api.py async def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_identity()).value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return await self . _provider . make_request ( self . _get_identity , GetIdentityResp ) get_inflation_governor ( self , commitment = None ) async Returns the current inflation governor. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> await ( solana_client . get_inflation_governor ()) . value . foundation 0.05 Source code in solana/rpc/async_api.py async def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> await (solana_client.get_inflation_governor()).value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return await self . _provider . make_request ( body , GetInflationGovernorResp ) get_inflation_rate ( self ) async Returns the specific inflation values for the current epoch. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_inflation_rate ()) . value . epoch 1 Source code in solana/rpc/async_api.py async def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_inflation_rate()).value.epoch # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp ) get_largest_accounts ( self , filter_opt = None , commitment = None ) async Returns the 20 largest accounts, by lamport balance. Parameters: Name Type Description Default filter_opt Optional[str] Filter results by account type; currently supported: circulating|nonCirculating. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_largest_accounts ()) . value [ 0 ] . lamports 500000000000000000 Source code in solana/rpc/async_api.py async def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_largest_accounts()).value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return await self . _provider . make_request ( body , GetLargestAccountsResp ) get_latest_blockhash ( self , commitment = None ) async Returns the latest block hash from the ledger. Response also includes the last valid block height. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_latest_blockhash ()) . value RpcBlockhash { blockhash : Hash ( 4 TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT , ), last_valid_block_height : 158286487 , } Source code in solana/rpc/async_api.py async def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_latest_blockhash()).value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return await self . _provider . make_request ( body , GetLatestBlockhashResp ) get_leader_schedule ( self , epoch = None , commitment = None ) async Returns the leader schedule for an epoch. Parameters: Name Type Description Default epoch Optional[int] Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> resp = await solana_client . get_leader_schedule () >>> list ( resp . value . items ())[ 0 ] ( Pubkey ( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr , ), [ 346448 , 346449 , 346450 , 346451 , 369140 , 369141 , 369142 , 369143 , 384204 , 384205 , 384206 , 384207 ]) Source code in solana/rpc/async_api.py async def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> resp = await solana_client.get_leader_schedule() # doctest: +SKIP >>> list(resp.value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return await self . _provider . make_request ( body , GetLeaderScheduleResp ) get_minimum_balance_for_rent_exemption ( self , usize , commitment = None ) async Returns minimum balance required to make account rent exempt. Parameters: Name Type Description Default usize int Account data length. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_minimum_balance_for_rent_exemption ( 50 )) . value 1238880 Source code in solana/rpc/async_api.py async def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_balance_for_rent_exemption(50)).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return await self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp ) get_minimum_ledger_slot ( self ) async Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_minimum_ledger_slot ()) . value 1234 Source code in solana/rpc/async_api.py async def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_ledger_slot()).value # doctest: +SKIP 1234 \"\"\" return await self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp ) get_multiple_accounts ( self , pubkeys , commitment = None , encoding = 'base64' , data_slice = None ) async Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[solders.pubkey.Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. 'base64' data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> ( await solana_client . get_multiple_accounts ( pubkeys )) . value [ 0 ] . lamports 1 Source code in solana/rpc/async_api.py async def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> (await solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetMultipleAccountsResp ) get_multiple_accounts_json_parsed ( self , pubkeys , commitment = None ) async Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[solders.pubkey.Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> asyncio . run ( solana_client . get_multiple_accounts ( pubkeys )) . value [ 0 ] . lamports 1 Source code in solana/rpc/async_api.py async def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> asyncio.run(solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return await self . _provider . make_request ( body , GetMultipleAccountsResp ) get_program_accounts ( self , pubkey , commitment = None , encoding = None , data_slice = None , filters = None ) async Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding Optional[str] (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". None data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None filters Optional[Sequence[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from typing import List , Union >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> memcmp_opts = types . MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , types . MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> ( await solana_client . get_program_accounts ( pubkey , filters = filters )) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/async_api.py async def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsResp ) get_program_accounts_json_parsed ( self , pubkey , commitment = None , filters = None ) async Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None filters Optional[Sequence[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from typing import List , Union >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> memcmp_opts = types . MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , types . MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> ( await solana_client . get_program_accounts ( pubkey , filters = filters )) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/async_api.py async def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp ) get_recent_performance_samples ( self , limit = None ) async Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: Name Type Description Default limit Optional[int] Limit (optional) number of samples to return (maximum 720) None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_recent_performance_samples ( 1 )) . value [ 0 ] RpcPerfSample ( RpcPerfSample { slot : 168036172 , num_transactions : 7159 , num_slots : 158 , sample_period_secs : 60 , }, ) Source code in solana/rpc/async_api.py async def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_recent_performance_samples(1)).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return await self . _provider . make_request ( body , GetRecentPerformanceSamplesResp ) get_signature_statuses ( self , signatures , search_transaction_history = False ) async Returns the statuses of a list of signatures. Unless the search_transaction_history configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus MAX_RECENT_BLOCKHASHES rooted slots. Parameters: Name Type Description Default signatures List[solders.signature.Signature] An array of transaction signatures to confirm. required search_transaction_history bool If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. False Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\" , ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\" ] >>> sigs = [ Signature . from_string ( sig ) for sig in raw_sigs ] >>> ( await solana_client . get_signature_statuses ( sigs )) . value [ 0 ] . confirmations 10 Source code in solana/rpc/async_api.py async def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> (await solana_client.get_signature_statuses(sigs)).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return await self . _provider . make_request ( body , GetSignatureStatusesResp ) get_signatures_for_address ( self , account , before = None , until = None , limit = None , commitment = None ) async Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Pubkey Account to be queried. required before Optional[solders.signature.Signature] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[solders.signature.Signature] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey . from_string ( \"Vote111111111111111111111111111111111111111\" ) >>> ( await solana_client . get_signatures_for_address ( pubkey , limit = 1 )) . value [ 0 ] . signature Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> (await solana_client.get_signatures_for_address(pubkey, limit=1)).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return await self . _provider . make_request ( body , GetSignaturesForAddressResp ) get_slot ( self , commitment = None ) async Returns the current slot the node is processing. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_slot ()) . value 7515 Source code in solana/rpc/async_api.py async def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot()).value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return await self . _provider . make_request ( body , GetSlotResp ) get_slot_leader ( self , commitment = None ) async Returns the current slot leader. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_slot_leader ()) . value Pubkey ( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV , ) Source code in solana/rpc/async_api.py async def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot_leader()).value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return await self . _provider . make_request ( body , GetSlotLeaderResp ) get_stake_activation ( self , pubkey , epoch = None , commitment = None ) async Returns epoch activation information for a stake account. Parameters: Name Type Description Default pubkey Pubkey Pubkey of stake account to query required epoch Optional[int] (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_stake_activation ()) . value . active 124429280 Source code in solana/rpc/async_api.py async def get_stake_activation ( self , pubkey : Pubkey , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetStakeActivationResp : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_stake_activation()).value.active # doctest: +SKIP 124429280 \"\"\" body = self . _get_stake_activation_body ( pubkey , epoch , commitment ) return await self . _provider . make_request ( body , GetStakeActivationResp ) get_supply ( self , commitment = None ) async Returns information about the current supply. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_supply ()) . value . circulating 683635192454157660 Source code in solana/rpc/async_api.py async def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_supply()).value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return await self . _provider . make_request ( body , GetSupplyResp ) get_token_account_balance ( self , pubkey , commitment = None ) async Returns the token balance of an SPL Token account (UNSTABLE). Parameters: Name Type Description Default pubkey Pubkey Pubkey of Token account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkey = Pubkey . from_string ( \"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\" ) >>> ( await solana_client . get_token_account_balance ( pubkey )) . value . amount # noqa: E501 '9864' Source code in solana/rpc/async_api.py async def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> (await solana_client.get_token_account_balance(pubkey)).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenAccountBalanceResp ) get_token_accounts_by_delegate ( self , delegate , opts , commitment = None ) async Returns all SPL Token accounts by approved Delegate (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateResp ) get_token_accounts_by_delegate_json_parsed ( self , delegate , opts , commitment = None ) async Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp ) get_token_accounts_by_owner ( self , owner , opts , commitment = None ) async Returns all SPL Token accounts by token owner (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerResp ) get_token_accounts_by_owner_json_parsed ( self , owner , opts , commitment = None ) async Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp ) get_token_largest_accounts ( self , pubkey , commitment = None ) async Returns the 20 largest accounts of a particular SPL Token type. Source code in solana/rpc/async_api.py async def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenLargestAccountsResp ) get_token_supply ( self , pubkey , commitment = None ) async Returns the total supply of an SPL Token type. Source code in solana/rpc/async_api.py async def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenSupplyResp ) get_transaction ( self , tx_sig , encoding = 'json' , commitment = None , max_supported_transaction_version = None ) async Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig Signature Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None max_supported_transaction_version Optional[int] (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> from solders.signature import Signature >>> sig = Signature . from_string ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" ) >>> ( await solana_client . get_transaction ( sig )) . value . block_time 1234 Source code in solana/rpc/async_api.py async def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> (await solana_client.get_transaction(sig)).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetTransactionResp ) get_transaction_count ( self , commitment = None ) async Returns the current Transaction count from the ledger. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_transaction_count ()) . value 4554 Source code in solana/rpc/async_api.py async def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_transaction_count()).value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return await self . _provider . make_request ( body , GetTransactionCountResp ) get_version ( self ) async Returns the current solana versions running on the node. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_version ()) . value . solana_core '1.13.2' Source code in solana/rpc/async_api.py async def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_version()).value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return await self . _provider . make_request ( self . _get_version , GetVersionResp ) get_vote_accounts ( self , commitment = None ) async Returns the account info and associated stake for all the voting accounts in the current bank. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_vote_accounts ()) . value . current [ 0 ] . commission 100 Source code in solana/rpc/async_api.py async def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_vote_accounts()).value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( commitment ) return await self . _provider . make_request ( body , GetVoteAccountsResp ) is_connected ( self ) async Health check. solana_client = AsyncClient(\"http://localhost:8899\") asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: Type Description bool True if the client is connected. Source code in solana/rpc/async_api.py async def is_connected ( self ) -> bool : \"\"\"Health check. >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return await self . _provider . is_connected () request_airdrop ( self , pubkey , lamports , commitment = None ) async Requests an airdrop of lamports to a Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to receive lamports, as base-58 encoded string or public key object. required lamports int Amount of lamports. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . request_airdrop ( Pubkey ([ 0 ] * 31 + [ 1 ]), 10000 )) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amount of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return await self . _provider . make_request ( body , RequestAirdropResp ) send_raw_transaction ( self , txn , opts = None ) async Send a transaction that has already been signed and serialized into the wire format. Parameters: Name Type Description Default txn bytes Transaction bytes. required opts Optional[solana.rpc.types.TxOpts] (optional) Transaction options. None Before submitting, the following preflight checks are performed (unless disabled with the skip_preflight option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> ( await solana_client . send_raw_transaction ( bytes . fromhex ( full_signed_tx_hex ))) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> (await solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex))).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = await self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return await self . __post_send_with_confirm ( * post_send_args ) send_transaction ( self , txn , * signers , * , opts = None , recent_blockhash = None ) async Send a transaction. Parameters: Name Type Description Default txn Union[solders.transaction.VersionedTransaction, solana.transaction.Transaction] transaction object. required signers Keypair Signers to sign the transaction. Only supported for legacy Transaction. () opts Optional[solana.rpc.types.TxOpts] (optional) Transaction options. None recent_blockhash Optional[solders.hash.Hash] (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Only supported for legacy Transaction. None Examples: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))) >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . send_transaction ( txn , sender )) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. signers: Signers to sign the transaction. Only supported for legacy Transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Only supported for legacy Transaction. Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.send_transaction(txn, sender)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" if isinstance ( txn , VersionedTransaction ): if signers : msg = \"*signers args are not used when sending VersionedTransaction.\" raise ValueError ( msg ) if recent_blockhash is not None : msg = \"recent_blockhash arg is not used when sending VersionedTransaction.\" raise ValueError ( msg ) versioned_tx_opts = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts return await self . send_raw_transaction ( bytes ( txn ), opts = versioned_tx_opts ) last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp . value . last_valid_block_height else : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp . value . last_valid_block_height txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height , ) if opts is None else opts ) txn_resp = await self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = await self . get_latest_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp simulate_transaction ( self , txn , sig_verify = False , commitment = None ) async Simulate sending a transaction. Parameters: Name Type Description Default txn Union[solana.transaction.Transaction, solders.transaction.VersionedTransaction] A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. required sig_verify bool If true the transaction signatures will be verified (default: false). False commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction . deserialize ( bytes . fromhex ( full_signed_tx_hex )) >>> ( await solana_client . simulate_transaction ( tx )) . value . logs [ 'BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success' ] Source code in solana/rpc/async_api.py async def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.deserialize(bytes.fromhex(full_signed_tx_hex)) >>> (await solana_client.simulate_transaction(tx)).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment ) return await self . _provider . make_request ( body , SimulateTransactionResp ) validator_exit ( self ) async Request to have the validator exit. Validator must have booted with RPC exit enabled ( --enable-rpc-exit parameter). Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . validator_exit ()) . value True Source code in solana/rpc/async_api.py async def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.validator_exit()).value # doctest: +SKIP True \"\"\" return await self . _provider . make_request ( self . _validator_exit , ValidatorExitResp )","title":"Async API Client"},{"location":"rpc/async_api/#async-api-client","text":"","title":"Async API Client"},{"location":"rpc/async_api/#solana.rpc.async_api","text":"Async API client to interact with the Solana JSON RPC Endpoint.","title":"async_api"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient","text":"Async client class. Parameters: Name Type Description Default endpoint Optional[str] URL of the RPC endpoint. None commitment Optional[Commitment] Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None blockhash_cache Union[solana.blockhash.BlockhashCache, bool] (Experimental) If True, keep a cache of recent blockhashes to make send_transaction calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: Retrieve the oldest unused cached blockhash that is younger than ttl seconds, where ttl is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than ttl seconds. Fetch a new recent blockhash after sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your .send_transaction calls. False timeout float HTTP request timeout in seconds. 10 extra_headers Optional[Dict[str, str]] Extra headers to pass for HTTP request. None Source code in solana/rpc/async_api.py class AsyncClient ( _ClientCore ): # pylint: disable=too-many-public-methods \"\"\"Async client class. Args: endpoint: URL of the RPC endpoint. commitment: Default bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". blockhash_cache: (Experimental) If True, keep a cache of recent blockhashes to make `send_transaction` calls faster. You can also pass your own BlockhashCache object to customize its parameters. The cache works as follows: 1. Retrieve the oldest unused cached blockhash that is younger than `ttl` seconds, where `ttl` is defined in the BlockhashCache (we prefer unused blockhashes because reusing blockhashes can cause errors in some edge cases, and we prefer slightly older blockhashes because they're more likely to be accepted by every validator). 2. If there are no unused blockhashes in the cache, take the oldest used blockhash that is younger than `ttl` seconds. 3. Fetch a new recent blockhash *after* sending the transaction. This is to keep the cache up-to-date. If you want something tailored to your use case, run your own loop that fetches the recent blockhash, and pass that value in your `.send_transaction` calls. timeout: HTTP request timeout in seconds. extra_headers: Extra headers to pass for HTTP request. \"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , ) -> None : \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = async_http . AsyncHTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers ) async def __aenter__ ( self ) -> \"AsyncClient\" : \"\"\"Use as a context manager.\"\"\" await self . _provider . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . _provider . close () async def is_connected ( self ) -> bool : \"\"\"Health check. >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return await self . _provider . is_connected () async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_balance(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP 0 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetBalanceResp ) async def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetAccountInfoResp ) async def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1]))).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return await self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp ) async def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_commitment(0)).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return await self . _provider . make_request ( body , GetBlockCommitmentResp ) async def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_time(5)).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return await self . _provider . make_request ( body , GetBlockTimeResp ) async def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_cluster_nodes()).value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return await self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp ) async def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : int = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block(1)).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetBlockResp ) async def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_recent_performance_samples(1)).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return await self . _provider . make_request ( body , GetRecentPerformanceSamplesResp ) async def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_height()).value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return await self . _provider . make_request ( body , GetBlockHeightResp ) async def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_blocks(5, 10)).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return await self . _provider . make_request ( body , GetBlocksResp ) async def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> (await solana_client.get_signatures_for_address(pubkey, limit=1)).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return await self . _provider . make_request ( body , GetSignaturesForAddressResp ) async def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> (await solana_client.get_transaction(sig)).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetTransactionResp ) async def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_info()).value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return await self . _provider . make_request ( body , GetEpochInfoResp ) async def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_schedule()).value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return await self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp ) async def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_fee_for_message(txn.compile_message())).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return await self . _provider . make_request ( body , GetFeeForMessageResp ) async def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_first_available_block()).value # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp ) async def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_genesis_hash()).value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return await self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp ) async def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_identity()).value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return await self . _provider . make_request ( self . _get_identity , GetIdentityResp ) async def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> await (solana_client.get_inflation_governor()).value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return await self . _provider . make_request ( body , GetInflationGovernorResp ) async def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_inflation_rate()).value.epoch # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp ) async def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_largest_accounts()).value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return await self . _provider . make_request ( body , GetLargestAccountsResp ) async def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> resp = await solana_client.get_leader_schedule() # doctest: +SKIP >>> list(resp.value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return await self . _provider . make_request ( body , GetLeaderScheduleResp ) async def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_balance_for_rent_exemption(50)).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return await self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp ) async def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> (await solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetMultipleAccountsResp ) async def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> asyncio.run(solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return await self . _provider . make_request ( body , GetMultipleAccountsResp ) async def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsResp ) async def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp ) async def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_latest_blockhash()).value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return await self . _provider . make_request ( body , GetLatestBlockhashResp ) async def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> (await solana_client.get_signature_statuses(sigs)).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return await self . _provider . make_request ( body , GetSignatureStatusesResp ) async def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot()).value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return await self . _provider . make_request ( body , GetSlotResp ) async def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot_leader()).value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return await self . _provider . make_request ( body , GetSlotLeaderResp ) async def get_stake_activation ( self , pubkey : Pubkey , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetStakeActivationResp : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_stake_activation()).value.active # doctest: +SKIP 124429280 \"\"\" body = self . _get_stake_activation_body ( pubkey , epoch , commitment ) return await self . _provider . make_request ( body , GetStakeActivationResp ) async def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_supply()).value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return await self . _provider . make_request ( body , GetSupplyResp ) async def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> (await solana_client.get_token_account_balance(pubkey)).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenAccountBalanceResp ) async def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateResp ) async def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp ) async def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp ) async def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerResp ) async def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenLargestAccountsResp ) async def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenSupplyResp ) async def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_transaction_count()).value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return await self . _provider . make_request ( body , GetTransactionCountResp ) async def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_ledger_slot()).value # doctest: +SKIP 1234 \"\"\" return await self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp ) async def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_version()).value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return await self . _provider . make_request ( self . _get_version , GetVersionResp ) async def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_vote_accounts()).value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( commitment ) return await self . _provider . make_request ( body , GetVoteAccountsResp ) async def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amount of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return await self . _provider . make_request ( body , RequestAirdropResp ) async def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> (await solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex))).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = await self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return await self . __post_send_with_confirm ( * post_send_args ) async def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. signers: Signers to sign the transaction. Only supported for legacy Transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Only supported for legacy Transaction. Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.send_transaction(txn, sender)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" if isinstance ( txn , VersionedTransaction ): if signers : msg = \"*signers args are not used when sending VersionedTransaction.\" raise ValueError ( msg ) if recent_blockhash is not None : msg = \"recent_blockhash arg is not used when sending VersionedTransaction.\" raise ValueError ( msg ) versioned_tx_opts = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts return await self . send_raw_transaction ( bytes ( txn ), opts = versioned_tx_opts ) last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp . value . last_valid_block_height else : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp . value . last_valid_block_height txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height , ) if opts is None else opts ) txn_resp = await self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = await self . get_latest_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp async def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.deserialize(bytes.fromhex(full_signed_tx_hex)) >>> (await solana_client.simulate_transaction(tx)).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment ) return await self . _provider . make_request ( body , SimulateTransactionResp ) async def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.validator_exit()).value # doctest: +SKIP True \"\"\" return await self . _provider . make_request ( self . _validator_exit , ValidatorExitResp ) async def __post_send_with_confirm ( self , resp : SendTransactionResp , conf_comm : Commitment , last_valid_block_height : Optional [ int ], ) -> SendTransactionResp : resp = self . _post_send ( resp ) sig = resp . value self . _provider . logger . info ( \"Transaction sent to %s . Signature %s : \" , self . _provider . endpoint_uri , sig ) await self . confirm_transaction ( sig , conf_comm , last_valid_block_height = last_valid_block_height ) return resp async def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( await self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( await self . get_block_height ( commitment )) . value await asyncio . sleep ( sleep_seconds ) else : raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : timeout = time () + 90 while time () < timeout : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break await asyncio . sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp","title":"AsyncClient"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.__init__","text":"Init API client. Source code in solana/rpc/async_api.py def __init__ ( self , endpoint : Optional [ str ] = None , commitment : Optional [ Commitment ] = None , blockhash_cache : Union [ BlockhashCache , bool ] = False , timeout : float = 10 , extra_headers : Optional [ Dict [ str , str ]] = None , ) -> None : \"\"\"Init API client.\"\"\" super () . __init__ ( commitment , blockhash_cache ) self . _provider = async_http . AsyncHTTPProvider ( endpoint , timeout = timeout , extra_headers = extra_headers )","title":"__init__()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.close","text":"Use this when you are done with the client. Source code in solana/rpc/async_api.py async def close ( self ) -> None : \"\"\"Use this when you are done with the client.\"\"\" await self . _provider . close ()","title":"close()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.confirm_transaction","text":"Confirm the transaction identified by the specified signature. Parameters: Name Type Description Default tx_sig Signature the transaction signature to confirm. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None sleep_seconds float The number of seconds to sleep when polling the signature status. 0.5 last_valid_block_height Optional[int] The block height by which the transaction would become invalid. None Source code in solana/rpc/async_api.py async def confirm_transaction ( self , tx_sig : Signature , commitment : Optional [ Commitment ] = None , sleep_seconds : float = 0.5 , last_valid_block_height : Optional [ int ] = None , ) -> GetSignatureStatusesResp : \"\"\"Confirm the transaction identified by the specified signature. Args: tx_sig: the transaction signature to confirm. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". sleep_seconds: The number of seconds to sleep when polling the signature status. last_valid_block_height: The block height by which the transaction would become invalid. \"\"\" commitment_to_use = _COMMITMENT_TO_SOLDERS [ commitment or self . _commitment ] commitment_rank = int ( commitment_to_use ) if last_valid_block_height : # pylint: disable=no-else-return current_blockheight = ( await self . get_block_height ( commitment )) . value while current_blockheight <= last_valid_block_height : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break current_blockheight = ( await self . get_block_height ( commitment )) . value await asyncio . sleep ( sleep_seconds ) else : raise TransactionExpiredBlockheightExceededError ( f \" { tx_sig } has expired: block height exceeded\" ) return resp else : timeout = time () + 90 while time () < timeout : resp = await self . get_signature_statuses ([ tx_sig ]) resp_value = resp . value [ 0 ] if resp_value is not None : confirmation_status = resp_value . confirmation_status if confirmation_status is not None : confirmation_rank = int ( confirmation_status ) if confirmation_rank >= commitment_rank : break await asyncio . sleep ( sleep_seconds ) else : raise UnconfirmedTxError ( f \"Unable to confirm transaction { tx_sig } \" ) return resp","title":"confirm_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_account_info","text":"Returns all the account info for the specified public key. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). 'base64' data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_account_info ( Pubkey ([ 0 ] * 31 + [ 1 ]))) . value Account ( Account { lamports : 4104230290 , data . len : 0 , owner : 11111111111111111111111111111111 , executable : false , rent_epoch : 371 , }, ) Source code in solana/rpc/async_api.py async def get_account_info ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetAccountInfoResp : \"\"\"Returns all the account info for the specified public key. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow), \"base64\", or \"jsonParsed\". Default is \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. - \"jsonParsed\" encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If jsonParsed is requested but a parser cannot be found, the field falls back to base64 encoding, detectable when the data field is type. (jsonParsed encoding is UNSTABLE). data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP Account( Account { lamports: 4104230290, data.len: 0, owner: 11111111111111111111111111111111, executable: false, rent_epoch: 371, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetAccountInfoResp )","title":"get_account_info()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_account_info_json_parsed","text":"Returns all the account info for the specified public key. If JSON formatting is not available for this account, base64 is returned. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_account_info_json_parsed ( Pubkey ([ 0 ] * 31 + [ 1 ]))) . value . owner Pubkey ( 11111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def get_account_info_json_parsed ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetAccountInfoMaybeJsonParsedResp : \"\"\"Returns all the account info for the specified public key. If JSON formatting is not available for this account, base64 is returned. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_account_info_json_parsed(Pubkey([0] * 31 + [1]))).value.owner # doctest: +SKIP Pubkey( 11111111111111111111111111111111, ) \"\"\" body = self . _get_account_info_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None ) return await self . _provider . make_request ( body , GetAccountInfoMaybeJsonParsedResp )","title":"get_account_info_json_parsed()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_balance","text":"Returns the balance of the account of provided Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_balance ( Pubkey ([ 0 ] * 31 + [ 1 ]))) . value 0 Source code in solana/rpc/async_api.py async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetBalanceResp : \"\"\"Returns the balance of the account of provided Pubkey. Args: pubkey: Pubkey of account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_balance(Pubkey([0] * 31 + [1]))).value # doctest: +SKIP 0 \"\"\" body = self . _get_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetBalanceResp )","title":"get_balance()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_block","text":"Returns identity and transaction information about a confirmed block in the ledger. Parameters: Name Type Description Default slot int Slot, as u64 integer. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' max_supported_transaction_version int (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block ( 1 )) . value . blockhash Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/async_api.py async def get_block ( self , slot : int , encoding : str = \"json\" , max_supported_transaction_version : int = None , ) -> GetBlockResp : \"\"\"Returns identity and transaction information about a confirmed block in the ledger. Args: slot: Slot, as u64 integer. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block(1)).value.blockhash # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" body = self . _get_block_body ( slot , encoding , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetBlockResp )","title":"get_block()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_block_commitment","text":"Fetch the commitment for particular block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block_commitment ( 0 )) . total_stake 497717120 Source code in solana/rpc/async_api.py async def get_block_commitment ( self , slot : int ) -> GetBlockCommitmentResp : \"\"\"Fetch the commitment for particular block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_commitment(0)).total_stake # doctest: +SKIP 497717120 \"\"\" body = self . _get_block_commitment_body ( slot ) return await self . _provider . make_request ( body , GetBlockCommitmentResp )","title":"get_block_commitment()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_block_height","text":"Returns the current block height of the node. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block_height ()) . value 1233 Source code in solana/rpc/async_api.py async def get_block_height ( self , commitment : Optional [ Commitment ] = None ) -> GetBlockHeightResp : \"\"\"Returns the current block height of the node. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_height()).value # doctest: +SKIP 1233 \"\"\" body = self . _get_block_height_body ( commitment ) return await self . _provider . make_request ( body , GetBlockHeightResp )","title":"get_block_height()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_block_time","text":"Fetch the estimated production time of a block. Parameters: Name Type Description Default slot int Block, identified by Slot. required Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_block_time ( 5 )) . value 1598400007 Source code in solana/rpc/async_api.py async def get_block_time ( self , slot : int ) -> GetBlockTimeResp : \"\"\"Fetch the estimated production time of a block. Args: slot: Block, identified by Slot. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_block_time(5)).value # doctest: +SKIP 1598400007 \"\"\" body = self . _get_block_time_body ( slot ) return await self . _provider . make_request ( body , GetBlockTimeResp )","title":"get_block_time()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_blocks","text":"Returns a list of confirmed blocks. Parameters: Name Type Description Default start_slot int Start slot, as u64 integer. required end_slot Optional[int] (optional) End slot, as u64 integer. None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_blocks ( 5 , 10 )) . value [ 5 , 6 , 7 , 8 , 9 , 10 ] Source code in solana/rpc/async_api.py async def get_blocks ( self , start_slot : int , end_slot : Optional [ int ] = None ) -> GetBlocksResp : \"\"\"Returns a list of confirmed blocks. Args: start_slot: Start slot, as u64 integer. end_slot: (optional) End slot, as u64 integer. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_blocks(5, 10)).value # doctest: +SKIP [5, 6, 7, 8, 9, 10] \"\"\" body = self . _get_blocks_body ( start_slot , end_slot ) return await self . _provider . make_request ( body , GetBlocksResp )","title":"get_blocks()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_cluster_nodes","text":"Returns information about all the nodes participating in the cluster. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_cluster_nodes ()) . value [ 0 ] . tpu '139.178.65.155:8004' Source code in solana/rpc/async_api.py async def get_cluster_nodes ( self ) -> GetClusterNodesResp : \"\"\"Returns information about all the nodes participating in the cluster. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_cluster_nodes()).value[0].tpu # doctest: +SKIP '139.178.65.155:8004' \"\"\" return await self . _provider . make_request ( self . _get_cluster_nodes , GetClusterNodesResp )","title":"get_cluster_nodes()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_epoch_info","text":"Returns information about the current epoch. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_epoch_info ()) . value . epoch 0 Source code in solana/rpc/async_api.py async def get_epoch_info ( self , commitment : Optional [ Commitment ] = None ) -> GetEpochInfoResp : \"\"\"Returns information about the current epoch. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_info()).value.epoch # doctest: +SKIP 0 \"\"\" body = self . _get_epoch_info_body ( commitment ) return await self . _provider . make_request ( body , GetEpochInfoResp )","title":"get_epoch_info()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_epoch_schedule","text":"Returns epoch schedule information from this cluster's genesis config. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_epoch_schedule ()) . value . slots_per_epoch 8192 Source code in solana/rpc/async_api.py async def get_epoch_schedule ( self ) -> GetEpochScheduleResp : \"\"\"Returns epoch schedule information from this cluster's genesis config. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_epoch_schedule()).value.slots_per_epoch # doctest: +SKIP 8192 \"\"\" return await self . _provider . make_request ( self . _get_epoch_schedule , GetEpochScheduleResp )","title":"get_epoch_schedule()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_fee_for_message","text":"Returns the fee for a message. Parameters: Name Type Description Default message Union[solders.message.MessageV0, solders.message.Message] Message that the fee is requested for. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))) >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_fee_for_message ( txn . compile_message ())) . value 5000 Source code in solana/rpc/async_api.py async def get_fee_for_message ( self , message : VersionedMessage , commitment : Optional [ Commitment ] = None ) -> GetFeeForMessageResp : \"\"\"Returns the fee for a message. Args: message: Message that the fee is requested for. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_fee_for_message(txn.compile_message())).value # doctest: +SKIP 5000 \"\"\" body = self . _get_fee_for_message_body ( message , commitment ) return await self . _provider . make_request ( body , GetFeeForMessageResp )","title":"get_fee_for_message()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_first_available_block","text":"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_first_available_block ()) . value 1 Source code in solana/rpc/async_api.py async def get_first_available_block ( self ) -> GetFirstAvailableBlockResp : \"\"\"Returns the slot of the lowest confirmed block that has not been purged from the ledger. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_first_available_block()).value # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_first_available_block , GetFirstAvailableBlockResp )","title":"get_first_available_block()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_genesis_hash","text":"Returns the genesis hash. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_genesis_hash ()) . value Hash ( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG , ) Source code in solana/rpc/async_api.py async def get_genesis_hash ( self ) -> GetGenesisHashResp : \"\"\"Returns the genesis hash. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_genesis_hash()).value # doctest: +SKIP Hash( EtWTRABZaYq6iMfeYKouRu166VU2xqa1wcaWoxPkrZBG, ) \"\"\" return await self . _provider . make_request ( self . _get_genesis_hash , GetGenesisHashResp )","title":"get_genesis_hash()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_identity","text":"Returns the identity pubkey for the current node. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_identity ()) . value . identity Pubkey ( 2 LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv , ) Source code in solana/rpc/async_api.py async def get_identity ( self ) -> GetIdentityResp : \"\"\"Returns the identity pubkey for the current node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_identity()).value.identity # doctest: +SKIP Pubkey( 2LVtX3Wq5bhqAYYaUYBRknWaYrsfYiXLQBHTxtHWD2mv, ) \"\"\" return await self . _provider . make_request ( self . _get_identity , GetIdentityResp )","title":"get_identity()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_inflation_governor","text":"Returns the current inflation governor. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> await ( solana_client . get_inflation_governor ()) . value . foundation 0.05 Source code in solana/rpc/async_api.py async def get_inflation_governor ( self , commitment : Optional [ Commitment ] = None ) -> GetInflationGovernorResp : \"\"\"Returns the current inflation governor. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> await (solana_client.get_inflation_governor()).value.foundation # doctest: +SKIP 0.05 \"\"\" body = self . _get_inflation_governor_body ( commitment ) return await self . _provider . make_request ( body , GetInflationGovernorResp )","title":"get_inflation_governor()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_inflation_rate","text":"Returns the specific inflation values for the current epoch. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_inflation_rate ()) . value . epoch 1 Source code in solana/rpc/async_api.py async def get_inflation_rate ( self ) -> GetInflationRateResp : \"\"\"Returns the specific inflation values for the current epoch. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_inflation_rate()).value.epoch # doctest: +SKIP 1 \"\"\" return await self . _provider . make_request ( self . _get_inflation_rate , GetInflationRateResp )","title":"get_inflation_rate()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_largest_accounts","text":"Returns the 20 largest accounts, by lamport balance. Parameters: Name Type Description Default filter_opt Optional[str] Filter results by account type; currently supported: circulating|nonCirculating. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_largest_accounts ()) . value [ 0 ] . lamports 500000000000000000 Source code in solana/rpc/async_api.py async def get_largest_accounts ( self , filter_opt : Optional [ str ] = None , commitment : Optional [ Commitment ] = None ) -> GetLargestAccountsResp : \"\"\"Returns the 20 largest accounts, by lamport balance. Args: filter_opt: Filter results by account type; currently supported: circulating|nonCirculating. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_largest_accounts()).value[0].lamports # doctest: +SKIP 500000000000000000 \"\"\" body = self . _get_largest_accounts_body ( filter_opt , commitment ) return await self . _provider . make_request ( body , GetLargestAccountsResp )","title":"get_largest_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_latest_blockhash","text":"Returns the latest block hash from the ledger. Response also includes the last valid block height. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_latest_blockhash ()) . value RpcBlockhash { blockhash : Hash ( 4 TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT , ), last_valid_block_height : 158286487 , } Source code in solana/rpc/async_api.py async def get_latest_blockhash ( self , commitment : Optional [ Commitment ] = None ) -> GetLatestBlockhashResp : \"\"\"Returns the latest block hash from the ledger. Response also includes the last valid block height. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_latest_blockhash()).value # doctest: +SKIP RpcBlockhash { blockhash: Hash( 4TLzN2RAACFnd5TYpHcUi76pC3V1qkggRF29HWk2VLeT, ), last_valid_block_height: 158286487, } \"\"\" body = self . _get_latest_blockhash_body ( commitment ) return await self . _provider . make_request ( body , GetLatestBlockhashResp )","title":"get_latest_blockhash()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_leader_schedule","text":"Returns the leader schedule for an epoch. Parameters: Name Type Description Default epoch Optional[int] Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> resp = await solana_client . get_leader_schedule () >>> list ( resp . value . items ())[ 0 ] ( Pubkey ( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr , ), [ 346448 , 346449 , 346450 , 346451 , 369140 , 369141 , 369142 , 369143 , 384204 , 384205 , 384206 , 384207 ]) Source code in solana/rpc/async_api.py async def get_leader_schedule ( self , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None ) -> GetLeaderScheduleResp : \"\"\"Returns the leader schedule for an epoch. Args: epoch: Fetch the leader schedule for the epoch that corresponds to the provided slot. If unspecified, the leader schedule for the current epoch is fetched. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> resp = await solana_client.get_leader_schedule() # doctest: +SKIP >>> list(resp.value.items())[0] # doctest: +SKIP (Pubkey( HMU77m6WSL9Xew9YvVCgz1hLuhzamz74eD9avi4XPdr, ), [346448, 346449, 346450, 346451, 369140, 369141, 369142, 369143, 384204, 384205, 384206, 384207]) \"\"\" body = self . _get_leader_schedule_body ( epoch , commitment ) return await self . _provider . make_request ( body , GetLeaderScheduleResp )","title":"get_leader_schedule()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_minimum_balance_for_rent_exemption","text":"Returns minimum balance required to make account rent exempt. Parameters: Name Type Description Default usize int Account data length. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_minimum_balance_for_rent_exemption ( 50 )) . value 1238880 Source code in solana/rpc/async_api.py async def get_minimum_balance_for_rent_exemption ( self , usize : int , commitment : Optional [ Commitment ] = None ) -> GetMinimumBalanceForRentExemptionResp : \"\"\"Returns minimum balance required to make account rent exempt. Args: usize: Account data length. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_balance_for_rent_exemption(50)).value # doctest: +SKIP 1238880 \"\"\" body = self . _get_minimum_balance_for_rent_exemption_body ( usize , commitment ) return await self . _provider . make_request ( body , GetMinimumBalanceForRentExemptionResp )","title":"get_minimum_balance_for_rent_exemption()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_minimum_ledger_slot","text":"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_minimum_ledger_slot ()) . value 1234 Source code in solana/rpc/async_api.py async def get_minimum_ledger_slot ( self ) -> MinimumLedgerSlotResp : \"\"\"Returns the lowest slot that the node has information about in its ledger. This value may increase over time if the node is configured to purge older ledger data. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_minimum_ledger_slot()).value # doctest: +SKIP 1234 \"\"\" return await self . _provider . make_request ( self . _minimum_ledger_slot , MinimumLedgerSlotResp )","title":"get_minimum_ledger_slot()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_multiple_accounts","text":"Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[solders.pubkey.Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"base58\" is limited to Account data of less than 128 bytes. \"base64\" will return base64 encoded data for Account data of any size. 'base64' data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Option to limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> ( await solana_client . get_multiple_accounts ( pubkeys )) . value [ 0 ] . lamports 1 Source code in solana/rpc/async_api.py async def get_multiple_accounts ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , data_slice : Optional [ types . DataSliceOpts ] = None , ) -> GetMultipleAccountsResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". - \"base58\" is limited to Account data of less than 128 bytes. - \"base64\" will return base64 encoded data for Account data of any size. data_slice: (optional) Option to limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> (await solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = encoding , data_slice = data_slice , ) return await self . _provider . make_request ( body , GetMultipleAccountsResp )","title":"get_multiple_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_multiple_accounts_json_parsed","text":"Returns all the account info for a list of public keys. Parameters: Name Type Description Default pubkeys List[solders.pubkey.Pubkey] list of Pubkeys to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkeys = [ Pubkey . from_string ( \"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\" ), Pubkey . from_string ( \"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\" )] >>> asyncio . run ( solana_client . get_multiple_accounts ( pubkeys )) . value [ 0 ] . lamports 1 Source code in solana/rpc/async_api.py async def get_multiple_accounts_json_parsed ( self , pubkeys : List [ Pubkey ], commitment : Optional [ Commitment ] = None , ) -> GetMultipleAccountsMaybeJsonParsedResp : \"\"\"Returns all the account info for a list of public keys. Args: pubkeys: list of Pubkeys to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkeys = [Pubkey.from_string(\"6ZWcsUiWJ63awprYmbZgBQSreqYZ4s6opowP4b7boUdh\"), Pubkey.from_string(\"HkcE9sqQAnjJtECiFsqGMNmUho3ptXkapUPAqgZQbBSY\")] >>> asyncio.run(solana_client.get_multiple_accounts(pubkeys)).value[0].lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_multiple_accounts_body ( pubkeys = pubkeys , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , ) return await self . _provider . make_request ( body , GetMultipleAccountsResp )","title":"get_multiple_accounts_json_parsed()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_program_accounts","text":"Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None encoding Optional[str] (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". None data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and length : fields; only available for \"base58\" or \"base64\" encoding. None filters Optional[Sequence[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from typing import List , Union >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> memcmp_opts = types . MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , types . MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> ( await solana_client . get_program_accounts ( pubkey , filters = filters )) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/async_api.py async def get_program_accounts ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". encoding: (optional) Encoding for the returned Transaction, either jsonParsed\", \"base58\" (slow), or \"base64\". data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and `length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = encoding , data_slice = data_slice , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsResp )","title":"get_program_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_program_accounts_json_parsed","text":"Returns all accounts owned by the provided program Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of program required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None filters Optional[Sequence[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Examples: >>> from typing import List , Union >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> memcmp_opts = types . MemcmpOpts ( offset = 4 , bytes = \"3Mc6vR\" ) >>> pubkey = Pubkey . from_string ( \"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\" ) >>> filters : List [ Union [ int , types . MemcmpOpts ]] = [ 17 , memcmp_opts ] >>> ( await solana_client . get_program_accounts ( pubkey , filters = filters )) . value [ 0 ] . account . lamports 1 Source code in solana/rpc/async_api.py async def get_program_accounts_json_parsed ( # pylint: disable=too-many-arguments self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> GetProgramAccountsMaybeJsonParsedResp : \"\"\"Returns all accounts owned by the provided program Pubkey. Args: pubkey: Pubkey of program commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. Example: >>> from typing import List, Union >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> memcmp_opts = types.MemcmpOpts(offset=4, bytes=\"3Mc6vR\") >>> pubkey = Pubkey.from_string(\"4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T\") >>> filters: List[Union[int, types.MemcmpOpts]] = [17, memcmp_opts] >>> (await solana_client.get_program_accounts(pubkey, filters=filters)).value[0].account.lamports # doctest: +SKIP 1 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_program_accounts_body ( pubkey = pubkey , commitment = commitment , encoding = \"jsonParsed\" , data_slice = None , filters = filters , ) return await self . _provider . make_request ( body , GetProgramAccountsMaybeJsonParsedResp )","title":"get_program_accounts_json_parsed()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_recent_performance_samples","text":"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Parameters: Name Type Description Default limit Optional[int] Limit (optional) number of samples to return (maximum 720) None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_recent_performance_samples ( 1 )) . value [ 0 ] RpcPerfSample ( RpcPerfSample { slot : 168036172 , num_transactions : 7159 , num_slots : 158 , sample_period_secs : 60 , }, ) Source code in solana/rpc/async_api.py async def get_recent_performance_samples ( self , limit : Optional [ int ] = None ) -> GetRecentPerformanceSamplesResp : \"\"\"Returns a list of recent performance samples, in reverse slot order. Performance samples are taken every 60 seconds and include the number of transactions and slots that occur in a given time window. Args: limit: Limit (optional) number of samples to return (maximum 720) Examples: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_recent_performance_samples(1)).value[0] # doctest: +SKIP RpcPerfSample( RpcPerfSample { slot: 168036172, num_transactions: 7159, num_slots: 158, sample_period_secs: 60, }, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_recent_performance_samples_body ( limit ) return await self . _provider . make_request ( body , GetRecentPerformanceSamplesResp )","title":"get_recent_performance_samples()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_signature_statuses","text":"Returns the statuses of a list of signatures. Unless the search_transaction_history configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus MAX_RECENT_BLOCKHASHES rooted slots. Parameters: Name Type Description Default signatures List[solders.signature.Signature] An array of transaction signatures to confirm. required search_transaction_history bool If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. False Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\" , ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\" ] >>> sigs = [ Signature . from_string ( sig ) for sig in raw_sigs ] >>> ( await solana_client . get_signature_statuses ( sigs )) . value [ 0 ] . confirmations 10 Source code in solana/rpc/async_api.py async def get_signature_statuses ( self , signatures : List [ Signature ], search_transaction_history : bool = False ) -> GetSignatureStatusesResp : \"\"\"Returns the statuses of a list of signatures. Unless the `search_transaction_history` configuration parameter is included, this method only searches the recent status cache of signatures, which retains statuses for all active slots plus `MAX_RECENT_BLOCKHASHES` rooted slots. Args: signatures: An array of transaction signatures to confirm. search_transaction_history: If true, a Solana node will search its ledger cache for any signatures not found in the recent status cache. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> raw_sigs = [ ... \"5VERv8NMvzbJMEkV8xnrLkEaWRtSz9CosKDYjCJjBRnbJLgp8uirBgmQpjKhoR4tjF3ZpRzrFmBV6UjKdiSZkQUW\", ... \"5j7s6NiJS3JAkvgkoc18WVAsiSaci2pxB2A6ueCJP4tprA2TFg9wSyTLeYouxPBJEMzJinENTkpA52YStRW5Dia7\"] >>> sigs = [Signature.from_string(sig) for sig in raw_sigs] >>> (await solana_client.get_signature_statuses(sigs)).value[0].confirmations # doctest: +SKIP 10 \"\"\" body = self . _get_signature_statuses_body ( signatures , search_transaction_history ) return await self . _provider . make_request ( body , GetSignatureStatusesResp )","title":"get_signature_statuses()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_signatures_for_address","text":"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Parameters: Name Type Description Default account Pubkey Account to be queried. required before Optional[solders.signature.Signature] (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. None until Optional[solders.signature.Signature] (optional) Search until this transaction signature, if found before limit reached. None limit Optional[int] (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). None commitment Optional[Commitment] (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey . from_string ( \"Vote111111111111111111111111111111111111111\" ) >>> ( await solana_client . get_signatures_for_address ( pubkey , limit = 1 )) . value [ 0 ] . signature Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def get_signatures_for_address ( self , account : Pubkey , before : Optional [ Signature ] = None , until : Optional [ Signature ] = None , limit : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetSignaturesForAddressResp : \"\"\"Returns confirmed signatures for transactions involving an address. Signatures are returned backwards in time from the provided signature or most recent confirmed block. Args: account: Account to be queried. before: (optional) Start searching backwards from this transaction signature. If not provided the search starts from the top of the highest max confirmed block. until: (optional) Search until this transaction signature, if found before limit reached. limit: (optional) Maximum transaction signatures to return (between 1 and 1,000, default: 1,000). commitment: (optional) Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.pubkey import Pubkey >>> pubkey = Pubkey.from_string(\"Vote111111111111111111111111111111111111111\") >>> (await solana_client.get_signatures_for_address(pubkey, limit=1)).value[0].signature # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _get_signatures_for_address_body ( account , before , until , limit , commitment ) return await self . _provider . make_request ( body , GetSignaturesForAddressResp )","title":"get_signatures_for_address()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_slot","text":"Returns the current slot the node is processing. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_slot ()) . value 7515 Source code in solana/rpc/async_api.py async def get_slot ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotResp : \"\"\"Returns the current slot the node is processing. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot()).value # doctest: +SKIP 7515 \"\"\" body = self . _get_slot_body ( commitment ) return await self . _provider . make_request ( body , GetSlotResp )","title":"get_slot()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_slot_leader","text":"Returns the current slot leader. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_slot_leader ()) . value Pubkey ( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV , ) Source code in solana/rpc/async_api.py async def get_slot_leader ( self , commitment : Optional [ Commitment ] = None ) -> GetSlotLeaderResp : \"\"\"Returns the current slot leader. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_slot_leader()).value # doctest: +SKIP Pubkey( dv2eQHeP4RFrJZ6UeiZWoc3XTtmtZCUKxxCApCDcRNV, ) \"\"\" body = self . _get_slot_leader_body ( commitment ) return await self . _provider . make_request ( body , GetSlotLeaderResp )","title":"get_slot_leader()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_stake_activation","text":"Returns epoch activation information for a stake account. Parameters: Name Type Description Default pubkey Pubkey Pubkey of stake account to query required epoch Optional[int] (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. None commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_stake_activation ()) . value . active 124429280 Source code in solana/rpc/async_api.py async def get_stake_activation ( self , pubkey : Pubkey , epoch : Optional [ int ] = None , commitment : Optional [ Commitment ] = None , ) -> GetStakeActivationResp : \"\"\"Returns epoch activation information for a stake account. Args: pubkey: Pubkey of stake account to query epoch: (optional) Epoch for which to calculate activation details. If parameter not provided, defaults to current epoch. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_stake_activation()).value.active # doctest: +SKIP 124429280 \"\"\" body = self . _get_stake_activation_body ( pubkey , epoch , commitment ) return await self . _provider . make_request ( body , GetStakeActivationResp )","title":"get_stake_activation()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_supply","text":"Returns information about the current supply. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_supply ()) . value . circulating 683635192454157660 Source code in solana/rpc/async_api.py async def get_supply ( self , commitment : Optional [ Commitment ] = None ) -> GetSupplyResp : \"\"\"Returns information about the current supply. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_supply()).value.circulating # doctest: +SKIP 683635192454157660 \"\"\" body = self . _get_supply_body ( commitment ) return await self . _provider . make_request ( body , GetSupplyResp )","title":"get_supply()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_account_balance","text":"Returns the token balance of an SPL Token account (UNSTABLE). Parameters: Name Type Description Default pubkey Pubkey Pubkey of Token account to query required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> pubkey = Pubkey . from_string ( \"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\" ) >>> ( await solana_client . get_token_account_balance ( pubkey )) . value . amount # noqa: E501 '9864' Source code in solana/rpc/async_api.py async def get_token_account_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Returns the token balance of an SPL Token account (UNSTABLE). Args: pubkey: Pubkey of Token account to query commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> pubkey = Pubkey.from_string(\"7fUAJdStEuGbc3sM84cKRL6yYaaSstyLSU4ve5oovLS7\") >>> (await solana_client.get_token_account_balance(pubkey)).value.amount # noqa: E501 # doctest: +SKIP '9864' \"\"\" body = self . _get_token_account_balance_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenAccountBalanceResp )","title":"get_token_account_balance()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_accounts_by_delegate","text":"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_delegate ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateResp : \"\"\"Returns all SPL Token accounts by approved Delegate (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateResp )","title":"get_token_accounts_by_delegate()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_accounts_by_delegate_json_parsed","text":"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Parameters: Name Type Description Default delegate Pubkey Public key of the delegate owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_delegate_json_parsed ( self , delegate : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Returns all SPL Token accounts by approved delegate in JSON format (UNSTABLE). Args: delegate: Public key of the delegate owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_delegate_json_parsed_body ( delegate , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByDelegateJsonParsedResp )","title":"get_token_accounts_by_delegate_json_parsed()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_accounts_by_owner","text":"Returns all SPL Token accounts by token owner (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_owner ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerResp : \"\"\"Returns all SPL Token accounts by token owner (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerResp )","title":"get_token_accounts_by_owner()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_accounts_by_owner_json_parsed","text":"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Parameters: Name Type Description Default owner Pubkey Public key of the account owner to query. required opts TokenAccountOpts Token account option specifying at least one of mint or program_id . required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Source code in solana/rpc/async_api.py async def get_token_accounts_by_owner_json_parsed ( self , owner : Pubkey , opts : types . TokenAccountOpts , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Returns all SPL Token accounts by token owner in JSON format (UNSTABLE). Args: owner: Public key of the account owner to query. opts: Token account option specifying at least one of `mint` or `program_id`. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". \"\"\" body = self . _get_token_accounts_by_owner_json_parsed_body ( owner , opts , commitment ) return await self . _provider . make_request ( body , GetTokenAccountsByOwnerJsonParsedResp )","title":"get_token_accounts_by_owner_json_parsed()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_largest_accounts","text":"Returns the 20 largest accounts of a particular SPL Token type. Source code in solana/rpc/async_api.py async def get_token_largest_accounts ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenLargestAccountsResp : \"\"\"Returns the 20 largest accounts of a particular SPL Token type.\"\"\" body = self . _get_token_largest_accounts_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenLargestAccountsResp )","title":"get_token_largest_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_token_supply","text":"Returns the total supply of an SPL Token type. Source code in solana/rpc/async_api.py async def get_token_supply ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenSupplyResp : \"\"\"Returns the total supply of an SPL Token type.\"\"\" body = self . _get_token_supply_body ( pubkey , commitment ) return await self . _provider . make_request ( body , GetTokenSupplyResp )","title":"get_token_supply()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_transaction","text":"Returns transaction details for a confirmed transaction. Parameters: Name Type Description Default tx_sig Signature Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the transaction.message.instructions list. required encoding str (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. 'json' commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None max_supported_transaction_version Optional[int] (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> from solders.signature import Signature >>> sig = Signature . from_string ( \"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\" ) >>> ( await solana_client . get_transaction ( sig )) . value . block_time 1234 Source code in solana/rpc/async_api.py async def get_transaction ( self , tx_sig : Signature , encoding : str = \"json\" , commitment : Optional [ Commitment ] = None , max_supported_transaction_version : Optional [ int ] = None , ) -> GetTransactionResp : \"\"\"Returns transaction details for a confirmed transaction. Args: tx_sig: Transaction signature as base-58 encoded string N encoding attempts to use program-specific instruction parsers to return more human-readable and explicit data in the `transaction.message.instructions` list. encoding: (optional) Encoding for the returned Transaction, either \"json\", \"jsonParsed\", \"base58\" (slow), or \"base64\". If parameter not provided, the default encoding is JSON. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". max_supported_transaction_version: (optional) The max transaction version to return in responses. If the requested transaction is a higher version, an error will be returned Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> from solders.signature import Signature >>> sig = Signature.from_string(\"3PtGYH77LhhQqTXP4SmDVJ85hmDieWsgXCUbn14v7gYyVYPjZzygUQhTk3bSTYnfA48vCM1rmWY7zWL3j1EVKmEy\") >>> (await solana_client.get_transaction(sig)).value.block_time # doctest: +SKIP 1234 \"\"\" # noqa: E501 # pylint: disable=line-too-long body = self . _get_transaction_body ( tx_sig , encoding , commitment , max_supported_transaction_version ) return await self . _provider . make_request ( body , GetTransactionResp )","title":"get_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_transaction_count","text":"Returns the current Transaction count from the ledger. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_transaction_count ()) . value 4554 Source code in solana/rpc/async_api.py async def get_transaction_count ( self , commitment : Optional [ Commitment ] = None ) -> GetTransactionCountResp : \"\"\"Returns the current Transaction count from the ledger. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_transaction_count()).value # doctest: +SKIP 4554 \"\"\" body = self . _get_transaction_count_body ( commitment ) return await self . _provider . make_request ( body , GetTransactionCountResp )","title":"get_transaction_count()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_version","text":"Returns the current solana versions running on the node. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_version ()) . value . solana_core '1.13.2' Source code in solana/rpc/async_api.py async def get_version ( self ) -> GetVersionResp : \"\"\"Returns the current solana versions running on the node. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_version()).value.solana_core # doctest: +SKIP '1.13.2' \"\"\" return await self . _provider . make_request ( self . _get_version , GetVersionResp )","title":"get_version()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.get_vote_accounts","text":"Returns the account info and associated stake for all the voting accounts in the current bank. Parameters: Name Type Description Default commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . get_vote_accounts ()) . value . current [ 0 ] . commission 100 Source code in solana/rpc/async_api.py async def get_vote_accounts ( self , commitment : Optional [ Commitment ] = None ) -> GetVoteAccountsResp : \"\"\"Returns the account info and associated stake for all the voting accounts in the current bank. Args: commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.get_vote_accounts()).value.current[0].commission # doctest: +SKIP 100 \"\"\" body = self . _get_vote_accounts_body ( commitment ) return await self . _provider . make_request ( body , GetVoteAccountsResp )","title":"get_vote_accounts()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.is_connected","text":"Health check. solana_client = AsyncClient(\"http://localhost:8899\") asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: Type Description bool True if the client is connected. Source code in solana/rpc/async_api.py async def is_connected ( self ) -> bool : \"\"\"Health check. >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> asyncio.run(solana_client.is_connected()) # doctest: +SKIP True Returns: True if the client is connected. \"\"\" return await self . _provider . is_connected ()","title":"is_connected()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.request_airdrop","text":"Requests an airdrop of lamports to a Pubkey. Parameters: Name Type Description Default pubkey Pubkey Pubkey of account to receive lamports, as base-58 encoded string or public key object. required lamports int Amount of lamports. required commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . request_airdrop ( Pubkey ([ 0 ] * 31 + [ 1 ]), 10000 )) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def request_airdrop ( self , pubkey : Pubkey , lamports : int , commitment : Optional [ Commitment ] = None ) -> RequestAirdropResp : \"\"\"Requests an airdrop of lamports to a Pubkey. Args: pubkey: Pubkey of account to receive lamports, as base-58 encoded string or public key object. lamports: Amount of lamports. commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> from solders.pubkey import Pubkey >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.request_airdrop(Pubkey([0] * 31 + [1]), 10000)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" body = self . _request_airdrop_body ( pubkey , lamports , commitment ) return await self . _provider . make_request ( body , RequestAirdropResp )","title":"request_airdrop()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.send_raw_transaction","text":"Send a transaction that has already been signed and serialized into the wire format. Parameters: Name Type Description Default txn bytes Transaction bytes. required opts Optional[solana.rpc.types.TxOpts] (optional) Transaction options. None Before submitting, the following preflight checks are performed (unless disabled with the skip_preflight option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> ( await solana_client . send_raw_transaction ( bytes . fromhex ( full_signed_tx_hex ))) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def send_raw_transaction ( self , txn : bytes , opts : Optional [ types . TxOpts ] = None ) -> SendTransactionResp : \"\"\"Send a transaction that has already been signed and serialized into the wire format. Args: txn: Transaction bytes. opts: (optional) Transaction options. Before submitting, the following preflight checks are performed (unless disabled with the `skip_preflight` option): - The transaction signatures are verified. - The transaction is simulated against the latest max confirmed bank and on failure an error will be returned. Preflight checks may be disabled if desired. Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> (await solana_client.send_raw_transaction(bytes.fromhex(full_signed_tx_hex))).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" # noqa: E501 # pylint: disable=line-too-long opts_to_use = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts body = self . _send_raw_transaction_body ( txn , opts_to_use ) resp = await self . _provider . make_request ( body , SendTransactionResp ) if opts_to_use . skip_confirmation : return self . _post_send ( resp ) post_send_args = self . _send_raw_transaction_post_send_args ( resp , opts_to_use ) return await self . __post_send_with_confirm ( * post_send_args )","title":"send_raw_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.send_transaction","text":"Send a transaction. Parameters: Name Type Description Default txn Union[solders.transaction.VersionedTransaction, solana.transaction.Transaction] transaction object. required signers Keypair Signers to sign the transaction. Only supported for legacy Transaction. () opts Optional[solana.rpc.types.TxOpts] (optional) Transaction options. None recent_blockhash Optional[solders.hash.Hash] (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Only supported for legacy Transaction. None Examples: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams , transfer >>> from solana.transaction import Transaction >>> leading_zeros = [ 0 ] * 31 >>> sender , receiver = Keypair . from_seed ( leading_zeros + [ 1 ]), Keypair . from_seed ( leading_zeros + [ 2 ]) >>> txn = Transaction () . add ( transfer ( TransferParams ( ... from_pubkey = sender . pubkey (), to_pubkey = receiver . pubkey (), lamports = 1000 ))) >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . send_transaction ( txn , sender )) . value Signature ( 1111111111111111111111111111111111111111111111111111111111111111 , ) Source code in solana/rpc/async_api.py async def send_transaction ( self , txn : Union [ VersionedTransaction , Transaction ], * signers : Keypair , opts : Optional [ types . TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Send a transaction. Args: txn: transaction object. signers: Signers to sign the transaction. Only supported for legacy Transaction. opts: (optional) Transaction options. recent_blockhash: (optional) Pass a valid recent blockhash here if you want to skip fetching the recent blockhash or relying on the cache. Only supported for legacy Transaction. Example: >>> from solders.keypair import Keypair >>> from solders.system_program import TransferParams, transfer >>> from solana.transaction import Transaction >>> leading_zeros = [0] * 31 >>> sender, receiver = Keypair.from_seed(leading_zeros + [1]), Keypair.from_seed(leading_zeros + [2]) >>> txn = Transaction().add(transfer(TransferParams( ... from_pubkey=sender.pubkey(), to_pubkey=receiver.pubkey(), lamports=1000))) >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.send_transaction(txn, sender)).value # doctest: +SKIP Signature( 1111111111111111111111111111111111111111111111111111111111111111, ) \"\"\" if isinstance ( txn , VersionedTransaction ): if signers : msg = \"*signers args are not used when sending VersionedTransaction.\" raise ValueError ( msg ) if recent_blockhash is not None : msg = \"recent_blockhash arg is not used when sending VersionedTransaction.\" raise ValueError ( msg ) versioned_tx_opts = types . TxOpts ( preflight_commitment = self . _commitment ) if opts is None else opts return await self . send_raw_transaction ( bytes ( txn ), opts = versioned_tx_opts ) last_valid_block_height = None if recent_blockhash is None : if self . blockhash_cache : try : recent_blockhash = self . blockhash_cache . get () except ValueError : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . _process_blockhash_resp ( blockhash_resp , used_immediately = True ) last_valid_block_height = blockhash_resp . value . last_valid_block_height else : blockhash_resp = await self . get_latest_blockhash ( Finalized ) recent_blockhash = self . parse_recent_blockhash ( blockhash_resp ) last_valid_block_height = blockhash_resp . value . last_valid_block_height txn . recent_blockhash = recent_blockhash txn . sign ( * signers ) opts_to_use = ( types . TxOpts ( preflight_commitment = self . _commitment , last_valid_block_height = last_valid_block_height , ) if opts is None else opts ) txn_resp = await self . send_raw_transaction ( txn . serialize (), opts = opts_to_use ) if self . blockhash_cache : blockhash_resp = await self . get_latest_blockhash ( Finalized ) self . _process_blockhash_resp ( blockhash_resp , used_immediately = False ) return txn_resp","title":"send_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.simulate_transaction","text":"Simulate sending a transaction. Parameters: Name Type Description Default txn Union[solana.transaction.Transaction, solders.transaction.VersionedTransaction] A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. required sig_verify bool If true the transaction signatures will be verified (default: false). False commitment Optional[Commitment] Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". None Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction . deserialize ( bytes . fromhex ( full_signed_tx_hex )) >>> ( await solana_client . simulate_transaction ( tx )) . value . logs [ 'BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success' ] Source code in solana/rpc/async_api.py async def simulate_transaction ( self , txn : Union [ Transaction , VersionedTransaction ], sig_verify : bool = False , commitment : Optional [ Commitment ] = None , ) -> SimulateTransactionResp : \"\"\"Simulate sending a transaction. Args: txn: A Transaction object, a transaction in wire format, or a transaction as base-64 encoded string The transaction must have a valid blockhash, but is not required to be signed. sig_verify: If true the transaction signatures will be verified (default: false). commitment: Bank state to query. It can be either \"finalized\", \"confirmed\" or \"processed\". Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> full_signed_tx_hex = ( ... '01b3795ccfaac3eee838bb05c3b8284122c18acedcd645c914fe8e178c3b62640d8616d061cc818b26cab8ecf3855ecc' ... '72fa113f731ecbd0215e88edc0309d6f0a010001031398f62c6d1a457c51ba6a4b5f3dbd2f69fca93216218dc8997e41' ... '6bd17d93ca68ab4677ffb1f2894dd0a6153c231d45ec436ae53ae60149dbe15f32e4b8703f0000000000000000000000' ... '000000000000000000000000000000000000000000839618f701ba7e9ba27ae59825dd6d6bb66d14f6d5d0eae215161d7' ... '1851a106901020200010c0200000040420f0000000000' ... ) >>> tx = Transaction.deserialize(bytes.fromhex(full_signed_tx_hex)) >>> (await solana_client.simulate_transaction(tx)).value.logs # doctest: +SKIP ['BPF program 83astBRguLMdt2h5U1Tpdq5tjFoJ6noeGwaY3mDLVcri success'] \"\"\" body = self . _simulate_transaction_body ( txn , sig_verify , commitment ) return await self . _provider . make_request ( body , SimulateTransactionResp )","title":"simulate_transaction()"},{"location":"rpc/async_api/#solana.rpc.async_api.AsyncClient.validator_exit","text":"Request to have the validator exit. Validator must have booted with RPC exit enabled ( --enable-rpc-exit parameter). Examples: >>> solana_client = AsyncClient ( \"http://localhost:8899\" ) >>> ( await solana_client . validator_exit ()) . value True Source code in solana/rpc/async_api.py async def validator_exit ( self ) -> ValidatorExitResp : \"\"\"Request to have the validator exit. Validator must have booted with RPC exit enabled (`--enable-rpc-exit` parameter). Example: >>> solana_client = AsyncClient(\"http://localhost:8899\") >>> (await solana_client.validator_exit()).value # doctest: +SKIP True \"\"\" return await self . _provider . make_request ( self . _validator_exit , ValidatorExitResp )","title":"validator_exit()"},{"location":"rpc/commitment/","text":"Commitment solana.rpc.commitment Commitment options. Solana nodes choose which bank state to query based on a commitment requirement set by the client. In descending order of commitment (most finalized to least finalized), clients may specify: Commitment Type for commitment. Confirmed The node will query the most recent block that has been voted on by supermajority of the cluster. It incorporates votes from gossip and replay. It does not count votes on descendants of a block, only direct votes on that block. This confirmation level also upholds \"optimistic confirmation\" guarantees in release 1.3 and onwards. Finalized The node will query the most recent block confirmed by supermajority of the cluster as having reached maximum lockout, meaning the cluster has recognized this block as finalized. Max Deprecated Processed The node will query its most recent block. Note that the block may not be complete. Recent Deprecated Root Deprecated Single Deprecated","title":"Commitment"},{"location":"rpc/commitment/#commitment","text":"","title":"Commitment"},{"location":"rpc/commitment/#solana.rpc.commitment","text":"Commitment options. Solana nodes choose which bank state to query based on a commitment requirement set by the client. In descending order of commitment (most finalized to least finalized), clients may specify:","title":"commitment"},{"location":"rpc/commitment/#solana.rpc.commitment.Commitment","text":"Type for commitment.","title":"Commitment"},{"location":"rpc/commitment/#solana.rpc.commitment.Confirmed","text":"The node will query the most recent block that has been voted on by supermajority of the cluster. It incorporates votes from gossip and replay. It does not count votes on descendants of a block, only direct votes on that block. This confirmation level also upholds \"optimistic confirmation\" guarantees in release 1.3 and onwards.","title":"Confirmed"},{"location":"rpc/commitment/#solana.rpc.commitment.Finalized","text":"The node will query the most recent block confirmed by supermajority of the cluster as having reached maximum lockout, meaning the cluster has recognized this block as finalized.","title":"Finalized"},{"location":"rpc/commitment/#solana.rpc.commitment.Max","text":"Deprecated","title":"Max"},{"location":"rpc/commitment/#solana.rpc.commitment.Processed","text":"The node will query its most recent block. Note that the block may not be complete.","title":"Processed"},{"location":"rpc/commitment/#solana.rpc.commitment.Recent","text":"Deprecated","title":"Recent"},{"location":"rpc/commitment/#solana.rpc.commitment.Root","text":"Deprecated","title":"Root"},{"location":"rpc/commitment/#solana.rpc.commitment.Single","text":"Deprecated","title":"Single"},{"location":"rpc/providers/","text":"RPC Providers solana.rpc.providers special RPC Providers. async_base Async base RPC Provider. AsyncBaseProvider Base class for async RPC providers to implement. Source code in solana/rpc/providers/async_base.py class AsyncBaseProvider : \"\"\"Base class for async RPC providers to implement.\"\"\" async def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) is_connected ( self ) async Health check. Source code in solana/rpc/providers/async_base.py async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) make_request ( self , body , parser ) async Make a request ot the rpc endpoint. Source code in solana/rpc/providers/async_base.py async def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) async_http Async HTTP RPC Provider. AsyncHTTPProvider Async HTTP provider to interact with the http rpc endpoint. Source code in solana/rpc/providers/async_http.py class AsyncHTTPProvider ( AsyncBaseProvider , _HTTPProviderCore ): \"\"\"Async HTTP provider to interact with the http rpc endpoint.\"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , str ]] = None , timeout : float = DEFAULT_TIMEOUT , ): \"\"\"Init AsyncHTTPProvider.\"\"\" super () . __init__ ( endpoint , extra_headers ) self . session = httpx . AsyncClient ( timeout = timeout ) def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"Async HTTP RPC connection { self . endpoint_uri } \" @handle_async_exceptions ( SolanaRpcException , httpx . HTTPError ) async def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" raw = await self . make_request_unparsed ( body ) return _parse_raw ( raw , parser = parser ) async def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) async def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) @overload async def make_batch_request ( self , reqs : _BodiesTup , parsers : _Tup ) -> _RespTup : ... @overload async def make_batch_request ( self , reqs : _BodiesTup1 , parsers : _Tup1 ) -> _RespTup1 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup2 , parsers : _Tup2 ) -> _RespTup2 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup3 , parsers : _Tup3 ) -> _RespTup3 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup4 , parsers : _Tup4 ) -> _RespTup4 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup5 , parsers : _Tup5 ) -> _RespTup5 : ... async def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make an async HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.async_http import AsyncHTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = AsyncHTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> await provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = await self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers ) async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = await self . session . get ( self . health_uri ) response . raise_for_status () except ( IOError , httpx . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . status_code == httpx . codes . OK async def __aenter__ ( self ) -> \"AsyncHTTPProvider\" : \"\"\"Use as a context manager.\"\"\" await self . session . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Close session.\"\"\" await self . session . aclose () __init__ ( self , endpoint = None , extra_headers = None , timeout = 10 ) special Init AsyncHTTPProvider. Source code in solana/rpc/providers/async_http.py def __init__ ( self , endpoint : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , str ]] = None , timeout : float = DEFAULT_TIMEOUT , ): \"\"\"Init AsyncHTTPProvider.\"\"\" super () . __init__ ( endpoint , extra_headers ) self . session = httpx . AsyncClient ( timeout = timeout ) close ( self ) async Close session. Source code in solana/rpc/providers/async_http.py async def close ( self ) -> None : \"\"\"Close session.\"\"\" await self . session . aclose () is_connected ( self ) async Health check. Source code in solana/rpc/providers/async_http.py async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = await self . session . get ( self . health_uri ) response . raise_for_status () except ( IOError , httpx . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . status_code == httpx . codes . OK make_batch_request ( self , reqs , parsers ) async Make an async HTTP batch request to an http rpc endpoint. Parameters: Name Type Description Default reqs Tuple[Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe], ...] A tuple of request objects from solders.rpc.requests . required parsers Union[Tuple[Type[~T]], Tuple[Type[~T], Type[~_T1]], Tuple[Type[~T], Type[~_T1], Type[~_T2]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4], Type[~_T5]]] A tuple of response classes from solders.rpc.responses . Note: parsers should line up with reqs . required Examples: >>> from solana.rpc.providers.async_http import AsyncHTTPProvider >>> from solders.rpc.requests import GetBlockHeight , GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp , GetFirstAvailableBlockResp >>> provider = AsyncHTTPProvider ( \"https://api.devnet.solana.com\" ) >>> reqs = ( GetBlockHeight (), GetFirstAvailableBlock ()) >>> parsers = ( GetBlockHeightResp , GetFirstAvailableBlockResp ) >>> await provider . make_batch_request ( reqs , parsers ) ( GetBlockHeightResp ( 158613909 , ), GetFirstAvailableBlockResp ( 86753592 , )) Source code in solana/rpc/providers/async_http.py async def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make an async HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.async_http import AsyncHTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = AsyncHTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> await provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = await self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers ) make_batch_request_unparsed ( self , reqs ) async Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/async_http.py async def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) make_request_unparsed ( self , body ) async Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/async_http.py async def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) base Base RPC Provider. BaseProvider Base class for RPC providers to implement. Source code in solana/rpc/providers/base.py class BaseProvider : \"\"\"Base class for RPC providers to implement.\"\"\" def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request to the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) is_connected ( self ) Health check. Source code in solana/rpc/providers/base.py def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) make_request ( self , body , parser ) Make a request to the rpc endpoint. Source code in solana/rpc/providers/base.py def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request to the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) core Helper code for HTTP provider classes. get_default_endpoint () Get the default http rpc endpoint. Source code in solana/rpc/providers/core.py def get_default_endpoint () -> URI : \"\"\"Get the default http rpc endpoint.\"\"\" return URI ( os . environ . get ( \"SOLANARPC_HTTP_URI\" , \"http://localhost:8899\" )) http HTTP RPC Provider. HTTPProvider HTTP provider to interact with the http rpc endpoint. Source code in solana/rpc/providers/http.py class HTTPProvider ( BaseProvider , _HTTPProviderCore ): \"\"\"HTTP provider to interact with the http rpc endpoint.\"\"\" def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"HTTP RPC connection { self . endpoint_uri } \" @handle_exceptions ( SolanaRpcException , httpx . HTTPError ) def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make an HTTP request to an http rpc endpoint.\"\"\" raw = self . make_request_unparsed ( body ) return _parse_raw ( raw , parser = parser ) def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = httpx . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = httpx . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) @overload def make_batch_request ( self , reqs : _BodiesTup , parsers : _Tup ) -> _RespTup : ... @overload def make_batch_request ( self , reqs : _BodiesTup1 , parsers : _Tup1 ) -> _RespTup1 : ... @overload def make_batch_request ( self , reqs : _BodiesTup2 , parsers : _Tup2 ) -> _RespTup2 : ... @overload def make_batch_request ( self , reqs : _BodiesTup3 , parsers : _Tup3 ) -> _RespTup3 : ... @overload def make_batch_request ( self , reqs : _BodiesTup4 , parsers : _Tup4 ) -> _RespTup4 : ... @overload def make_batch_request ( self , reqs : _BodiesTup5 , parsers : _Tup5 ) -> _RespTup5 : ... def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make a HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.http import HTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = HTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers ) def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = httpx . get ( self . health_uri ) response . raise_for_status () except ( IOError , httpx . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . status_code == httpx . codes . OK is_connected ( self ) Health check. Source code in solana/rpc/providers/http.py def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = httpx . get ( self . health_uri ) response . raise_for_status () except ( IOError , httpx . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . status_code == httpx . codes . OK make_batch_request ( self , reqs , parsers ) Make a HTTP batch request to an http rpc endpoint. Parameters: Name Type Description Default reqs Tuple[Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe], ...] A tuple of request objects from solders.rpc.requests . required parsers Union[Tuple[Type[~T]], Tuple[Type[~T], Type[~_T1]], Tuple[Type[~T], Type[~_T1], Type[~_T2]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4], Type[~_T5]]] A tuple of response classes from solders.rpc.responses . Note: parsers should line up with reqs . required Examples: >>> from solana.rpc.providers.http import HTTPProvider >>> from solders.rpc.requests import GetBlockHeight , GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp , GetFirstAvailableBlockResp >>> provider = HTTPProvider ( \"https://api.devnet.solana.com\" ) >>> reqs = ( GetBlockHeight (), GetFirstAvailableBlock ()) >>> parsers = ( GetBlockHeightResp , GetFirstAvailableBlockResp ) >>> provider . make_batch_request ( reqs , parsers ) ( GetBlockHeightResp ( 158613909 , ), GetFirstAvailableBlockResp ( 86753592 , )) Source code in solana/rpc/providers/http.py def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make a HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.http import HTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = HTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers ) make_batch_request_unparsed ( self , reqs ) Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/http.py def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = httpx . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) make_request_unparsed ( self , body ) Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/http.py def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = httpx . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response )","title":"RPC Providers"},{"location":"rpc/providers/#rpc-providers","text":"","title":"RPC Providers"},{"location":"rpc/providers/#solana.rpc.providers","text":"RPC Providers.","title":"providers"},{"location":"rpc/providers/#solana.rpc.providers.async_base","text":"Async base RPC Provider.","title":"async_base"},{"location":"rpc/providers/#solana.rpc.providers.async_base.AsyncBaseProvider","text":"Base class for async RPC providers to implement. Source code in solana/rpc/providers/async_base.py class AsyncBaseProvider : \"\"\"Base class for async RPC providers to implement.\"\"\" async def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"AsyncBaseProvider"},{"location":"rpc/providers/#solana.rpc.providers.async_base.AsyncBaseProvider.is_connected","text":"Health check. Source code in solana/rpc/providers/async_base.py async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"is_connected()"},{"location":"rpc/providers/#solana.rpc.providers.async_base.AsyncBaseProvider.make_request","text":"Make a request ot the rpc endpoint. Source code in solana/rpc/providers/async_base.py async def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request ot the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"make_request()"},{"location":"rpc/providers/#solana.rpc.providers.async_http","text":"Async HTTP RPC Provider.","title":"async_http"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider","text":"Async HTTP provider to interact with the http rpc endpoint. Source code in solana/rpc/providers/async_http.py class AsyncHTTPProvider ( AsyncBaseProvider , _HTTPProviderCore ): \"\"\"Async HTTP provider to interact with the http rpc endpoint.\"\"\" def __init__ ( self , endpoint : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , str ]] = None , timeout : float = DEFAULT_TIMEOUT , ): \"\"\"Init AsyncHTTPProvider.\"\"\" super () . __init__ ( endpoint , extra_headers ) self . session = httpx . AsyncClient ( timeout = timeout ) def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"Async HTTP RPC connection { self . endpoint_uri } \" @handle_async_exceptions ( SolanaRpcException , httpx . HTTPError ) async def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" raw = await self . make_request_unparsed ( body ) return _parse_raw ( raw , parser = parser ) async def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) async def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) @overload async def make_batch_request ( self , reqs : _BodiesTup , parsers : _Tup ) -> _RespTup : ... @overload async def make_batch_request ( self , reqs : _BodiesTup1 , parsers : _Tup1 ) -> _RespTup1 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup2 , parsers : _Tup2 ) -> _RespTup2 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup3 , parsers : _Tup3 ) -> _RespTup3 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup4 , parsers : _Tup4 ) -> _RespTup4 : ... @overload async def make_batch_request ( self , reqs : _BodiesTup5 , parsers : _Tup5 ) -> _RespTup5 : ... async def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make an async HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.async_http import AsyncHTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = AsyncHTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> await provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = await self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers ) async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = await self . session . get ( self . health_uri ) response . raise_for_status () except ( IOError , httpx . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . status_code == httpx . codes . OK async def __aenter__ ( self ) -> \"AsyncHTTPProvider\" : \"\"\"Use as a context manager.\"\"\" await self . session . __aenter__ () return self async def __aexit__ ( self , _exc_type , _exc , _tb ): \"\"\"Exits the context manager.\"\"\" await self . close () async def close ( self ) -> None : \"\"\"Close session.\"\"\" await self . session . aclose ()","title":"AsyncHTTPProvider"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.__init__","text":"Init AsyncHTTPProvider. Source code in solana/rpc/providers/async_http.py def __init__ ( self , endpoint : Optional [ str ] = None , extra_headers : Optional [ Dict [ str , str ]] = None , timeout : float = DEFAULT_TIMEOUT , ): \"\"\"Init AsyncHTTPProvider.\"\"\" super () . __init__ ( endpoint , extra_headers ) self . session = httpx . AsyncClient ( timeout = timeout )","title":"__init__()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.close","text":"Close session. Source code in solana/rpc/providers/async_http.py async def close ( self ) -> None : \"\"\"Close session.\"\"\" await self . session . aclose ()","title":"close()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.is_connected","text":"Health check. Source code in solana/rpc/providers/async_http.py async def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = await self . session . get ( self . health_uri ) response . raise_for_status () except ( IOError , httpx . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . status_code == httpx . codes . OK","title":"is_connected()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.make_batch_request","text":"Make an async HTTP batch request to an http rpc endpoint. Parameters: Name Type Description Default reqs Tuple[Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe], ...] A tuple of request objects from solders.rpc.requests . required parsers Union[Tuple[Type[~T]], Tuple[Type[~T], Type[~_T1]], Tuple[Type[~T], Type[~_T1], Type[~_T2]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4], Type[~_T5]]] A tuple of response classes from solders.rpc.responses . Note: parsers should line up with reqs . required Examples: >>> from solana.rpc.providers.async_http import AsyncHTTPProvider >>> from solders.rpc.requests import GetBlockHeight , GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp , GetFirstAvailableBlockResp >>> provider = AsyncHTTPProvider ( \"https://api.devnet.solana.com\" ) >>> reqs = ( GetBlockHeight (), GetFirstAvailableBlock ()) >>> parsers = ( GetBlockHeightResp , GetFirstAvailableBlockResp ) >>> await provider . make_batch_request ( reqs , parsers ) ( GetBlockHeightResp ( 158613909 , ), GetFirstAvailableBlockResp ( 86753592 , )) Source code in solana/rpc/providers/async_http.py async def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make an async HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.async_http import AsyncHTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = AsyncHTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> await provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = await self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers )","title":"make_batch_request()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.make_batch_request_unparsed","text":"Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/async_http.py async def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response )","title":"make_batch_request_unparsed()"},{"location":"rpc/providers/#solana.rpc.providers.async_http.AsyncHTTPProvider.make_request_unparsed","text":"Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/async_http.py async def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = await self . session . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response )","title":"make_request_unparsed()"},{"location":"rpc/providers/#solana.rpc.providers.base","text":"Base RPC Provider.","title":"base"},{"location":"rpc/providers/#solana.rpc.providers.base.BaseProvider","text":"Base class for RPC providers to implement. Source code in solana/rpc/providers/base.py class BaseProvider : \"\"\"Base class for RPC providers to implement.\"\"\" def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request to the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" ) def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"BaseProvider"},{"location":"rpc/providers/#solana.rpc.providers.base.BaseProvider.is_connected","text":"Health check. Source code in solana/rpc/providers/base.py def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"is_connected()"},{"location":"rpc/providers/#solana.rpc.providers.base.BaseProvider.make_request","text":"Make a request to the rpc endpoint. Source code in solana/rpc/providers/base.py def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make a request to the rpc endpoint.\"\"\" raise NotImplementedError ( \"Providers must implement this method\" )","title":"make_request()"},{"location":"rpc/providers/#solana.rpc.providers.core","text":"Helper code for HTTP provider classes.","title":"core"},{"location":"rpc/providers/#solana.rpc.providers.core.get_default_endpoint","text":"Get the default http rpc endpoint. Source code in solana/rpc/providers/core.py def get_default_endpoint () -> URI : \"\"\"Get the default http rpc endpoint.\"\"\" return URI ( os . environ . get ( \"SOLANARPC_HTTP_URI\" , \"http://localhost:8899\" ))","title":"get_default_endpoint()"},{"location":"rpc/providers/#solana.rpc.providers.http","text":"HTTP RPC Provider.","title":"http"},{"location":"rpc/providers/#solana.rpc.providers.http.HTTPProvider","text":"HTTP provider to interact with the http rpc endpoint. Source code in solana/rpc/providers/http.py class HTTPProvider ( BaseProvider , _HTTPProviderCore ): \"\"\"HTTP provider to interact with the http rpc endpoint.\"\"\" def __str__ ( self ) -> str : \"\"\"String definition for HTTPProvider.\"\"\" return f \"HTTP RPC connection { self . endpoint_uri } \" @handle_exceptions ( SolanaRpcException , httpx . HTTPError ) def make_request ( self , body : Body , parser : Type [ T ]) -> T : \"\"\"Make an HTTP request to an http rpc endpoint.\"\"\" raw = self . make_request_unparsed ( body ) return _parse_raw ( raw , parser = parser ) def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = httpx . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = httpx . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response ) @overload def make_batch_request ( self , reqs : _BodiesTup , parsers : _Tup ) -> _RespTup : ... @overload def make_batch_request ( self , reqs : _BodiesTup1 , parsers : _Tup1 ) -> _RespTup1 : ... @overload def make_batch_request ( self , reqs : _BodiesTup2 , parsers : _Tup2 ) -> _RespTup2 : ... @overload def make_batch_request ( self , reqs : _BodiesTup3 , parsers : _Tup3 ) -> _RespTup3 : ... @overload def make_batch_request ( self , reqs : _BodiesTup4 , parsers : _Tup4 ) -> _RespTup4 : ... @overload def make_batch_request ( self , reqs : _BodiesTup5 , parsers : _Tup5 ) -> _RespTup5 : ... def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make a HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.http import HTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = HTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers ) def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = httpx . get ( self . health_uri ) response . raise_for_status () except ( IOError , httpx . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . status_code == httpx . codes . OK","title":"HTTPProvider"},{"location":"rpc/providers/#solana.rpc.providers.http.HTTPProvider.is_connected","text":"Health check. Source code in solana/rpc/providers/http.py def is_connected ( self ) -> bool : \"\"\"Health check.\"\"\" try : response = httpx . get ( self . health_uri ) response . raise_for_status () except ( IOError , httpx . HTTPError ) as err : self . logger . error ( \"Health check failed with error: %s \" , str ( err )) return False return response . status_code == httpx . codes . OK","title":"is_connected()"},{"location":"rpc/providers/#solana.rpc.providers.http.HTTPProvider.make_batch_request","text":"Make a HTTP batch request to an http rpc endpoint. Parameters: Name Type Description Default reqs Tuple[Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe], ...] A tuple of request objects from solders.rpc.requests . required parsers Union[Tuple[Type[~T]], Tuple[Type[~T], Type[~_T1]], Tuple[Type[~T], Type[~_T1], Type[~_T2]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4]], Tuple[Type[~T], Type[~_T1], Type[~_T2], Type[~_T3], Type[~_T4], Type[~_T5]]] A tuple of response classes from solders.rpc.responses . Note: parsers should line up with reqs . required Examples: >>> from solana.rpc.providers.http import HTTPProvider >>> from solders.rpc.requests import GetBlockHeight , GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp , GetFirstAvailableBlockResp >>> provider = HTTPProvider ( \"https://api.devnet.solana.com\" ) >>> reqs = ( GetBlockHeight (), GetFirstAvailableBlock ()) >>> parsers = ( GetBlockHeightResp , GetFirstAvailableBlockResp ) >>> provider . make_batch_request ( reqs , parsers ) ( GetBlockHeightResp ( 158613909 , ), GetFirstAvailableBlockResp ( 86753592 , )) Source code in solana/rpc/providers/http.py def make_batch_request ( self , reqs : Tuple [ Body , ... ], parsers : _Tuples ) -> Tuple [ RPCResult , ... ]: \"\"\"Make a HTTP batch request to an http rpc endpoint. Args: reqs: A tuple of request objects from ``solders.rpc.requests``. parsers: A tuple of response classes from ``solders.rpc.responses``. Note: ``parsers`` should line up with ``reqs``. Example: >>> from solana.rpc.providers.http import HTTPProvider >>> from solders.rpc.requests import GetBlockHeight, GetFirstAvailableBlock >>> from solders.rpc.responses import GetBlockHeightResp, GetFirstAvailableBlockResp >>> provider = HTTPProvider(\"https://api.devnet.solana.com\") >>> reqs = (GetBlockHeight(), GetFirstAvailableBlock()) >>> parsers = (GetBlockHeightResp, GetFirstAvailableBlockResp) >>> provider.make_batch_request(reqs, parsers) # doctest: +SKIP (GetBlockHeightResp( 158613909, ), GetFirstAvailableBlockResp( 86753592, )) \"\"\" raw = self . make_batch_request_unparsed ( reqs ) return _parse_raw_batch ( raw , parsers )","title":"make_batch_request()"},{"location":"rpc/providers/#solana.rpc.providers.http.HTTPProvider.make_batch_request_unparsed","text":"Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/http.py def make_batch_request_unparsed ( self , reqs : Tuple [ Body , ... ]) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_batch_request ( reqs ) raw_response = httpx . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response )","title":"make_batch_request_unparsed()"},{"location":"rpc/providers/#solana.rpc.providers.http.HTTPProvider.make_request_unparsed","text":"Make an async HTTP request to an http rpc endpoint. Source code in solana/rpc/providers/http.py def make_request_unparsed ( self , body : Body ) -> str : \"\"\"Make an async HTTP request to an http rpc endpoint.\"\"\" request_kwargs = self . _before_request ( body = body ) raw_response = httpx . post ( ** request_kwargs ) return _after_request_unparsed ( raw_response )","title":"make_request_unparsed()"},{"location":"rpc/types/","text":"RPC Types solana.rpc.types RPC types. RPCMethod Type for RPC method. URI Type for endpoint URI. DataSliceOpts Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding. Source code in solana/rpc/types.py class DataSliceOpts ( NamedTuple ): \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\" offset : int \"\"\"Limit the returned account data using the provided offset: <usize>.\"\"\" length : int \"\"\"Limit the returned account data using the provided length: <usize>.\"\"\" length : int Limit the returned account data using the provided length: . offset : int Limit the returned account data using the provided offset: . MemcmpOpts Option to compare a provided series of bytes with program account data at a particular offset. Source code in solana/rpc/types.py class MemcmpOpts ( NamedTuple ): \"\"\"Option to compare a provided series of bytes with program account data at a particular offset.\"\"\" offset : int \"\"\"Offset into program account data to start comparison: <usize>.\"\"\" bytes : str # noqa: A003 \"\"\"Data to match, as base-58 encoded string: <string>.\"\"\" bytes : str Data to match, as base-58 encoded string: . offset : int Offset into program account data to start comparison: . RPCError RPC error. Source code in solana/rpc/types.py class RPCError ( TypedDict ): \"\"\"RPC error.\"\"\" code : int \"\"\"HTTP status code.\"\"\" message : str \"\"\"Error message.\"\"\" TokenAccountOpts Options when querying token accounts. Provide one of mint or program_id. Source code in solana/rpc/types.py class TokenAccountOpts ( NamedTuple ): \"\"\"Options when querying token accounts. Provide one of mint or program_id. \"\"\" mint : Optional [ Pubkey ] = None \"\"\"Public key of the specific token Mint to limit accounts to.\"\"\" program_id : Optional [ Pubkey ] = None \"\"\"Public key of the Token program ID that owns the accounts.\"\"\" encoding : str = \"base64\" \"\"\"Encoding for Account data, either \"base58\" (slow) or \"base64\".\"\"\" data_slice : Optional [ DataSliceOpts ] = None \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\" data_slice : Optional [ solana . rpc . types . DataSliceOpts ] Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding. encoding : str Encoding for Account data, either \"base58\" (slow) or \"base64\". mint : Optional [ solders . pubkey . Pubkey ] Public key of the specific token Mint to limit accounts to. program_id : Optional [ solders . pubkey . Pubkey ] Public key of the Token program ID that owns the accounts. TxOpts Options to specify when broadcasting a transaction. Source code in solana/rpc/types.py class TxOpts ( NamedTuple ): \"\"\"Options to specify when broadcasting a transaction.\"\"\" skip_confirmation : bool = True \"\"\"If false, `send_transaction` will try to confirm that the transaction was successfully broadcasted. When confirming a transaction, `send_transaction` will block for a maximum of 30 seconds. Wrap the call inside a thread to make it asynchronous. \"\"\" skip_preflight : bool = False \"\"\"If true, skip the preflight transaction checks.\"\"\" preflight_commitment : Commitment = Finalized \"\"\"Commitment level to use for preflight.\"\"\" max_retries : Optional [ int ] = None \"\"\"Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires. \"\"\" last_valid_block_height : Optional [ int ] = None \"\"\"Pass the latest valid block height here, to be consumed by confirm_transaction. Valid only if skip_confirmation is False. \"\"\" last_valid_block_height : Optional [ int ] Pass the latest valid block height here, to be consumed by confirm_transaction. Valid only if skip_confirmation is False. max_retries : Optional [ int ] Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires. preflight_commitment : < function NewType .< locals >. new_type at 0x7fe64a4b74c0 > Commitment level to use for preflight. skip_confirmation : bool If false, send_transaction will try to confirm that the transaction was successfully broadcasted. When confirming a transaction, send_transaction will block for a maximum of 30 seconds. Wrap the call inside a thread to make it asynchronous. skip_preflight : bool If true, skip the preflight transaction checks.","title":"RPC Types"},{"location":"rpc/types/#rpc-types","text":"","title":"RPC Types"},{"location":"rpc/types/#solana.rpc.types","text":"RPC types.","title":"types"},{"location":"rpc/types/#solana.rpc.types.RPCMethod","text":"Type for RPC method.","title":"RPCMethod"},{"location":"rpc/types/#solana.rpc.types.URI","text":"Type for endpoint URI.","title":"URI"},{"location":"rpc/types/#solana.rpc.types.DataSliceOpts","text":"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding. Source code in solana/rpc/types.py class DataSliceOpts ( NamedTuple ): \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\" offset : int \"\"\"Limit the returned account data using the provided offset: <usize>.\"\"\" length : int \"\"\"Limit the returned account data using the provided length: <usize>.\"\"\"","title":"DataSliceOpts"},{"location":"rpc/types/#solana.rpc.types.DataSliceOpts.length","text":"Limit the returned account data using the provided length: .","title":"length"},{"location":"rpc/types/#solana.rpc.types.DataSliceOpts.offset","text":"Limit the returned account data using the provided offset: .","title":"offset"},{"location":"rpc/types/#solana.rpc.types.MemcmpOpts","text":"Option to compare a provided series of bytes with program account data at a particular offset. Source code in solana/rpc/types.py class MemcmpOpts ( NamedTuple ): \"\"\"Option to compare a provided series of bytes with program account data at a particular offset.\"\"\" offset : int \"\"\"Offset into program account data to start comparison: <usize>.\"\"\" bytes : str # noqa: A003 \"\"\"Data to match, as base-58 encoded string: <string>.\"\"\"","title":"MemcmpOpts"},{"location":"rpc/types/#solana.rpc.types.MemcmpOpts.bytes","text":"Data to match, as base-58 encoded string: .","title":"bytes"},{"location":"rpc/types/#solana.rpc.types.MemcmpOpts.offset","text":"Offset into program account data to start comparison: .","title":"offset"},{"location":"rpc/types/#solana.rpc.types.RPCError","text":"RPC error. Source code in solana/rpc/types.py class RPCError ( TypedDict ): \"\"\"RPC error.\"\"\" code : int \"\"\"HTTP status code.\"\"\" message : str \"\"\"Error message.\"\"\"","title":"RPCError"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts","text":"Options when querying token accounts. Provide one of mint or program_id. Source code in solana/rpc/types.py class TokenAccountOpts ( NamedTuple ): \"\"\"Options when querying token accounts. Provide one of mint or program_id. \"\"\" mint : Optional [ Pubkey ] = None \"\"\"Public key of the specific token Mint to limit accounts to.\"\"\" program_id : Optional [ Pubkey ] = None \"\"\"Public key of the Token program ID that owns the accounts.\"\"\" encoding : str = \"base64\" \"\"\"Encoding for Account data, either \"base58\" (slow) or \"base64\".\"\"\" data_slice : Optional [ DataSliceOpts ] = None \"\"\"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.\"\"\"","title":"TokenAccountOpts"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.data_slice","text":"Option to limit the returned account data, only available for \"base58\" or \"base64\" encoding.","title":"data_slice"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.encoding","text":"Encoding for Account data, either \"base58\" (slow) or \"base64\".","title":"encoding"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.mint","text":"Public key of the specific token Mint to limit accounts to.","title":"mint"},{"location":"rpc/types/#solana.rpc.types.TokenAccountOpts.program_id","text":"Public key of the Token program ID that owns the accounts.","title":"program_id"},{"location":"rpc/types/#solana.rpc.types.TxOpts","text":"Options to specify when broadcasting a transaction. Source code in solana/rpc/types.py class TxOpts ( NamedTuple ): \"\"\"Options to specify when broadcasting a transaction.\"\"\" skip_confirmation : bool = True \"\"\"If false, `send_transaction` will try to confirm that the transaction was successfully broadcasted. When confirming a transaction, `send_transaction` will block for a maximum of 30 seconds. Wrap the call inside a thread to make it asynchronous. \"\"\" skip_preflight : bool = False \"\"\"If true, skip the preflight transaction checks.\"\"\" preflight_commitment : Commitment = Finalized \"\"\"Commitment level to use for preflight.\"\"\" max_retries : Optional [ int ] = None \"\"\"Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires. \"\"\" last_valid_block_height : Optional [ int ] = None \"\"\"Pass the latest valid block height here, to be consumed by confirm_transaction. Valid only if skip_confirmation is False. \"\"\"","title":"TxOpts"},{"location":"rpc/types/#solana.rpc.types.TxOpts.last_valid_block_height","text":"Pass the latest valid block height here, to be consumed by confirm_transaction. Valid only if skip_confirmation is False.","title":"last_valid_block_height"},{"location":"rpc/types/#solana.rpc.types.TxOpts.max_retries","text":"Maximum number of times for the RPC node to retry sending the transaction to the leader. If this parameter not provided, the RPC node will retry the transaction until it is finalized or until the blockhash expires.","title":"max_retries"},{"location":"rpc/types/#solana.rpc.types.TxOpts.preflight_commitment","text":"Commitment level to use for preflight.","title":"preflight_commitment"},{"location":"rpc/types/#solana.rpc.types.TxOpts.skip_confirmation","text":"If false, send_transaction will try to confirm that the transaction was successfully broadcasted. When confirming a transaction, send_transaction will block for a maximum of 30 seconds. Wrap the call inside a thread to make it asynchronous.","title":"skip_confirmation"},{"location":"rpc/types/#solana.rpc.types.TxOpts.skip_preflight","text":"If true, skip the preflight transaction checks.","title":"skip_preflight"},{"location":"rpc/websocket/","text":"Websocket Client solana.rpc.websocket_api This module contains code for interacting with the RPC Websocket endpoint. SolanaWsClientProtocol Subclass of websockets.WebSocketClientProtocol tailored for Solana RPC websockets. Source code in solana/rpc/websocket_api.py class SolanaWsClientProtocol ( WebSocketClientProtocol ): \"\"\"Subclass of `websockets.WebSocketClientProtocol` tailored for Solana RPC websockets.\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Init. Args and kwargs are passed to `websockets.WebSocketClientProtocol`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . subscriptions : Dict [ int , Body ] = {} self . sent_subscriptions : Dict [ int , Body ] = {} self . failed_subscriptions = {} self . request_counter = itertools . count () def increment_counter_and_get_id ( self ) -> int : \"\"\"Increment self.request_counter and return the latest id.\"\"\" return next ( self . request_counter ) + 1 async def send_data ( self , message : Union [ Body , List [ Body ]]) -> None : \"\"\"Send a subscribe/unsubscribe request or list of requests. Basically `.send` from `websockets` with extra parsing. Args: message: The request(s) to send. \"\"\" if isinstance ( message , list ): to_send = batch_to_json ( message ) for req in message : self . sent_subscriptions [ req . id ] = req else : to_send = message . to_json () self . sent_subscriptions [ message . id ] = message await super () . send ( to_send ) # type: ignore async def recv ( # type: ignore self , ) -> List [ Union [ Notification , SubscriptionResult ]]: \"\"\"Receive the next message. Basically `.recv` from `websockets` with extra parsing. \"\"\" data = await super () . recv () return self . _process_rpc_response ( cast ( str , data )) async def account_subscribe ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , ) -> None : \"\"\"Subscribe to an account to receive notifications when the lamports or data change. Args: pubkey: Account pubkey. commitment: Commitment level. encoding: Encoding to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] config = ( None if commitment_to_use is None and encoding_to_use is None else RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use ) ) req = AccountSubscribe ( pubkey , config , req_id ) await self . send_data ( req ) async def account_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = AccountUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def logs_subscribe ( self , filter_ : Union [ RpcTransactionLogsFilter , RpcTransactionLogsFilterMentions ] = RpcTransactionLogsFilter . All , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to transaction logging. Args: filter_: filter criteria for the logs. commitment: The commitment level to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = RpcTransactionLogsConfig ( commitment_to_use ) req = LogsSubscribe ( filter_ , config , req_id ) await self . send_data ( req ) async def logs_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from transaction logging. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = LogsUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def program_subscribe ( # pylint: disable=too-many-arguments self , program_id : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> None : \"\"\"Receive notifications when the lamports or data for a given account owned by the program changes. Args: program_id: The program ID. commitment: Commitment level to use. encoding: Encoding to use. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. \"\"\" # noqa: E501 # pylint: disable=line-too-long req_id = self . increment_counter_and_get_id () if commitment is None and encoding is None and data_slice is None and filters is None : config = None else : encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] data_slice_to_use = ( None if data_slice is None else UiDataSliceConfig ( offset = data_slice . offset , length = data_slice . length ) ) account_config = RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use , data_slice = data_slice_to_use , ) filters_to_use : Optional [ List [ Union [ int , Memcmp ]]] = ( None if filters is None else [ x if isinstance ( x , int ) else Memcmp ( * x ) for x in filters ] ) config = RpcProgramAccountsConfig ( account_config , filters_to_use ) req = ProgramSubscribe ( program_id , config , req_id ) await self . send_data ( req ) async def program_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from program account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = ProgramUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def signature_subscribe ( self , signature : Signature , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Args: signature: The transaction signature to subscribe to. commitment: Commitment level. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = None if commitment_to_use is None else RpcSignatureSubscribeConfig ( commitment = commitment_to_use ) req = SignatureSubscribe ( signature , config , req_id ) await self . send_data ( req ) async def signature_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from signature notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SignatureUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def slot_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a slot is processed by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotSubscribe ( req_id ) await self . send_data ( req ) async def slot_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def slots_updates_subscribe ( self ) -> None : \"\"\"Subscribe to receive a notification from the validator on a variety of updates on every slot.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesSubscribe ( req_id ) await self . send_data ( req ) async def slots_updates_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot update notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def root_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new root is set by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = RootSubscribe ( req_id ) await self . send_data ( req ) async def root_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from root notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = RootUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def vote_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new vote is observed in gossip.\"\"\" req_id = self . increment_counter_and_get_id () req = VoteSubscribe ( req_id ) await self . send_data ( req ) async def vote_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from vote notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = VoteUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] def _process_rpc_response ( self , raw : str ) -> List [ Union [ Notification , SubscriptionResult ]]: parsed = parse_websocket_message ( raw ) for item in parsed : if isinstance ( item , SoldersSubscriptionError ): subscription = self . sent_subscriptions [ item . id ] self . failed_subscriptions [ item . id ] = subscription raise SubscriptionError ( item , subscription ) if isinstance ( item , SubscriptionResult ): self . subscriptions [ item . result ] = self . sent_subscriptions [ item . id ] return cast ( List [ Union [ Notification , SubscriptionResult ]], parsed ) __init__ ( self , * args , ** kwargs ) special Init. Args and kwargs are passed to websockets.WebSocketClientProtocol . Source code in solana/rpc/websocket_api.py def __init__ ( self , * args , ** kwargs ): \"\"\"Init. Args and kwargs are passed to `websockets.WebSocketClientProtocol`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . subscriptions : Dict [ int , Body ] = {} self . sent_subscriptions : Dict [ int , Body ] = {} self . failed_subscriptions = {} self . request_counter = itertools . count () account_subscribe ( self , pubkey , commitment = None , encoding = None ) async Subscribe to an account to receive notifications when the lamports or data change. Parameters: Name Type Description Default pubkey Pubkey Account pubkey. required commitment Optional[Commitment] Commitment level. None encoding Optional[str] Encoding to use. None Source code in solana/rpc/websocket_api.py async def account_subscribe ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , ) -> None : \"\"\"Subscribe to an account to receive notifications when the lamports or data change. Args: pubkey: Account pubkey. commitment: Commitment level. encoding: Encoding to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] config = ( None if commitment_to_use is None and encoding_to_use is None else RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use ) ) req = AccountSubscribe ( pubkey , config , req_id ) await self . send_data ( req ) account_unsubscribe ( self , subscription ) async Unsubscribe from account notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def account_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = AccountUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] increment_counter_and_get_id ( self ) Increment self.request_counter and return the latest id. Source code in solana/rpc/websocket_api.py def increment_counter_and_get_id ( self ) -> int : \"\"\"Increment self.request_counter and return the latest id.\"\"\" return next ( self . request_counter ) + 1 logs_subscribe ( self , filter_ = RpcTransactionLogsFilter . All , commitment = None ) async Subscribe to transaction logging. Parameters: Name Type Description Default filter_ Union[solders.rpc.config.RpcTransactionLogsFilter, solders.rpc.config.RpcTransactionLogsFilterMentions] filter criteria for the logs. RpcTransactionLogsFilter.All commitment Optional[Commitment] The commitment level to use. None Source code in solana/rpc/websocket_api.py async def logs_subscribe ( self , filter_ : Union [ RpcTransactionLogsFilter , RpcTransactionLogsFilterMentions ] = RpcTransactionLogsFilter . All , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to transaction logging. Args: filter_: filter criteria for the logs. commitment: The commitment level to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = RpcTransactionLogsConfig ( commitment_to_use ) req = LogsSubscribe ( filter_ , config , req_id ) await self . send_data ( req ) logs_unsubscribe ( self , subscription ) async Unsubscribe from transaction logging. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def logs_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from transaction logging. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = LogsUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] program_subscribe ( self , program_id , commitment = None , encoding = None , data_slice = None , filters = None ) async Receive notifications when the lamports or data for a given account owned by the program changes. Parameters: Name Type Description Default program_id Pubkey The program ID. required commitment Optional[Commitment] Commitment level to use. None encoding Optional[str] Encoding to use. None data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and None ` length` fields; only available for \"base58\" or \"base64\" encoding. required filters Optional[Sequence[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Source code in solana/rpc/websocket_api.py async def program_subscribe ( # pylint: disable=too-many-arguments self , program_id : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> None : \"\"\"Receive notifications when the lamports or data for a given account owned by the program changes. Args: program_id: The program ID. commitment: Commitment level to use. encoding: Encoding to use. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. \"\"\" # noqa: E501 # pylint: disable=line-too-long req_id = self . increment_counter_and_get_id () if commitment is None and encoding is None and data_slice is None and filters is None : config = None else : encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] data_slice_to_use = ( None if data_slice is None else UiDataSliceConfig ( offset = data_slice . offset , length = data_slice . length ) ) account_config = RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use , data_slice = data_slice_to_use , ) filters_to_use : Optional [ List [ Union [ int , Memcmp ]]] = ( None if filters is None else [ x if isinstance ( x , int ) else Memcmp ( * x ) for x in filters ] ) config = RpcProgramAccountsConfig ( account_config , filters_to_use ) req = ProgramSubscribe ( program_id , config , req_id ) await self . send_data ( req ) program_unsubscribe ( self , subscription ) async Unsubscribe from program account notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def program_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from program account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = ProgramUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] recv ( self ) async Receive the next message. Basically .recv from websockets with extra parsing. Source code in solana/rpc/websocket_api.py async def recv ( # type: ignore self , ) -> List [ Union [ Notification , SubscriptionResult ]]: \"\"\"Receive the next message. Basically `.recv` from `websockets` with extra parsing. \"\"\" data = await super () . recv () return self . _process_rpc_response ( cast ( str , data )) root_subscribe ( self ) async Subscribe to receive notification anytime a new root is set by the validator. Source code in solana/rpc/websocket_api.py async def root_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new root is set by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = RootSubscribe ( req_id ) await self . send_data ( req ) root_unsubscribe ( self , subscription ) async Unsubscribe from root notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def root_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from root notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = RootUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] send_data ( self , message ) async Send a subscribe/unsubscribe request or list of requests. Basically .send from websockets with extra parsing. Parameters: Name Type Description Default message Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe, List[Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe]]] The request(s) to send. required Source code in solana/rpc/websocket_api.py async def send_data ( self , message : Union [ Body , List [ Body ]]) -> None : \"\"\"Send a subscribe/unsubscribe request or list of requests. Basically `.send` from `websockets` with extra parsing. Args: message: The request(s) to send. \"\"\" if isinstance ( message , list ): to_send = batch_to_json ( message ) for req in message : self . sent_subscriptions [ req . id ] = req else : to_send = message . to_json () self . sent_subscriptions [ message . id ] = message await super () . send ( to_send ) # type: ignore signature_subscribe ( self , signature , commitment = None ) async Subscribe to a transaction signature to receive notification when the transaction is confirmed. Parameters: Name Type Description Default signature Signature The transaction signature to subscribe to. required commitment Optional[Commitment] Commitment level. None Source code in solana/rpc/websocket_api.py async def signature_subscribe ( self , signature : Signature , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Args: signature: The transaction signature to subscribe to. commitment: Commitment level. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = None if commitment_to_use is None else RpcSignatureSubscribeConfig ( commitment = commitment_to_use ) req = SignatureSubscribe ( signature , config , req_id ) await self . send_data ( req ) signature_unsubscribe ( self , subscription ) async Unsubscribe from signature notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def signature_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from signature notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SignatureUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] slot_subscribe ( self ) async Subscribe to receive notification anytime a slot is processed by the validator. Source code in solana/rpc/websocket_api.py async def slot_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a slot is processed by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotSubscribe ( req_id ) await self . send_data ( req ) slot_unsubscribe ( self , subscription ) async Unsubscribe from slot notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def slot_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] slots_updates_subscribe ( self ) async Subscribe to receive a notification from the validator on a variety of updates on every slot. Source code in solana/rpc/websocket_api.py async def slots_updates_subscribe ( self ) -> None : \"\"\"Subscribe to receive a notification from the validator on a variety of updates on every slot.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesSubscribe ( req_id ) await self . send_data ( req ) slots_updates_unsubscribe ( self , subscription ) async Unsubscribe from slot update notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def slots_updates_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot update notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] vote_subscribe ( self ) async Subscribe to receive notification anytime a new vote is observed in gossip. Source code in solana/rpc/websocket_api.py async def vote_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new vote is observed in gossip.\"\"\" req_id = self . increment_counter_and_get_id () req = VoteSubscribe ( req_id ) await self . send_data ( req ) vote_unsubscribe ( self , subscription ) async Unsubscribe from vote notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def vote_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from vote notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = VoteUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] SubscriptionError Raise when subscribing to an RPC feed fails. Source code in solana/rpc/websocket_api.py class SubscriptionError ( Exception ): \"\"\"Raise when subscribing to an RPC feed fails.\"\"\" def __init__ ( self , err : SoldersSubscriptionError , subscription : Body ) -> None : \"\"\"Init. Args: err: The RPC error object. subscription: The subscription message that caused the error. \"\"\" self . type = err . error . __class__ self . msg : str = err . error . message # type: ignore # TODO: narrow this union type self . subscription = subscription super () . __init__ ( f \" { self . type . __name__ } : { self . msg } \\n Caused by subscription: { subscription } \" ) __init__ ( self , err , subscription ) special Init. Parameters: Name Type Description Default err SubscriptionError The RPC error object. required subscription Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe] The subscription message that caused the error. required Source code in solana/rpc/websocket_api.py def __init__ ( self , err : SoldersSubscriptionError , subscription : Body ) -> None : \"\"\"Init. Args: err: The RPC error object. subscription: The subscription message that caused the error. \"\"\" self . type = err . error . __class__ self . msg : str = err . error . message # type: ignore # TODO: narrow this union type self . subscription = subscription super () . __init__ ( f \" { self . type . __name__ } : { self . msg } \\n Caused by subscription: { subscription } \" ) connect Solana RPC websocket connector. Source code in solana/rpc/websocket_api.py class connect ( ws_connect ): # pylint: disable=invalid-name,too-few-public-methods \"\"\"Solana RPC websocket connector.\"\"\" def __init__ ( self , uri : str = \"ws://localhost:8900\" , ** kwargs : Any ) -> None : \"\"\"Init. Kwargs are passed to `websockets.connect`. Args: uri: The websocket endpoint. **kwargs: Keyword arguments for ``websockets.legacy.client.connect`` \"\"\" super () . __init__ ( uri , ** kwargs , create_protocol = SolanaWsClientProtocol ) __init__ ( self , uri = 'ws://localhost:8900' , ** kwargs ) special Init. Kwargs are passed to websockets.connect . Parameters: Name Type Description Default uri str The websocket endpoint. 'ws://localhost:8900' **kwargs Any Keyword arguments for websockets.legacy.client.connect {} Source code in solana/rpc/websocket_api.py def __init__ ( self , uri : str = \"ws://localhost:8900\" , ** kwargs : Any ) -> None : \"\"\"Init. Kwargs are passed to `websockets.connect`. Args: uri: The websocket endpoint. **kwargs: Keyword arguments for ``websockets.legacy.client.connect`` \"\"\" super () . __init__ ( uri , ** kwargs , create_protocol = SolanaWsClientProtocol )","title":"Websocket Client"},{"location":"rpc/websocket/#websocket-client","text":"","title":"Websocket Client"},{"location":"rpc/websocket/#solana.rpc.websocket_api","text":"This module contains code for interacting with the RPC Websocket endpoint.","title":"websocket_api"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol","text":"Subclass of websockets.WebSocketClientProtocol tailored for Solana RPC websockets. Source code in solana/rpc/websocket_api.py class SolanaWsClientProtocol ( WebSocketClientProtocol ): \"\"\"Subclass of `websockets.WebSocketClientProtocol` tailored for Solana RPC websockets.\"\"\" def __init__ ( self , * args , ** kwargs ): \"\"\"Init. Args and kwargs are passed to `websockets.WebSocketClientProtocol`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . subscriptions : Dict [ int , Body ] = {} self . sent_subscriptions : Dict [ int , Body ] = {} self . failed_subscriptions = {} self . request_counter = itertools . count () def increment_counter_and_get_id ( self ) -> int : \"\"\"Increment self.request_counter and return the latest id.\"\"\" return next ( self . request_counter ) + 1 async def send_data ( self , message : Union [ Body , List [ Body ]]) -> None : \"\"\"Send a subscribe/unsubscribe request or list of requests. Basically `.send` from `websockets` with extra parsing. Args: message: The request(s) to send. \"\"\" if isinstance ( message , list ): to_send = batch_to_json ( message ) for req in message : self . sent_subscriptions [ req . id ] = req else : to_send = message . to_json () self . sent_subscriptions [ message . id ] = message await super () . send ( to_send ) # type: ignore async def recv ( # type: ignore self , ) -> List [ Union [ Notification , SubscriptionResult ]]: \"\"\"Receive the next message. Basically `.recv` from `websockets` with extra parsing. \"\"\" data = await super () . recv () return self . _process_rpc_response ( cast ( str , data )) async def account_subscribe ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , ) -> None : \"\"\"Subscribe to an account to receive notifications when the lamports or data change. Args: pubkey: Account pubkey. commitment: Commitment level. encoding: Encoding to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] config = ( None if commitment_to_use is None and encoding_to_use is None else RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use ) ) req = AccountSubscribe ( pubkey , config , req_id ) await self . send_data ( req ) async def account_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = AccountUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def logs_subscribe ( self , filter_ : Union [ RpcTransactionLogsFilter , RpcTransactionLogsFilterMentions ] = RpcTransactionLogsFilter . All , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to transaction logging. Args: filter_: filter criteria for the logs. commitment: The commitment level to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = RpcTransactionLogsConfig ( commitment_to_use ) req = LogsSubscribe ( filter_ , config , req_id ) await self . send_data ( req ) async def logs_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from transaction logging. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = LogsUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def program_subscribe ( # pylint: disable=too-many-arguments self , program_id : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> None : \"\"\"Receive notifications when the lamports or data for a given account owned by the program changes. Args: program_id: The program ID. commitment: Commitment level to use. encoding: Encoding to use. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. \"\"\" # noqa: E501 # pylint: disable=line-too-long req_id = self . increment_counter_and_get_id () if commitment is None and encoding is None and data_slice is None and filters is None : config = None else : encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] data_slice_to_use = ( None if data_slice is None else UiDataSliceConfig ( offset = data_slice . offset , length = data_slice . length ) ) account_config = RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use , data_slice = data_slice_to_use , ) filters_to_use : Optional [ List [ Union [ int , Memcmp ]]] = ( None if filters is None else [ x if isinstance ( x , int ) else Memcmp ( * x ) for x in filters ] ) config = RpcProgramAccountsConfig ( account_config , filters_to_use ) req = ProgramSubscribe ( program_id , config , req_id ) await self . send_data ( req ) async def program_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from program account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = ProgramUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def signature_subscribe ( self , signature : Signature , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Args: signature: The transaction signature to subscribe to. commitment: Commitment level. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = None if commitment_to_use is None else RpcSignatureSubscribeConfig ( commitment = commitment_to_use ) req = SignatureSubscribe ( signature , config , req_id ) await self . send_data ( req ) async def signature_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from signature notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SignatureUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def slot_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a slot is processed by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotSubscribe ( req_id ) await self . send_data ( req ) async def slot_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def slots_updates_subscribe ( self ) -> None : \"\"\"Subscribe to receive a notification from the validator on a variety of updates on every slot.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesSubscribe ( req_id ) await self . send_data ( req ) async def slots_updates_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot update notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def root_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new root is set by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = RootSubscribe ( req_id ) await self . send_data ( req ) async def root_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from root notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = RootUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] async def vote_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new vote is observed in gossip.\"\"\" req_id = self . increment_counter_and_get_id () req = VoteSubscribe ( req_id ) await self . send_data ( req ) async def vote_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from vote notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = VoteUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ] def _process_rpc_response ( self , raw : str ) -> List [ Union [ Notification , SubscriptionResult ]]: parsed = parse_websocket_message ( raw ) for item in parsed : if isinstance ( item , SoldersSubscriptionError ): subscription = self . sent_subscriptions [ item . id ] self . failed_subscriptions [ item . id ] = subscription raise SubscriptionError ( item , subscription ) if isinstance ( item , SubscriptionResult ): self . subscriptions [ item . result ] = self . sent_subscriptions [ item . id ] return cast ( List [ Union [ Notification , SubscriptionResult ]], parsed )","title":"SolanaWsClientProtocol"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.__init__","text":"Init. Args and kwargs are passed to websockets.WebSocketClientProtocol . Source code in solana/rpc/websocket_api.py def __init__ ( self , * args , ** kwargs ): \"\"\"Init. Args and kwargs are passed to `websockets.WebSocketClientProtocol`.\"\"\" super () . __init__ ( * args , ** kwargs ) self . subscriptions : Dict [ int , Body ] = {} self . sent_subscriptions : Dict [ int , Body ] = {} self . failed_subscriptions = {} self . request_counter = itertools . count ()","title":"__init__()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.account_subscribe","text":"Subscribe to an account to receive notifications when the lamports or data change. Parameters: Name Type Description Default pubkey Pubkey Account pubkey. required commitment Optional[Commitment] Commitment level. None encoding Optional[str] Encoding to use. None Source code in solana/rpc/websocket_api.py async def account_subscribe ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , ) -> None : \"\"\"Subscribe to an account to receive notifications when the lamports or data change. Args: pubkey: Account pubkey. commitment: Commitment level. encoding: Encoding to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] config = ( None if commitment_to_use is None and encoding_to_use is None else RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use ) ) req = AccountSubscribe ( pubkey , config , req_id ) await self . send_data ( req )","title":"account_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.account_unsubscribe","text":"Unsubscribe from account notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def account_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = AccountUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"account_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.increment_counter_and_get_id","text":"Increment self.request_counter and return the latest id. Source code in solana/rpc/websocket_api.py def increment_counter_and_get_id ( self ) -> int : \"\"\"Increment self.request_counter and return the latest id.\"\"\" return next ( self . request_counter ) + 1","title":"increment_counter_and_get_id()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.logs_subscribe","text":"Subscribe to transaction logging. Parameters: Name Type Description Default filter_ Union[solders.rpc.config.RpcTransactionLogsFilter, solders.rpc.config.RpcTransactionLogsFilterMentions] filter criteria for the logs. RpcTransactionLogsFilter.All commitment Optional[Commitment] The commitment level to use. None Source code in solana/rpc/websocket_api.py async def logs_subscribe ( self , filter_ : Union [ RpcTransactionLogsFilter , RpcTransactionLogsFilterMentions ] = RpcTransactionLogsFilter . All , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to transaction logging. Args: filter_: filter criteria for the logs. commitment: The commitment level to use. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = RpcTransactionLogsConfig ( commitment_to_use ) req = LogsSubscribe ( filter_ , config , req_id ) await self . send_data ( req )","title":"logs_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.logs_unsubscribe","text":"Unsubscribe from transaction logging. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def logs_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from transaction logging. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = LogsUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"logs_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.program_subscribe","text":"Receive notifications when the lamports or data for a given account owned by the program changes. Parameters: Name Type Description Default program_id Pubkey The program ID. required commitment Optional[Commitment] Commitment level to use. None encoding Optional[str] Encoding to use. None data_slice Optional[solana.rpc.types.DataSliceOpts] (optional) Limit the returned account data using the provided offset : and None ` length` fields; only available for \"base58\" or \"base64\" encoding. required filters Optional[Sequence[Union[int, solana.rpc.types.MemcmpOpts]]] (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a dataSize filter. None Source code in solana/rpc/websocket_api.py async def program_subscribe ( # pylint: disable=too-many-arguments self , program_id : Pubkey , commitment : Optional [ Commitment ] = None , encoding : Optional [ str ] = None , data_slice : Optional [ types . DataSliceOpts ] = None , filters : Optional [ Sequence [ Union [ int , types . MemcmpOpts ]]] = None , ) -> None : \"\"\"Receive notifications when the lamports or data for a given account owned by the program changes. Args: program_id: The program ID. commitment: Commitment level to use. encoding: Encoding to use. data_slice: (optional) Limit the returned account data using the provided `offset`: <usize> and ` length`: <usize> fields; only available for \"base58\" or \"base64\" encoding. filters: (optional) Options to compare a provided series of bytes with program account data at a particular offset. Note: an int entry is converted to a `dataSize` filter. \"\"\" # noqa: E501 # pylint: disable=line-too-long req_id = self . increment_counter_and_get_id () if commitment is None and encoding is None and data_slice is None and filters is None : config = None else : encoding_to_use = None if encoding is None else _ACCOUNT_ENCODING_TO_SOLDERS [ encoding ] commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] data_slice_to_use = ( None if data_slice is None else UiDataSliceConfig ( offset = data_slice . offset , length = data_slice . length ) ) account_config = RpcAccountInfoConfig ( encoding = encoding_to_use , commitment = commitment_to_use , data_slice = data_slice_to_use , ) filters_to_use : Optional [ List [ Union [ int , Memcmp ]]] = ( None if filters is None else [ x if isinstance ( x , int ) else Memcmp ( * x ) for x in filters ] ) config = RpcProgramAccountsConfig ( account_config , filters_to_use ) req = ProgramSubscribe ( program_id , config , req_id ) await self . send_data ( req )","title":"program_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.program_unsubscribe","text":"Unsubscribe from program account notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def program_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from program account notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = ProgramUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"program_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.recv","text":"Receive the next message. Basically .recv from websockets with extra parsing. Source code in solana/rpc/websocket_api.py async def recv ( # type: ignore self , ) -> List [ Union [ Notification , SubscriptionResult ]]: \"\"\"Receive the next message. Basically `.recv` from `websockets` with extra parsing. \"\"\" data = await super () . recv () return self . _process_rpc_response ( cast ( str , data ))","title":"recv()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.root_subscribe","text":"Subscribe to receive notification anytime a new root is set by the validator. Source code in solana/rpc/websocket_api.py async def root_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new root is set by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = RootSubscribe ( req_id ) await self . send_data ( req )","title":"root_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.root_unsubscribe","text":"Unsubscribe from root notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def root_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from root notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = RootUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"root_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.send_data","text":"Send a subscribe/unsubscribe request or list of requests. Basically .send from websockets with extra parsing. Parameters: Name Type Description Default message Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe, List[Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe]]] The request(s) to send. required Source code in solana/rpc/websocket_api.py async def send_data ( self , message : Union [ Body , List [ Body ]]) -> None : \"\"\"Send a subscribe/unsubscribe request or list of requests. Basically `.send` from `websockets` with extra parsing. Args: message: The request(s) to send. \"\"\" if isinstance ( message , list ): to_send = batch_to_json ( message ) for req in message : self . sent_subscriptions [ req . id ] = req else : to_send = message . to_json () self . sent_subscriptions [ message . id ] = message await super () . send ( to_send ) # type: ignore","title":"send_data()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.signature_subscribe","text":"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Parameters: Name Type Description Default signature Signature The transaction signature to subscribe to. required commitment Optional[Commitment] Commitment level. None Source code in solana/rpc/websocket_api.py async def signature_subscribe ( self , signature : Signature , commitment : Optional [ Commitment ] = None , ) -> None : \"\"\"Subscribe to a transaction signature to receive notification when the transaction is confirmed. Args: signature: The transaction signature to subscribe to. commitment: Commitment level. \"\"\" req_id = self . increment_counter_and_get_id () commitment_to_use = None if commitment is None else _COMMITMENT_TO_SOLDERS [ commitment ] config = None if commitment_to_use is None else RpcSignatureSubscribeConfig ( commitment = commitment_to_use ) req = SignatureSubscribe ( signature , config , req_id ) await self . send_data ( req )","title":"signature_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.signature_unsubscribe","text":"Unsubscribe from signature notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def signature_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from signature notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SignatureUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"signature_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.slot_subscribe","text":"Subscribe to receive notification anytime a slot is processed by the validator. Source code in solana/rpc/websocket_api.py async def slot_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a slot is processed by the validator.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotSubscribe ( req_id ) await self . send_data ( req )","title":"slot_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.slot_unsubscribe","text":"Unsubscribe from slot notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def slot_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"slot_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.slots_updates_subscribe","text":"Subscribe to receive a notification from the validator on a variety of updates on every slot. Source code in solana/rpc/websocket_api.py async def slots_updates_subscribe ( self ) -> None : \"\"\"Subscribe to receive a notification from the validator on a variety of updates on every slot.\"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesSubscribe ( req_id ) await self . send_data ( req )","title":"slots_updates_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.slots_updates_unsubscribe","text":"Unsubscribe from slot update notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def slots_updates_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from slot update notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = SlotsUpdatesUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"slots_updates_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.vote_subscribe","text":"Subscribe to receive notification anytime a new vote is observed in gossip. Source code in solana/rpc/websocket_api.py async def vote_subscribe ( self ) -> None : \"\"\"Subscribe to receive notification anytime a new vote is observed in gossip.\"\"\" req_id = self . increment_counter_and_get_id () req = VoteSubscribe ( req_id ) await self . send_data ( req )","title":"vote_subscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SolanaWsClientProtocol.vote_unsubscribe","text":"Unsubscribe from vote notifications. Parameters: Name Type Description Default subscription int ID of subscription to cancel. required Source code in solana/rpc/websocket_api.py async def vote_unsubscribe ( self , subscription : int , ) -> None : \"\"\"Unsubscribe from vote notifications. Args: subscription: ID of subscription to cancel. \"\"\" req_id = self . increment_counter_and_get_id () req = VoteUnsubscribe ( subscription , req_id ) await self . send_data ( req ) del self . subscriptions [ subscription ]","title":"vote_unsubscribe()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SubscriptionError","text":"Raise when subscribing to an RPC feed fails. Source code in solana/rpc/websocket_api.py class SubscriptionError ( Exception ): \"\"\"Raise when subscribing to an RPC feed fails.\"\"\" def __init__ ( self , err : SoldersSubscriptionError , subscription : Body ) -> None : \"\"\"Init. Args: err: The RPC error object. subscription: The subscription message that caused the error. \"\"\" self . type = err . error . __class__ self . msg : str = err . error . message # type: ignore # TODO: narrow this union type self . subscription = subscription super () . __init__ ( f \" { self . type . __name__ } : { self . msg } \\n Caused by subscription: { subscription } \" )","title":"SubscriptionError"},{"location":"rpc/websocket/#solana.rpc.websocket_api.SubscriptionError.__init__","text":"Init. Parameters: Name Type Description Default err SubscriptionError The RPC error object. required subscription Union[solders.rpc.requests.GetAccountInfo, solders.rpc.requests.GetBalance, solders.rpc.requests.GetBlock, solders.rpc.requests.GetBlockHeight, solders.rpc.requests.GetBlockProduction, solders.rpc.requests.GetBlockCommitment, solders.rpc.requests.GetBlocks, solders.rpc.requests.GetBlocksWithLimit, solders.rpc.requests.GetBlockTime, solders.rpc.requests.GetClusterNodes, solders.rpc.requests.GetEpochInfo, solders.rpc.requests.GetEpochSchedule, solders.rpc.requests.GetFeeForMessage, solders.rpc.requests.GetFirstAvailableBlock, solders.rpc.requests.GetGenesisHash, solders.rpc.requests.GetHealth, solders.rpc.requests.GetHighestSnapshotSlot, solders.rpc.requests.GetIdentity, solders.rpc.requests.GetInflationGovernor, solders.rpc.requests.GetInflationRate, solders.rpc.requests.GetInflationReward, solders.rpc.requests.GetLargestAccounts, solders.rpc.requests.GetLatestBlockhash, solders.rpc.requests.GetLeaderSchedule, solders.rpc.requests.GetMaxRetransmitSlot, solders.rpc.requests.GetMaxShredInsertSlot, solders.rpc.requests.GetMinimumBalanceForRentExemption, solders.rpc.requests.GetMultipleAccounts, solders.rpc.requests.GetProgramAccounts, solders.rpc.requests.GetRecentPerformanceSamples, solders.rpc.requests.GetSignaturesForAddress, solders.rpc.requests.GetSignatureStatuses, solders.rpc.requests.GetSlot, solders.rpc.requests.GetSlotLeader, solders.rpc.requests.GetSlotLeaders, solders.rpc.requests.GetStakeActivation, solders.rpc.requests.GetSupply, solders.rpc.requests.GetTokenAccountBalance, solders.rpc.requests.GetTokenAccountsByDelegate, solders.rpc.requests.GetTokenAccountsByOwner, solders.rpc.requests.GetTokenLargestAccounts, solders.rpc.requests.GetTokenSupply, solders.rpc.requests.GetTransaction, solders.rpc.requests.GetTransactionCount, solders.rpc.requests.GetVersion, solders.rpc.requests.GetVoteAccounts, solders.rpc.requests.IsBlockhashValid, solders.rpc.requests.MinimumLedgerSlot, solders.rpc.requests.RequestAirdrop, solders.rpc.requests.SendRawTransaction, solders.rpc.requests.SendLegacyTransaction, solders.rpc.requests.ValidatorExit, solders.rpc.requests.AccountSubscribe, solders.rpc.requests.BlockSubscribe, solders.rpc.requests.LogsSubscribe, solders.rpc.requests.ProgramSubscribe, solders.rpc.requests.SignatureSubscribe, solders.rpc.requests.SlotSubscribe, solders.rpc.requests.SlotsUpdatesSubscribe, solders.rpc.requests.RootSubscribe, solders.rpc.requests.VoteSubscribe, solders.rpc.requests.AccountUnsubscribe, solders.rpc.requests.BlockUnsubscribe, solders.rpc.requests.LogsUnsubscribe, solders.rpc.requests.ProgramUnsubscribe, solders.rpc.requests.SignatureUnsubscribe, solders.rpc.requests.SimulateLegacyTransaction, solders.rpc.requests.SlotUnsubscribe, solders.rpc.requests.SlotsUpdatesUnsubscribe, solders.rpc.requests.RootUnsubscribe, solders.rpc.requests.VoteUnsubscribe] The subscription message that caused the error. required Source code in solana/rpc/websocket_api.py def __init__ ( self , err : SoldersSubscriptionError , subscription : Body ) -> None : \"\"\"Init. Args: err: The RPC error object. subscription: The subscription message that caused the error. \"\"\" self . type = err . error . __class__ self . msg : str = err . error . message # type: ignore # TODO: narrow this union type self . subscription = subscription super () . __init__ ( f \" { self . type . __name__ } : { self . msg } \\n Caused by subscription: { subscription } \" )","title":"__init__()"},{"location":"rpc/websocket/#solana.rpc.websocket_api.connect","text":"Solana RPC websocket connector. Source code in solana/rpc/websocket_api.py class connect ( ws_connect ): # pylint: disable=invalid-name,too-few-public-methods \"\"\"Solana RPC websocket connector.\"\"\" def __init__ ( self , uri : str = \"ws://localhost:8900\" , ** kwargs : Any ) -> None : \"\"\"Init. Kwargs are passed to `websockets.connect`. Args: uri: The websocket endpoint. **kwargs: Keyword arguments for ``websockets.legacy.client.connect`` \"\"\" super () . __init__ ( uri , ** kwargs , create_protocol = SolanaWsClientProtocol )","title":"connect"},{"location":"rpc/websocket/#solana.rpc.websocket_api.connect.__init__","text":"Init. Kwargs are passed to websockets.connect . Parameters: Name Type Description Default uri str The websocket endpoint. 'ws://localhost:8900' **kwargs Any Keyword arguments for websockets.legacy.client.connect {} Source code in solana/rpc/websocket_api.py def __init__ ( self , uri : str = \"ws://localhost:8900\" , ** kwargs : Any ) -> None : \"\"\"Init. Kwargs are passed to `websockets.connect`. Args: uri: The websocket endpoint. **kwargs: Keyword arguments for ``websockets.legacy.client.connect`` \"\"\" super () . __init__ ( uri , ** kwargs , create_protocol = SolanaWsClientProtocol )","title":"__init__()"},{"location":"spl/intro/","text":"Solana Program Library (SPL) The Solana Program Library (SPL) is a collection of on-chain programs targeting the Sealevel parallel runtime . These programs are tested against Solana's implementation of Sealevel, solana-runtime, and deployed to its mainnet. Note The Python SPL library is separate from the main Python Solana library, so you import it with import spl instead of import solana . You don't install it separately though: it gets installed when you run pip install solana .","title":"Solana Program Library (SPL)"},{"location":"spl/intro/#solana-program-library-spl","text":"The Solana Program Library (SPL) is a collection of on-chain programs targeting the Sealevel parallel runtime . These programs are tested against Solana's implementation of Sealevel, solana-runtime, and deployed to its mainnet. Note The Python SPL library is separate from the main Python Solana library, so you import it with import spl instead of import solana . You don't install it separately though: it gets installed when you run pip install solana .","title":"Solana Program Library (SPL)"},{"location":"spl/memo/constants/","text":"Constants spl.memo.constants Memo program constants. MEMO_PROGRAM_ID : Pubkey Public key that identifies the Memo program.","title":"Constants"},{"location":"spl/memo/constants/#constants","text":"","title":"Constants"},{"location":"spl/memo/constants/#spl.memo.constants","text":"Memo program constants.","title":"constants"},{"location":"spl/memo/constants/#spl.memo.constants.MEMO_PROGRAM_ID","text":"Public key that identifies the Memo program.","title":"MEMO_PROGRAM_ID"},{"location":"spl/memo/instructions/","text":"Memo Program spl.memo.instructions Memo program instructions. MemoParams Create memo transaction params. Source code in spl/memo/instructions.py class MemoParams ( NamedTuple ): \"\"\"Create memo transaction params.\"\"\" program_id : Pubkey \"\"\"Memo program account.\"\"\" signer : Pubkey \"\"\"Signing account.\"\"\" message : bytes \"\"\"Memo message in bytes.\"\"\" message : bytes Memo message in bytes. program_id : Pubkey Memo program account. signer : Pubkey Signing account. create_memo ( params ) Creates a transaction instruction that creates a memo. Message need to be encoded in bytes. Examples: >>> from solders.pubkey import Pubkey >>> leading_zeros = [ 0 ] * 31 >>> signer , memo_program = Pubkey ( leading_zeros + [ 1 ]), Pubkey ( leading_zeros + [ 2 ]) >>> message = bytes ( \"test\" , encoding = \"utf8\" ) >>> params = MemoParams ( ... program_id = memo_program , ... message = message , ... signer = signer ... ) >>> type ( create_memo ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to create a memo. Source code in spl/memo/instructions.py def create_memo ( params : MemoParams ) -> Instruction : \"\"\"Creates a transaction instruction that creates a memo. Message need to be encoded in bytes. Example: >>> from solders.pubkey import Pubkey >>> leading_zeros = [0] * 31 >>> signer, memo_program = Pubkey(leading_zeros + [1]), Pubkey(leading_zeros + [2]) >>> message = bytes(\"test\", encoding=\"utf8\") >>> params = MemoParams( ... program_id=memo_program, ... message=message, ... signer=signer ... ) >>> type(create_memo(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to create a memo. \"\"\" keys = [ AccountMeta ( pubkey = params . signer , is_signer = True , is_writable = True ), ] return Instruction ( accounts = keys , program_id = params . program_id , data = params . message , ) decode_create_memo ( instruction ) Decode a create_memo_instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description MemoParams The decoded instruction. Source code in spl/memo/instructions.py def decode_create_memo ( instruction : Instruction ) -> MemoParams : \"\"\"Decode a create_memo_instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" return MemoParams ( signer = instruction . accounts [ 0 ] . pubkey , message = instruction . data , program_id = instruction . program_id , )","title":"Memo Program"},{"location":"spl/memo/instructions/#memo-program","text":"","title":"Memo Program"},{"location":"spl/memo/instructions/#spl.memo.instructions","text":"Memo program instructions.","title":"instructions"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams","text":"Create memo transaction params. Source code in spl/memo/instructions.py class MemoParams ( NamedTuple ): \"\"\"Create memo transaction params.\"\"\" program_id : Pubkey \"\"\"Memo program account.\"\"\" signer : Pubkey \"\"\"Signing account.\"\"\" message : bytes \"\"\"Memo message in bytes.\"\"\"","title":"MemoParams"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams.message","text":"Memo message in bytes.","title":"message"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams.program_id","text":"Memo program account.","title":"program_id"},{"location":"spl/memo/instructions/#spl.memo.instructions.MemoParams.signer","text":"Signing account.","title":"signer"},{"location":"spl/memo/instructions/#spl.memo.instructions.create_memo","text":"Creates a transaction instruction that creates a memo. Message need to be encoded in bytes. Examples: >>> from solders.pubkey import Pubkey >>> leading_zeros = [ 0 ] * 31 >>> signer , memo_program = Pubkey ( leading_zeros + [ 1 ]), Pubkey ( leading_zeros + [ 2 ]) >>> message = bytes ( \"test\" , encoding = \"utf8\" ) >>> params = MemoParams ( ... program_id = memo_program , ... message = message , ... signer = signer ... ) >>> type ( create_memo ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to create a memo. Source code in spl/memo/instructions.py def create_memo ( params : MemoParams ) -> Instruction : \"\"\"Creates a transaction instruction that creates a memo. Message need to be encoded in bytes. Example: >>> from solders.pubkey import Pubkey >>> leading_zeros = [0] * 31 >>> signer, memo_program = Pubkey(leading_zeros + [1]), Pubkey(leading_zeros + [2]) >>> message = bytes(\"test\", encoding=\"utf8\") >>> params = MemoParams( ... program_id=memo_program, ... message=message, ... signer=signer ... ) >>> type(create_memo(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to create a memo. \"\"\" keys = [ AccountMeta ( pubkey = params . signer , is_signer = True , is_writable = True ), ] return Instruction ( accounts = keys , program_id = params . program_id , data = params . message , )","title":"create_memo()"},{"location":"spl/memo/instructions/#spl.memo.instructions.decode_create_memo","text":"Decode a create_memo_instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description MemoParams The decoded instruction. Source code in spl/memo/instructions.py def decode_create_memo ( instruction : Instruction ) -> MemoParams : \"\"\"Decode a create_memo_instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" return MemoParams ( signer = instruction . accounts [ 0 ] . pubkey , message = instruction . data , program_id = instruction . program_id , )","title":"decode_create_memo()"},{"location":"spl/memo/intro/","text":"Intro The Memo program is a simple program that validates a string of UTF-8 encoded characters and verifies that any accounts provided are signers of the transaction. The program also logs the memo, as well as any verified signer addresses, to the transaction log, so that anyone can easily observe memos and know they were approved by zero or more addresses by inspecting the transaction log from a trusted provider. Background Solana's programming model and the definitions of the Solana terms used in this document are available at: https://docs.solana.com/apps https://docs.solana.com/terminology Source The Memo Program's source is available on github Interface The on-chain Memo Program is written in Rust and available on crates.io as spl-memo and docs.rs . The crate provides a build_memo() method to easily create a properly constructed Instruction. Operational Notes If zero accounts are provided to the signed-memo instruction, the program succeeds when the memo is valid UTF-8, and logs the memo to the transaction log. If one or more accounts are provided to the signed-memo instruction, all must be valid signers of the transaction for the instruction to succeed. Logs This section details expected log output for memo instructions. Logging begins with entry into the program: Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr invoke [1] The program will include a separate log for each verified signer: Program log: Signed by <BASE_58_ADDRESS> Then the program logs the memo length and UTF-8 text: Program log: Memo (len 4): \"\ud83d\udc06\" If UTF-8 parsing fails, the program will log the failure point: Program log: Invalid UTF-8, from byte 4 Logging ends with the status of the instruction, one of: Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr success Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr failed: missing required signature for instruction Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr failed: invalid instruction data For more information about exposing program logs on a node, head to the developer docs Compute Limits Like all programs, the Memo Program is subject to the cluster's compute budget . In Memo, compute is used for parsing UTF-8, verifying signers, and logging, limiting the memo length and number of signers that can be processed successfully in a single instruction. The longer or more complex the UTF-8 memo, the fewer signers can be supported, and vice versa. As of v1.5.1, an unsigned instruction can support single-byte UTF-8 of up to 566 bytes. An instruction with a simple memo of 32 bytes can support up to 12 signers.","title":"Intro"},{"location":"spl/memo/intro/#intro","text":"The Memo program is a simple program that validates a string of UTF-8 encoded characters and verifies that any accounts provided are signers of the transaction. The program also logs the memo, as well as any verified signer addresses, to the transaction log, so that anyone can easily observe memos and know they were approved by zero or more addresses by inspecting the transaction log from a trusted provider.","title":"Intro"},{"location":"spl/memo/intro/#background","text":"Solana's programming model and the definitions of the Solana terms used in this document are available at: https://docs.solana.com/apps https://docs.solana.com/terminology","title":"Background"},{"location":"spl/memo/intro/#source","text":"The Memo Program's source is available on github","title":"Source"},{"location":"spl/memo/intro/#interface","text":"The on-chain Memo Program is written in Rust and available on crates.io as spl-memo and docs.rs . The crate provides a build_memo() method to easily create a properly constructed Instruction.","title":"Interface"},{"location":"spl/memo/intro/#operational-notes","text":"If zero accounts are provided to the signed-memo instruction, the program succeeds when the memo is valid UTF-8, and logs the memo to the transaction log. If one or more accounts are provided to the signed-memo instruction, all must be valid signers of the transaction for the instruction to succeed.","title":"Operational Notes"},{"location":"spl/memo/intro/#logs","text":"This section details expected log output for memo instructions. Logging begins with entry into the program: Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr invoke [1] The program will include a separate log for each verified signer: Program log: Signed by <BASE_58_ADDRESS> Then the program logs the memo length and UTF-8 text: Program log: Memo (len 4): \"\ud83d\udc06\" If UTF-8 parsing fails, the program will log the failure point: Program log: Invalid UTF-8, from byte 4 Logging ends with the status of the instruction, one of: Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr success Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr failed: missing required signature for instruction Program MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr failed: invalid instruction data For more information about exposing program logs on a node, head to the developer docs","title":"Logs"},{"location":"spl/memo/intro/#compute-limits","text":"Like all programs, the Memo Program is subject to the cluster's compute budget . In Memo, compute is used for parsing UTF-8, verifying signers, and logging, limiting the memo length and number of signers that can be processed successfully in a single instruction. The longer or more complex the UTF-8 memo, the fewer signers can be supported, and vice versa. As of v1.5.1, an unsigned instruction can support single-byte UTF-8 of up to 566 bytes. An instruction with a simple memo of 32 bytes can support up to 12 signers.","title":"Compute Limits"},{"location":"spl/token/async_client/","text":"Async Client spl.token.async_client Async SPL Token program client. AsyncToken An ERC20-like Token. Source code in spl/token/async_client.py class AsyncToken ( _TokenCore ): # pylint: disable=too-many-public-methods \"\"\"An ERC20-like Token.\"\"\" def __init__ ( self , conn : AsyncClient , pubkey : Pubkey , program_id : Pubkey , payer : Keypair ) -> None : \"\"\"Initialize a client to a SPL-Token program.\"\"\" super () . __init__ ( pubkey , program_id , payer ) self . _conn = conn @staticmethod async def get_min_balance_rent_for_exempt_for_account ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value @staticmethod async def get_min_balance_rent_for_exempt_for_mint ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value @staticmethod async def get_min_balance_rent_for_exempt_for_multisig ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value async def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner ( * args ) async def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner_json_parsed ( * args ) async def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate ( * args ) async def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate_json_parsed ( * args ) async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return await self . _conn . get_token_account_balance ( pubkey , commitment ) @classmethod async def create_mint ( cls , conn : AsyncClient , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> AsyncToken : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions await conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( AsyncToken , token ) async def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions await self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk async def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) await self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key @staticmethod async def create_wrapped_native_account ( conn : AsyncClient , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( conn ) ( new_account_public_key , txn , payer , new_account , opts ,) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , ) await conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key async def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts await self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . pubkey () async def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = await self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) async def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = await self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) async def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def close_account ( self , account : Pubkey , dest : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def freeze_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def mint_to_checked ( self , dest : Pubkey , mint_authority : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def burn_checked ( self , account : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) approve ( self , source , delegate , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) async Grant a third-party permission to transfer up the specified number of tokens from an account. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) approve_checked ( self , source , delegate , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) async Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required decimals int Number of decimals in approve amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash optional A prefetched blockhash for the transaction. None Source code in spl/token/async_client.py async def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) burn ( self , account , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) async Burn tokens. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Pubkey Owner of the account. required amount int Amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) burn_checked ( self , account , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) async Burn tokens, asserting the token mint and decimals. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Pubkey Owner of the account. required amount int Amount to burn. required decimals int Number of decimals in amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def burn_checked ( self , account : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) close_account ( self , account , dest , authority , multi_signers = None , opts = None , recent_blockhash = None ) async Remove approval for the transfer of any remaining tokens. Parameters: Name Type Description Default account Pubkey Account to close. required dest Pubkey Account to receive the remaining balance of the closed account. required authority Pubkey Authority which is allowed to close the account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def close_account ( self , account : Pubkey , dest : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) create_account ( self , owner , skip_confirmation = False , recent_blockhash = None ) async Create and initialize a new account. This account may then be used as a transfer() or approve() destination. Parameters: Name Type Description Default owner Pubkey User account that will own the new account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash optional A prefetched blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new empty account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions await self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk create_associated_token_account ( self , owner , skip_confirmation = False , recent_blockhash = None ) async Create an associated token account. Parameters: Name Type Description Default owner Pubkey User account that will own the associated token account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash optional A prefetched blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new associated account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) await self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key create_mint ( conn , payer , mint_authority , decimals , program_id , freeze_authority = None , skip_confirmation = False , recent_blockhash = None ) async classmethod Create and initialize a token. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required payer Keypair Fee payer for transaction. required mint_authority Pubkey Account or multisig that will control minting. required decimals int Location of the decimal place. required program_id Pubkey SPL Token program account. required freeze_authority Optional[Pubkey] (optional) Account or multisig that can freeze token accounts. None skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description AsyncToken Token object for the newly minted token. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py @classmethod async def create_mint ( cls , conn : AsyncClient , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> AsyncToken : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions await conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( AsyncToken , token ) create_multisig ( self , m , multi_signers , opts = None , recent_blockhash = None ) async Create and initialize a new multisig. Parameters: Name Type Description Default m int Number of required signatures. required multi_signers List[Pubkey] Full set of signers. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new multisig account. Source code in spl/token/async_client.py async def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts await self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . pubkey () create_wrapped_native_account ( conn , program_id , owner , payer , amount , skip_confirmation = False , recent_blockhash = None ) async staticmethod Create and initialize a new account on the special native token mint. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required program_id Pubkey SPL Token program account. required owner Pubkey The owner of the new token account. required payer Keypair The source of the lamports to initialize, and payer of the initialization fees. required amount int The amount of lamports to wrap. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey The new token account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py @staticmethod async def create_wrapped_native_account ( conn : AsyncClient , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( conn ) ( new_account_public_key , txn , payer , new_account , opts ,) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , ) await conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key freeze_account ( self , account , authority , multi_signers = None , opts = None , recent_blockhash = None ) async Freeze account. Parameters: Name Type Description Default account Pubkey Account to freeze. required authority Pubkey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def freeze_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) get_account_info ( self , account , commitment = None ) async Retrieve account information. Source code in spl/token/async_client.py async def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = await self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) get_accounts_by_delegate ( self , owner , commitment = None , encoding = 'base64' ) async Get token accounts of the provided delegate. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/async_client.py async def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate ( * args ) get_accounts_by_delegate_json_parsed ( self , owner , commitment = None , encoding = 'base64' ) async Get token accounts of the provided delegate, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/async_client.py async def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate_json_parsed ( * args ) get_accounts_by_owner ( self , owner , commitment = None , encoding = 'base64' ) async Get token accounts of the provided owner. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/async_client.py async def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner ( * args ) get_accounts_by_owner_json_parsed ( self , owner , commitment = None ) async Get token accounts of the provided owner by the token's mint, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/async_client.py async def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner_json_parsed ( * args ) get_balance ( self , pubkey , commitment = None ) async Get the balance of the provided token account. Parameters: Name Type Description Default pubkey Pubkey Public Key of the token account. required commitment Optional[Commitment] (optional) Bank state to query. None Source code in spl/token/async_client.py async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return await self . _conn . get_token_account_balance ( pubkey , commitment ) get_min_balance_rent_for_exempt_for_account ( conn ) async staticmethod Get the minimum balance for the account to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_account ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value get_min_balance_rent_for_exempt_for_mint ( conn ) async staticmethod Get the minimum balance for the mint to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_mint ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value get_min_balance_rent_for_exempt_for_multisig ( conn ) async staticmethod Get the minimum balance for the multisig to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_multisig ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value get_mint_info ( self ) async Retrieve mint information. Source code in spl/token/async_client.py async def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = await self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) mint_to ( self , dest , mint_authority , amount , multi_signers = None , opts = None , recent_blockhash = None ) async Mint new tokens. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Union[Keypair, Pubkey] Public key of the minting authority. required amount int Amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) mint_to_checked ( self , dest , mint_authority , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) async Mint new tokens, asserting the token mint and decimals. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Pubkey Public key of the minting authority. required amount int Amount to mint. required decimals int Number of decimals in amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash optional A prefetched blockhash for the transaction. None Source code in spl/token/async_client.py async def mint_to_checked ( self , dest : Pubkey , mint_authority : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) revoke ( self , account , owner , multi_signers = None , opts = None , recent_blockhash = None ) async Revoke transfer authority for a given account. Parameters: Name Type Description Default account Pubkey Source account for which transfer authority is being revoked. required owner Pubkey Owner of the source account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) set_authority ( self , account , current_authority , authority_type , new_authority = None , multi_signers = None , opts = None , recent_blockhash = None ) async Assign a new authority to the account. Parameters: Name Type Description Default account Pubkey Public key of the token account. required current_authority Union[Keypair, Pubkey] Current authority of the account. required authority_type spl_token.AuthorityType Type of authority to set. required new_authority Optional[Pubkey] (optional) New authority of the account. None multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) thaw_account ( self , account , authority , multi_signers = None , opts = None , recent_blockhash = None ) async Thaw account. Parameters: Name Type Description Default account Pubkey Account to thaw. required authority Pubkey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) transfer ( self , source , dest , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) async Transfer tokens to another account. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Union[Keypair, Pubkey] Owner of the source account. required amount int Number of tokens to transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) transfer_checked ( self , source , dest , owner , amount , decimals , multi_signers , opts = None , recent_blockhash = None ) async Transfer tokens to another account, asserting the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Pubkey Owner of the source account. required amount int Number of tokens to transfer. required decimals int Number of decimals in transfer amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"Async Client"},{"location":"spl/token/async_client/#async-client","text":"","title":"Async Client"},{"location":"spl/token/async_client/#spl.token.async_client","text":"Async SPL Token program client.","title":"async_client"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken","text":"An ERC20-like Token. Source code in spl/token/async_client.py class AsyncToken ( _TokenCore ): # pylint: disable=too-many-public-methods \"\"\"An ERC20-like Token.\"\"\" def __init__ ( self , conn : AsyncClient , pubkey : Pubkey , program_id : Pubkey , payer : Keypair ) -> None : \"\"\"Initialize a client to a SPL-Token program.\"\"\" super () . __init__ ( pubkey , program_id , payer ) self . _conn = conn @staticmethod async def get_min_balance_rent_for_exempt_for_account ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value @staticmethod async def get_min_balance_rent_for_exempt_for_mint ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value @staticmethod async def get_min_balance_rent_for_exempt_for_multisig ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value async def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner ( * args ) async def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner_json_parsed ( * args ) async def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate ( * args ) async def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate_json_parsed ( * args ) async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return await self . _conn . get_token_account_balance ( pubkey , commitment ) @classmethod async def create_mint ( cls , conn : AsyncClient , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> AsyncToken : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions await conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( AsyncToken , token ) async def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions await self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk async def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) await self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key @staticmethod async def create_wrapped_native_account ( conn : AsyncClient , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( conn ) ( new_account_public_key , txn , payer , new_account , opts ,) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , ) await conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key async def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts await self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . pubkey () async def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = await self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) async def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = await self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) async def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def close_account ( self , account : Pubkey , dest : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def freeze_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def mint_to_checked ( self , dest : Pubkey , mint_authority : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) async def burn_checked ( self , account : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"AsyncToken"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.approve","text":"Grant a third-party permission to transfer up the specified number of tokens from an account. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"approve()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.approve_checked","text":"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required decimals int Number of decimals in approve amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash optional A prefetched blockhash for the transaction. None Source code in spl/token/async_client.py async def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"approve_checked()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.burn","text":"Burn tokens. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Pubkey Owner of the account. required amount int Amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"burn()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.burn_checked","text":"Burn tokens, asserting the token mint and decimals. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Pubkey Owner of the account. required amount int Amount to burn. required decimals int Number of decimals in amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def burn_checked ( self , account : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"burn_checked()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.close_account","text":"Remove approval for the transfer of any remaining tokens. Parameters: Name Type Description Default account Pubkey Account to close. required dest Pubkey Account to receive the remaining balance of the closed account. required authority Pubkey Authority which is allowed to close the account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def close_account ( self , account : Pubkey , dest : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"close_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_account","text":"Create and initialize a new account. This account may then be used as a transfer() or approve() destination. Parameters: Name Type Description Default owner Pubkey User account that will own the new account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash optional A prefetched blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new empty account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions await self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk","title":"create_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_associated_token_account","text":"Create an associated token account. Parameters: Name Type Description Default owner Pubkey User account that will own the associated token account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash optional A prefetched blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new associated account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash (optional): A prefetched blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) await self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key","title":"create_associated_token_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_mint","text":"Create and initialize a token. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required payer Keypair Fee payer for transaction. required mint_authority Pubkey Account or multisig that will control minting. required decimals int Location of the decimal place. required program_id Pubkey SPL Token program account. required freeze_authority Optional[Pubkey] (optional) Account or multisig that can freeze token accounts. None skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description AsyncToken Token object for the newly minted token. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py @classmethod async def create_mint ( cls , conn : AsyncClient , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> AsyncToken : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions await conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( AsyncToken , token )","title":"create_mint()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_multisig","text":"Create and initialize a new multisig. Parameters: Name Type Description Default m int Number of required signatures. required multi_signers List[Pubkey] Full set of signers. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new multisig account. Source code in spl/token/async_client.py async def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts await self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . pubkey ()","title":"create_multisig()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.create_wrapped_native_account","text":"Create and initialize a new account on the special native token mint. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required program_id Pubkey SPL Token program account. required owner Pubkey The owner of the new token account. required payer Keypair The source of the lamports to initialize, and payer of the initialization fees. required amount int The amount of lamports to wrap. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey The new token account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py @staticmethod async def create_wrapped_native_account ( conn : AsyncClient , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = await AsyncToken . get_min_balance_rent_for_exempt_for_account ( conn ) ( new_account_public_key , txn , payer , new_account , opts ,) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , ) await conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key","title":"create_wrapped_native_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.freeze_account","text":"Freeze account. Parameters: Name Type Description Default account Pubkey Account to freeze. required authority Pubkey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def freeze_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"freeze_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_account_info","text":"Retrieve account information. Source code in spl/token/async_client.py async def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = await self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info )","title":"get_account_info()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_accounts_by_delegate","text":"Get token accounts of the provided delegate. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/async_client.py async def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate ( * args )","title":"get_accounts_by_delegate()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_accounts_by_delegate_json_parsed","text":"Get token accounts of the provided delegate, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/async_client.py async def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_delegate_json_parsed ( * args )","title":"get_accounts_by_delegate_json_parsed()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_accounts_by_owner","text":"Get token accounts of the provided owner. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/async_client.py async def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner ( * args )","title":"get_accounts_by_owner()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_accounts_by_owner_json_parsed","text":"Get token accounts of the provided owner by the token's mint, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/async_client.py async def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return await self . _conn . get_token_accounts_by_owner_json_parsed ( * args )","title":"get_accounts_by_owner_json_parsed()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_balance","text":"Get the balance of the provided token account. Parameters: Name Type Description Default pubkey Pubkey Public Key of the token account. required commitment Optional[Commitment] (optional) Bank state to query. None Source code in spl/token/async_client.py async def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return await self . _conn . get_token_account_balance ( pubkey , commitment )","title":"get_balance()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_min_balance_rent_for_exempt_for_account","text":"Get the minimum balance for the account to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_account ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value","title":"get_min_balance_rent_for_exempt_for_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_min_balance_rent_for_exempt_for_mint","text":"Get the minimum balance for the mint to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_mint ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value","title":"get_min_balance_rent_for_exempt_for_mint()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_min_balance_rent_for_exempt_for_multisig","text":"Get the minimum balance for the multisig to be rent exempt. Parameters: Name Type Description Default conn AsyncClient RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/async_client.py @staticmethod async def get_min_balance_rent_for_exempt_for_multisig ( conn : AsyncClient ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = await conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value","title":"get_min_balance_rent_for_exempt_for_multisig()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.get_mint_info","text":"Retrieve mint information. Source code in spl/token/async_client.py async def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = await self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info )","title":"get_mint_info()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.mint_to","text":"Mint new tokens. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Union[Keypair, Pubkey] Public key of the minting authority. required amount int Amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/async_client.py async def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"mint_to()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.mint_to_checked","text":"Mint new tokens, asserting the token mint and decimals. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Pubkey Public key of the minting authority. required amount int Amount to mint. required decimals int Number of decimals in amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash optional A prefetched blockhash for the transaction. None Source code in spl/token/async_client.py async def mint_to_checked ( self , dest : Pubkey , mint_authority : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash (optional): A prefetched blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"mint_to_checked()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.revoke","text":"Revoke transfer authority for a given account. Parameters: Name Type Description Default account Pubkey Source account for which transfer authority is being revoked. required owner Pubkey Owner of the source account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multisig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multisig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"revoke()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.set_authority","text":"Assign a new authority to the account. Parameters: Name Type Description Default account Pubkey Public key of the token account. required current_authority Union[Keypair, Pubkey] Current authority of the account. required authority_type spl_token.AuthorityType Type of authority to set. required new_authority Optional[Pubkey] (optional) New authority of the account. None multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , ) return await self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"set_authority()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.thaw_account","text":"Thaw account. Parameters: Name Type Description Default account Pubkey Account to thaw. required authority Pubkey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"thaw_account()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.transfer","text":"Transfer tokens to another account. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Union[Keypair, Pubkey] Owner of the source account. required amount int Number of tokens to transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"transfer()"},{"location":"spl/token/async_client/#spl.token.async_client.AsyncToken.transfer_checked","text":"Transfer tokens to another account, asserting the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Pubkey Owner of the source account. required amount int Number of tokens to transfer. required decimals int Number of decimals in transfer amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/async_client.py async def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return await self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"transfer_checked()"},{"location":"spl/token/client/","text":"Client spl.token.client SPL Token program client. Token An ERC20-like Token. Source code in spl/token/client.py class Token ( _TokenCore ): # pylint: disable=too-many-public-methods \"\"\"An ERC20-like Token.\"\"\" def __init__ ( self , conn : Client , pubkey : Pubkey , program_id : Pubkey , payer : Keypair ) -> None : \"\"\"Initialize a client to a SPL-Token program.\"\"\" super () . __init__ ( pubkey , program_id , payer ) self . _conn = conn @staticmethod def get_min_balance_rent_for_exempt_for_account ( conn : Client ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value @staticmethod def get_min_balance_rent_for_exempt_for_mint ( conn : Client ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value @staticmethod def get_min_balance_rent_for_exempt_for_multisig ( conn : Client ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Return: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner ( * args ) def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner_json_parsed ( * args ) def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate ( * args ) def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate_json_parsed ( * args ) def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return self . _conn . get_token_account_balance ( pubkey , commitment ) @classmethod def create_mint ( cls , conn : Client , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Token : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( Token , token ) def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key @staticmethod def create_wrapped_native_account ( conn : Client , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( conn ) ( new_account_public_key , txn , payer , new_account , opts ,) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , ) conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . pubkey () def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def close_account ( self , account : Pubkey , dest : Pubkey , authority : Union [ Keypair , Pubkey ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def freeze_account ( self , account : Pubkey , authority : Union [ Pubkey , Keypair ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def mint_to_checked ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def burn_checked ( self , account : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) approve ( self , source , delegate , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) Grant a third-party permission to transfer up the specified number of tokens from an account. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) approve_checked ( self , source , delegate , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required decimals int Number of decimals in approve amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) burn ( self , account , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) Burn tokens. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Pubkey Owner of the account. required amount int Amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) burn_checked ( self , account , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) Burn tokens, asserting the token mint and decimals. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Union[Keypair, Pubkey] Owner of the account. required amount int Amount to burn. required decimals int Number of decimals in amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def burn_checked ( self , account : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) close_account ( self , account , dest , authority , multi_signers = None , opts = None , recent_blockhash = None ) Remove approval for the transfer of any remaining tokens. Parameters: Name Type Description Default account Pubkey Account to close. required dest Pubkey Account to receive the remaining balance of the closed account. required authority Union[Keypair, Pubkey] Authority which is allowed to close the account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def close_account ( self , account : Pubkey , dest : Pubkey , authority : Union [ Keypair , Pubkey ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) create_account ( self , owner , skip_confirmation = False , recent_blockhash = None ) Create and initialize a new account. This account may then be used as a transfer() or approve() destination. Parameters: Name Type Description Default owner Pubkey User account that will own the new account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new empty account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk create_associated_token_account ( self , owner , skip_confirmation = False , recent_blockhash = None ) Create an associated token account. Parameters: Name Type Description Default owner Pubkey User account that will own the associated token account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new associated account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key create_mint ( conn , payer , mint_authority , decimals , program_id , freeze_authority = None , skip_confirmation = False , recent_blockhash = None ) classmethod Create and initialize a token. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required payer Keypair Fee payer for transaction. required mint_authority Pubkey Account or multisig that will control minting. required decimals int Location of the decimal place. required program_id Pubkey SPL Token program account. required freeze_authority Optional[Pubkey] (optional) Account or multisig that can freeze token accounts. None skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Token Token object for the newly minted token. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py @classmethod def create_mint ( cls , conn : Client , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Token : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( Token , token ) create_multisig ( self , m , multi_signers , opts = None , recent_blockhash = None ) Create and initialize a new multisig. Parameters: Name Type Description Default m int Number of required signatures. required multi_signers List[Pubkey] Full set of signers. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new multisig account. Source code in spl/token/client.py def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . pubkey () create_wrapped_native_account ( conn , program_id , owner , payer , amount , skip_confirmation = False , recent_blockhash = None ) staticmethod Create and initialize a new account on the special native token mint. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required program_id Pubkey SPL Token program account. required owner Pubkey The owner of the new token account. required payer Keypair The source of the lamports to initialize, and payer of the initialization fees. required amount int The amount of lamports to wrap. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey The new token account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py @staticmethod def create_wrapped_native_account ( conn : Client , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( conn ) ( new_account_public_key , txn , payer , new_account , opts ,) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , ) conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key freeze_account ( self , account , authority , multi_signers = None , opts = None , recent_blockhash = None ) Freeze account. Parameters: Name Type Description Default account Pubkey Account to freeze. required authority Union[Pubkey, Keypair] The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def freeze_account ( self , account : Pubkey , authority : Union [ Pubkey , Keypair ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) get_account_info ( self , account , commitment = None ) Retrieve account information. Source code in spl/token/client.py def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) get_accounts_by_delegate ( self , owner , commitment = None , encoding = 'base64' ) Get token accounts of the provided delegate. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/client.py def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate ( * args ) get_accounts_by_delegate_json_parsed ( self , owner , commitment = None , encoding = 'base64' ) Get token accounts of the provided delegate, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/client.py def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate_json_parsed ( * args ) get_accounts_by_owner ( self , owner , commitment = None , encoding = 'base64' ) Get token accounts of the provided owner. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/client.py def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner ( * args ) get_accounts_by_owner_json_parsed ( self , owner , commitment = None ) Get token accounts of the provided owner by the token's mint, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/client.py def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner_json_parsed ( * args ) get_balance ( self , pubkey , commitment = None ) Get the balance of the provided token account. Parameters: Name Type Description Default pubkey Pubkey Public Key of the token account. required commitment Optional[Commitment] (optional) Bank state to query. None Source code in spl/token/client.py def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return self . _conn . get_token_account_balance ( pubkey , commitment ) get_min_balance_rent_for_exempt_for_account ( conn ) staticmethod Get the minimum balance for the account to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_account ( conn : Client ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value get_min_balance_rent_for_exempt_for_mint ( conn ) staticmethod Get the minimum balance for the mint to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_mint ( conn : Client ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value get_min_balance_rent_for_exempt_for_multisig ( conn ) staticmethod Get the minimum balance for the multisig to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_multisig ( conn : Client ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Return: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value get_mint_info ( self ) Retrieve mint information. Source code in spl/token/client.py def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) mint_to ( self , dest , mint_authority , amount , multi_signers = None , opts = None , recent_blockhash = None ) Mint new tokens. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Union[Keypair, Pubkey] Public key of the minting authority. required amount int Amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) mint_to_checked ( self , dest , mint_authority , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) Mint new tokens, asserting the token mint and decimals. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Union[Keypair, Pubkey] Public key of the minting authority. required amount int Amount to mint. required decimals int Number of decimals in amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def mint_to_checked ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) revoke ( self , account , owner , multi_signers = None , opts = None , recent_blockhash = None ) Revoke transfer authority for a given account. Parameters: Name Type Description Default account Pubkey Source account for which transfer authority is being revoked. required owner Pubkey Owner of the source account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) set_authority ( self , account , current_authority , authority_type , new_authority = None , multi_signers = None , opts = None , recent_blockhash = None ) Assign a new authority to the account. Parameters: Name Type Description Default account Pubkey Public key of the token account. required current_authority Union[Keypair, Pubkey] Current authority of the account. required authority_type spl_token.AuthorityType Type of authority to set. required new_authority Optional[Pubkey] (optional) New authority of the account. None multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) thaw_account ( self , account , authority , multi_signers = None , opts = None , recent_blockhash = None ) Thaw account. Parameters: Name Type Description Default account Pubkey Account to thaw. required authority Pubkey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) transfer ( self , source , dest , owner , amount , multi_signers = None , opts = None , recent_blockhash = None ) Transfer tokens to another account. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Union[Keypair, Pubkey] Owner of the source account. required amount int Number of tokens to transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) transfer_checked ( self , source , dest , owner , amount , decimals , multi_signers = None , opts = None , recent_blockhash = None ) Transfer tokens to another account, asserting the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Union[Keypair, Pubkey] Owner of the source account. required amount int Number of tokens to transfer. required decimals int Number of decimals in transfer amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"Client"},{"location":"spl/token/client/#client","text":"","title":"Client"},{"location":"spl/token/client/#spl.token.client","text":"SPL Token program client.","title":"client"},{"location":"spl/token/client/#spl.token.client.Token","text":"An ERC20-like Token. Source code in spl/token/client.py class Token ( _TokenCore ): # pylint: disable=too-many-public-methods \"\"\"An ERC20-like Token.\"\"\" def __init__ ( self , conn : Client , pubkey : Pubkey , program_id : Pubkey , payer : Keypair ) -> None : \"\"\"Initialize a client to a SPL-Token program.\"\"\" super () . __init__ ( pubkey , program_id , payer ) self . _conn = conn @staticmethod def get_min_balance_rent_for_exempt_for_account ( conn : Client ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value @staticmethod def get_min_balance_rent_for_exempt_for_mint ( conn : Client ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value @staticmethod def get_min_balance_rent_for_exempt_for_multisig ( conn : Client ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Return: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner ( * args ) def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner_json_parsed ( * args ) def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate ( * args ) def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate_json_parsed ( * args ) def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return self . _conn . get_token_account_balance ( pubkey , commitment ) @classmethod def create_mint ( cls , conn : Client , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Token : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( Token , token ) def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key @staticmethod def create_wrapped_native_account ( conn : Client , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( conn ) ( new_account_public_key , txn , payer , new_account , opts ,) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , ) conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . pubkey () def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info ) def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info ) def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def close_account ( self , account : Pubkey , dest : Pubkey , authority : Union [ Keypair , Pubkey ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def freeze_account ( self , account : Pubkey , authority : Union [ Pubkey , Keypair ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash ) def mint_to_checked ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash ) def burn_checked ( self , account : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"Token"},{"location":"spl/token/client/#spl.token.client.Token.approve","text":"Grant a third-party permission to transfer up the specified number of tokens from an account. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def approve ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_args ( source , delegate , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"approve()"},{"location":"spl/token/client/#spl.token.client.Token.approve_checked","text":"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of the source account. required delegate Pubkey Account authorized to perform a transfer tokens from the source account. required owner Pubkey Owner of the source account. required amount int Maximum number of tokens the delegate may transfer. required decimals int Number of decimals in approve amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def approve_checked ( self , source : Pubkey , delegate : Pubkey , owner : Pubkey , amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Grant a third-party permission to transfer up the specified number of tokens from an account. This method also asserts the token mint and decimals. Args: source: Public key of the source account. delegate: Account authorized to perform a transfer tokens from the source account. owner: Owner of the source account. amount: Maximum number of tokens the delegate may transfer. decimals: Number of decimals in approve amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _approve_checked_args ( source , delegate , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"approve_checked()"},{"location":"spl/token/client/#spl.token.client.Token.burn","text":"Burn tokens. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Pubkey Owner of the account. required amount int Amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def burn ( self , account : Pubkey , owner : Pubkey , amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_args ( account , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"burn()"},{"location":"spl/token/client/#spl.token.client.Token.burn_checked","text":"Burn tokens, asserting the token mint and decimals. Parameters: Name Type Description Default account Pubkey Account to burn tokens from. required owner Union[Keypair, Pubkey] Owner of the account. required amount int Amount to burn. required decimals int Number of decimals in amount to burn. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def burn_checked ( self , account : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Burn tokens, asserting the token mint and decimals. Args: account: Account to burn tokens from. owner: Owner of the account. amount: Amount to burn. decimals: Number of decimals in amount to burn. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _burn_checked_args ( account , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"burn_checked()"},{"location":"spl/token/client/#spl.token.client.Token.close_account","text":"Remove approval for the transfer of any remaining tokens. Parameters: Name Type Description Default account Pubkey Account to close. required dest Pubkey Account to receive the remaining balance of the closed account. required authority Union[Keypair, Pubkey] Authority which is allowed to close the account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def close_account ( self , account : Pubkey , dest : Pubkey , authority : Union [ Keypair , Pubkey ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Remove approval for the transfer of any remaining tokens. Args: account: Account to close. dest: Account to receive the remaining balance of the closed account. authority: Authority which is allowed to close the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _close_account_args ( account , dest , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"close_account()"},{"location":"spl/token/client/#spl.token.client.Token.create_account","text":"Create and initialize a new account. This account may then be used as a transfer() or approve() destination. Parameters: Name Type Description Default owner Pubkey User account that will own the new account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new empty account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def create_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account. This account may then be used as a `transfer()` or `approve()` destination. Args: owner: User account that will own the new account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new empty account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( self . _conn ) new_account_pk , txn , payer , new_account , opts = self . _create_account_args ( owner , skip_confirmation , balance_needed , self . _conn . commitment ) # Send the two instructions self . _conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_pk","title":"create_account()"},{"location":"spl/token/client/#spl.token.client.Token.create_associated_token_account","text":"Create an associated token account. Parameters: Name Type Description Default owner Pubkey User account that will own the associated token account. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new associated account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def create_associated_token_account ( self , owner : Pubkey , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create an associated token account. Args: owner: User account that will own the associated token account. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new associated account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Construct transaction public_key , txn , payer , opts = self . _create_associated_token_account_args ( owner , skip_confirmation , self . _conn . commitment ) self . _conn . send_transaction ( txn , payer , opts = opts , recent_blockhash = recent_blockhash ) return public_key","title":"create_associated_token_account()"},{"location":"spl/token/client/#spl.token.client.Token.create_mint","text":"Create and initialize a token. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required payer Keypair Fee payer for transaction. required mint_authority Pubkey Account or multisig that will control minting. required decimals int Location of the decimal place. required program_id Pubkey SPL Token program account. required freeze_authority Optional[Pubkey] (optional) Account or multisig that can freeze token accounts. None skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Token Token object for the newly minted token. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py @classmethod def create_mint ( cls , conn : Client , payer : Keypair , mint_authority : Pubkey , decimals : int , program_id : Pubkey , freeze_authority : Optional [ Pubkey ] = None , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Token : \"\"\"Create and initialize a token. Args: conn: RPC connection to a solana cluster. payer: Fee payer for transaction. mint_authority: Account or multisig that will control minting. decimals: Location of the decimal place. program_id: SPL Token program account. freeze_authority: (optional) Account or multisig that can freeze token accounts. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Token object for the newly minted token. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_mint ( conn ) # Construct transaction token , txn , payer , mint_account , opts = _TokenCore . _create_mint_args ( conn , payer , mint_authority , decimals , program_id , freeze_authority , skip_confirmation , balance_needed , cls , conn . commitment , ) # Send the two instructions conn . send_transaction ( txn , payer , mint_account , opts = opts , recent_blockhash = recent_blockhash ) return cast ( Token , token )","title":"create_mint()"},{"location":"spl/token/client/#spl.token.client.Token.create_multisig","text":"Create and initialize a new multisig. Parameters: Name Type Description Default m int Number of required signatures. required multi_signers List[Pubkey] Full set of signers. required opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey Public key of the new multisig account. Source code in spl/token/client.py def create_multisig ( self , m : int , multi_signers : List [ Pubkey ], opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : # pylint: disable=invalid-name \"\"\"Create and initialize a new multisig. Args: m: Number of required signatures. multi_signers: Full set of signers. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: Public key of the new multisig account. \"\"\" balance_needed = Token . get_min_balance_rent_for_exempt_for_multisig ( self . _conn ) txn , payer , multisig = self . _create_multisig_args ( m , multi_signers , balance_needed ) opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts self . _conn . send_transaction ( txn , payer , multisig , opts = opts_to_use , recent_blockhash = recent_blockhash ) return multisig . pubkey ()","title":"create_multisig()"},{"location":"spl/token/client/#spl.token.client.Token.create_wrapped_native_account","text":"Create and initialize a new account on the special native token mint. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required program_id Pubkey SPL Token program account. required owner Pubkey The owner of the new token account. required payer Keypair The source of the lamports to initialize, and payer of the initialization fees. required amount int The amount of lamports to wrap. required skip_confirmation bool (optional) Option to skip transaction confirmation. False recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Returns: Type Description Pubkey The new token account. If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py @staticmethod def create_wrapped_native_account ( conn : Client , program_id : Pubkey , owner : Pubkey , payer : Keypair , amount : int , skip_confirmation : bool = False , recent_blockhash : Optional [ Blockhash ] = None , ) -> Pubkey : \"\"\"Create and initialize a new account on the special native token mint. Args: conn: RPC connection to a solana cluster. program_id: SPL Token program account. owner: The owner of the new token account. payer: The source of the lamports to initialize, and payer of the initialization fees. amount: The amount of lamports to wrap. skip_confirmation: (optional) Option to skip transaction confirmation. recent_blockhash: (optional) a prefetched Blockhash for the transaction. Returns: The new token account. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" # Allocate memory for the account balance_needed = Token . get_min_balance_rent_for_exempt_for_account ( conn ) ( new_account_public_key , txn , payer , new_account , opts ,) = _TokenCore . _create_wrapped_native_account_args ( program_id , owner , payer , amount , skip_confirmation , balance_needed , conn . commitment , ) conn . send_transaction ( txn , payer , new_account , opts = opts , recent_blockhash = recent_blockhash ) return new_account_public_key","title":"create_wrapped_native_account()"},{"location":"spl/token/client/#spl.token.client.Token.freeze_account","text":"Freeze account. Parameters: Name Type Description Default account Pubkey Account to freeze. required authority Union[Pubkey, Keypair] The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def freeze_account ( self , account : Pubkey , authority : Union [ Pubkey , Keypair ], multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Freeze account. Args: account: Account to freeze. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _freeze_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"freeze_account()"},{"location":"spl/token/client/#spl.token.client.Token.get_account_info","text":"Retrieve account information. Source code in spl/token/client.py def get_account_info ( self , account : Pubkey , commitment : Optional [ Commitment ] = None ) -> AccountInfo : \"\"\"Retrieve account information.\"\"\" info = self . _conn . get_account_info ( account , commitment ) return self . _create_account_info ( info )","title":"get_account_info()"},{"location":"spl/token/client/#spl.token.client.Token.get_accounts_by_delegate","text":"Get token accounts of the provided delegate. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/client.py def get_accounts_by_delegate ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateResp : \"\"\"Get token accounts of the provided delegate. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate ( * args )","title":"get_accounts_by_delegate()"},{"location":"spl/token/client/#spl.token.client.Token.get_accounts_by_delegate_json_parsed","text":"Get token accounts of the provided delegate, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the delegate account. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/client.py def get_accounts_by_delegate_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByDelegateJsonParsedResp : \"\"\"Get token accounts of the provided delegate, in JSON format. Args: owner: Public Key of the delegate account. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_delegate_json_parsed ( * args )","title":"get_accounts_by_delegate_json_parsed()"},{"location":"spl/token/client/#spl.token.client.Token.get_accounts_by_owner","text":"Get token accounts of the provided owner. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None encoding str (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". 'base64' Source code in spl/token/client.py def get_accounts_by_owner ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , encoding : str = \"base64\" , ) -> GetTokenAccountsByOwnerResp : \"\"\"Get token accounts of the provided owner. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. encoding: (optional) Encoding for Account data, either \"base58\" (slow) or \"base64\". \"\"\" args = self . _get_accounts_args ( owner , commitment , encoding , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner ( * args )","title":"get_accounts_by_owner()"},{"location":"spl/token/client/#spl.token.client.Token.get_accounts_by_owner_json_parsed","text":"Get token accounts of the provided owner by the token's mint, in JSON format. Parameters: Name Type Description Default owner Pubkey Public Key of the token account owner. required commitment Optional[Commitment] (optional) Bank state to query. None Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. Source code in spl/token/client.py def get_accounts_by_owner_json_parsed ( self , owner : Pubkey , commitment : Optional [ Commitment ] = None , ) -> GetTokenAccountsByOwnerJsonParsedResp : \"\"\"Get token accounts of the provided owner by the token's mint, in JSON format. Args: owner: Public Key of the token account owner. commitment: (optional) Bank state to query. Parsed-JSON encoding attempts to use program-specific state parsers to return more human-readable and explicit account state data. If parsed-JSON is requested but a valid mint cannot be found for a particular account, that account will be filtered out from results. jsonParsed encoding is UNSTABLE. \"\"\" args = self . _get_accounts_args ( owner , commitment , \"jsonParsed\" , self . _conn . commitment , # pylint: disable=protected-access ) return self . _conn . get_token_accounts_by_owner_json_parsed ( * args )","title":"get_accounts_by_owner_json_parsed()"},{"location":"spl/token/client/#spl.token.client.Token.get_balance","text":"Get the balance of the provided token account. Parameters: Name Type Description Default pubkey Pubkey Public Key of the token account. required commitment Optional[Commitment] (optional) Bank state to query. None Source code in spl/token/client.py def get_balance ( self , pubkey : Pubkey , commitment : Optional [ Commitment ] = None ) -> GetTokenAccountBalanceResp : \"\"\"Get the balance of the provided token account. Args: pubkey: Public Key of the token account. commitment: (optional) Bank state to query. \"\"\" return self . _conn . get_token_account_balance ( pubkey , commitment )","title":"get_balance()"},{"location":"spl/token/client/#spl.token.client.Token.get_min_balance_rent_for_exempt_for_account","text":"Get the minimum balance for the account to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_account ( conn : Client ) -> int : \"\"\"Get the minimum balance for the account to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( ACCOUNT_LAYOUT . sizeof ()) return resp . value","title":"get_min_balance_rent_for_exempt_for_account()"},{"location":"spl/token/client/#spl.token.client.Token.get_min_balance_rent_for_exempt_for_mint","text":"Get the minimum balance for the mint to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Returns: Type Description int Number of lamports required. Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_mint ( conn : Client ) -> int : \"\"\"Get the minimum balance for the mint to be rent exempt. Args: conn: RPC connection to a solana cluster. Returns: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MINT_LAYOUT . sizeof ()) return resp . value","title":"get_min_balance_rent_for_exempt_for_mint()"},{"location":"spl/token/client/#spl.token.client.Token.get_min_balance_rent_for_exempt_for_multisig","text":"Get the minimum balance for the multisig to be rent exempt. Parameters: Name Type Description Default conn Client RPC connection to a solana cluster. required Source code in spl/token/client.py @staticmethod def get_min_balance_rent_for_exempt_for_multisig ( conn : Client ) -> int : \"\"\"Get the minimum balance for the multisig to be rent exempt. Args: conn: RPC connection to a solana cluster. Return: Number of lamports required. \"\"\" resp = conn . get_minimum_balance_for_rent_exemption ( MULTISIG_LAYOUT . sizeof ()) return resp . value","title":"get_min_balance_rent_for_exempt_for_multisig()"},{"location":"spl/token/client/#spl.token.client.Token.get_mint_info","text":"Retrieve mint information. Source code in spl/token/client.py def get_mint_info ( self ) -> MintInfo : \"\"\"Retrieve mint information.\"\"\" info = self . _conn . get_account_info ( self . pubkey ) return self . _create_mint_info ( info )","title":"get_mint_info()"},{"location":"spl/token/client/#spl.token.client.Token.mint_to","text":"Mint new tokens. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Union[Keypair, Pubkey] Public key of the minting authority. required amount int Amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None If skip confirmation is set to False , this method will block for at most 30 seconds or until the transaction is confirmed. Source code in spl/token/client.py def mint_to ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. If skip confirmation is set to `False`, this method will block for at most 30 seconds or until the transaction is confirmed. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_args ( dest , mint_authority , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"mint_to()"},{"location":"spl/token/client/#spl.token.client.Token.mint_to_checked","text":"Mint new tokens, asserting the token mint and decimals. Parameters: Name Type Description Default dest Pubkey Public key of the account to mint to. required mint_authority Union[Keypair, Pubkey] Public key of the minting authority. required amount int Amount to mint. required decimals int Number of decimals in amount to mint. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def mint_to_checked ( self , dest : Pubkey , mint_authority : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Mint new tokens, asserting the token mint and decimals. Args: dest: Public key of the account to mint to. mint_authority: Public key of the minting authority. amount: Amount to mint. decimals: Number of decimals in amount to mint. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _mint_to_checked_args ( dest , mint_authority , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"mint_to_checked()"},{"location":"spl/token/client/#spl.token.client.Token.revoke","text":"Revoke transfer authority for a given account. Parameters: Name Type Description Default account Pubkey Source account for which transfer authority is being revoked. required owner Pubkey Owner of the source account. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def revoke ( self , account : Pubkey , owner : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Revoke transfer authority for a given account. Args: account: Source account for which transfer authority is being revoked. owner: Owner of the source account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _revoke_args ( account , owner , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"revoke()"},{"location":"spl/token/client/#spl.token.client.Token.set_authority","text":"Assign a new authority to the account. Parameters: Name Type Description Default account Pubkey Public key of the token account. required current_authority Union[Keypair, Pubkey] Current authority of the account. required authority_type spl_token.AuthorityType Type of authority to set. required new_authority Optional[Pubkey] (optional) New authority of the account. None multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def set_authority ( self , account : Pubkey , current_authority : Union [ Keypair , Pubkey ], authority_type : spl_token . AuthorityType , new_authority : Optional [ Pubkey ] = None , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Assign a new authority to the account. Args: account: Public key of the token account. current_authority: Current authority of the account. authority_type: Type of authority to set. new_authority: (optional) New authority of the account. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , payer , signers , opts = self . _set_authority_args ( account , current_authority , authority_type , new_authority , multi_signers , opts_to_use , ) return self . _conn . send_transaction ( txn , payer , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"set_authority()"},{"location":"spl/token/client/#spl.token.client.Token.thaw_account","text":"Thaw account. Parameters: Name Type Description Default account Pubkey Account to thaw. required authority Pubkey The mint freeze authority. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if authority is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def thaw_account ( self , account : Pubkey , authority : Pubkey , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Thaw account. Args: account: Account to thaw. authority: The mint freeze authority. multi_signers: (optional) Signing accounts if `authority` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _thaw_account_args ( account , authority , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"thaw_account()"},{"location":"spl/token/client/#spl.token.client.Token.transfer","text":"Transfer tokens to another account. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Union[Keypair, Pubkey] Owner of the source account. required amount int Number of tokens to transfer. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def transfer ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_args ( source , dest , owner , amount , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"transfer()"},{"location":"spl/token/client/#spl.token.client.Token.transfer_checked","text":"Transfer tokens to another account, asserting the token mint and decimals. Parameters: Name Type Description Default source Pubkey Public key of account to transfer tokens from. required dest Pubkey Public key of account to transfer tokens to. required owner Union[Keypair, Pubkey] Owner of the source account. required amount int Number of tokens to transfer. required decimals int Number of decimals in transfer amount. required multi_signers Optional[List[Keypair]] (optional) Signing accounts if owner is a multiSig. None opts Optional[TxOpts] (optional) Transaction options. None recent_blockhash Optional[Blockhash] (optional) a prefetched Blockhash for the transaction. None Source code in spl/token/client.py def transfer_checked ( self , source : Pubkey , dest : Pubkey , owner : Union [ Keypair , Pubkey ], amount : int , decimals : int , multi_signers : Optional [ List [ Keypair ]] = None , opts : Optional [ TxOpts ] = None , recent_blockhash : Optional [ Blockhash ] = None , ) -> SendTransactionResp : \"\"\"Transfer tokens to another account, asserting the token mint and decimals. Args: source: Public key of account to transfer tokens from. dest: Public key of account to transfer tokens to. owner: Owner of the source account. amount: Number of tokens to transfer. decimals: Number of decimals in transfer amount. multi_signers: (optional) Signing accounts if `owner` is a multiSig. opts: (optional) Transaction options. recent_blockhash: (optional) a prefetched Blockhash for the transaction. \"\"\" opts_to_use = TxOpts ( preflight_commitment = self . _conn . commitment ) if opts is None else opts txn , signers , opts = self . _transfer_checked_args ( source , dest , owner , amount , decimals , multi_signers , opts_to_use ) return self . _conn . send_transaction ( txn , * signers , opts = opts , recent_blockhash = recent_blockhash )","title":"transfer_checked()"},{"location":"spl/token/constants/","text":"Constants spl.token.constants SPL token constants. ACCOUNT_LEN : int Data length of a token account. ASSOCIATED_TOKEN_PROGRAM_ID Program ID for the associated token account program. MINT_LEN : int Data length of a token mint account. MULTISIG_LEN : int Data length of a multisig token account. TOKEN_PROGRAM_ID : Pubkey Public key that identifies the SPL token program. WRAPPED_SOL_MINT : Pubkey Public key of the \"Native Mint\" for wrapping SOL to SPL token. The Token Program can be used to wrap native SOL. Doing so allows native SOL to be treated like any other Token program token type and can be useful when being called from other programs that interact with the Token Program's interface.","title":"Constants"},{"location":"spl/token/constants/#constants","text":"","title":"Constants"},{"location":"spl/token/constants/#spl.token.constants","text":"SPL token constants.","title":"constants"},{"location":"spl/token/constants/#spl.token.constants.ACCOUNT_LEN","text":"Data length of a token account.","title":"ACCOUNT_LEN"},{"location":"spl/token/constants/#spl.token.constants.ASSOCIATED_TOKEN_PROGRAM_ID","text":"Program ID for the associated token account program.","title":"ASSOCIATED_TOKEN_PROGRAM_ID"},{"location":"spl/token/constants/#spl.token.constants.MINT_LEN","text":"Data length of a token mint account.","title":"MINT_LEN"},{"location":"spl/token/constants/#spl.token.constants.MULTISIG_LEN","text":"Data length of a multisig token account.","title":"MULTISIG_LEN"},{"location":"spl/token/constants/#spl.token.constants.TOKEN_PROGRAM_ID","text":"Public key that identifies the SPL token program.","title":"TOKEN_PROGRAM_ID"},{"location":"spl/token/constants/#spl.token.constants.WRAPPED_SOL_MINT","text":"Public key of the \"Native Mint\" for wrapping SOL to SPL token. The Token Program can be used to wrap native SOL. Doing so allows native SOL to be treated like any other Token program token type and can be useful when being called from other programs that interact with the Token Program's interface.","title":"WRAPPED_SOL_MINT"},{"location":"spl/token/core/","text":"Core spl.token.core Helper code for client.py and async_client.py. AccountInfo Information about an account. Source code in spl/token/core.py class AccountInfo ( NamedTuple ): \"\"\"Information about an account.\"\"\" mint : Pubkey \"\"\"The mint associated with this account.\"\"\" owner : Pubkey \"\"\"Owner of this account.\"\"\" amount : int \"\"\"Amount of tokens this account holds.\"\"\" delegate : Optional [ Pubkey ] \"\"\"The delegate for this account.\"\"\" delegated_amount : int \"\"\"The amount of tokens the delegate authorized to the delegate.\"\"\" is_initialized : bool \"\"\" Is this account initialized.\"\"\" is_frozen : bool \"\"\"Is this account frozen.\"\"\" is_native : bool \"\"\"Is this a native token account.\"\"\" rent_exempt_reserve : Optional [ int ] \"\"\"If this account is a native token, it must be rent-exempt. This value logs the rent-exempt reserve which must remain in the balance until the account is closed. \"\"\" close_authority : Optional [ Pubkey ] \"\"\"Optional authority to close the account.\"\"\" amount : int Amount of tokens this account holds. close_authority : Optional [ solders . pubkey . Pubkey ] Optional authority to close the account. delegate : Optional [ solders . pubkey . Pubkey ] The delegate for this account. delegated_amount : int The amount of tokens the delegate authorized to the delegate. is_frozen : bool Is this account frozen. is_initialized : bool Is this account initialized. is_native : bool Is this a native token account. mint : Pubkey The mint associated with this account. owner : Pubkey Owner of this account. rent_exempt_reserve : Optional [ int ] If this account is a native token, it must be rent-exempt. This value logs the rent-exempt reserve which must remain in the balance until the account is closed. MintInfo Information about the mint. Source code in spl/token/core.py class MintInfo ( NamedTuple ): \"\"\"Information about the mint.\"\"\" mint_authority : Optional [ Pubkey ] \"\"\"\"Optional authority used to mint new tokens. The mint authority may only be provided during mint creation. If no mint authority is present then the mint has a fixed supply and no further tokens may be minted. \"\"\" supply : int \"\"\"Total supply of tokens.\"\"\" decimals : int \"\"\"Number of base 10 digits to the right of the decimal place.\"\"\" is_initialized : bool \"\"\"Is this mint initialized.\"\"\" freeze_authority : Optional [ Pubkey ] \"\"\" Optional authority to freeze token accounts.\"\"\" decimals : int Number of base 10 digits to the right of the decimal place. freeze_authority : Optional [ solders . pubkey . Pubkey ] Optional authority to freeze token accounts. is_initialized : bool Is this mint initialized. mint_authority : Optional [ solders . pubkey . Pubkey ] \"Optional authority used to mint new tokens. The mint authority may only be provided during mint creation. If no mint authority is present then the mint has a fixed supply and no further tokens may be minted. supply : int Total supply of tokens.","title":"Core"},{"location":"spl/token/core/#core","text":"","title":"Core"},{"location":"spl/token/core/#spl.token.core","text":"Helper code for client.py and async_client.py.","title":"core"},{"location":"spl/token/core/#spl.token.core.AccountInfo","text":"Information about an account. Source code in spl/token/core.py class AccountInfo ( NamedTuple ): \"\"\"Information about an account.\"\"\" mint : Pubkey \"\"\"The mint associated with this account.\"\"\" owner : Pubkey \"\"\"Owner of this account.\"\"\" amount : int \"\"\"Amount of tokens this account holds.\"\"\" delegate : Optional [ Pubkey ] \"\"\"The delegate for this account.\"\"\" delegated_amount : int \"\"\"The amount of tokens the delegate authorized to the delegate.\"\"\" is_initialized : bool \"\"\" Is this account initialized.\"\"\" is_frozen : bool \"\"\"Is this account frozen.\"\"\" is_native : bool \"\"\"Is this a native token account.\"\"\" rent_exempt_reserve : Optional [ int ] \"\"\"If this account is a native token, it must be rent-exempt. This value logs the rent-exempt reserve which must remain in the balance until the account is closed. \"\"\" close_authority : Optional [ Pubkey ] \"\"\"Optional authority to close the account.\"\"\"","title":"AccountInfo"},{"location":"spl/token/core/#spl.token.core.AccountInfo.amount","text":"Amount of tokens this account holds.","title":"amount"},{"location":"spl/token/core/#spl.token.core.AccountInfo.close_authority","text":"Optional authority to close the account.","title":"close_authority"},{"location":"spl/token/core/#spl.token.core.AccountInfo.delegate","text":"The delegate for this account.","title":"delegate"},{"location":"spl/token/core/#spl.token.core.AccountInfo.delegated_amount","text":"The amount of tokens the delegate authorized to the delegate.","title":"delegated_amount"},{"location":"spl/token/core/#spl.token.core.AccountInfo.is_frozen","text":"Is this account frozen.","title":"is_frozen"},{"location":"spl/token/core/#spl.token.core.AccountInfo.is_initialized","text":"Is this account initialized.","title":"is_initialized"},{"location":"spl/token/core/#spl.token.core.AccountInfo.is_native","text":"Is this a native token account.","title":"is_native"},{"location":"spl/token/core/#spl.token.core.AccountInfo.mint","text":"The mint associated with this account.","title":"mint"},{"location":"spl/token/core/#spl.token.core.AccountInfo.owner","text":"Owner of this account.","title":"owner"},{"location":"spl/token/core/#spl.token.core.AccountInfo.rent_exempt_reserve","text":"If this account is a native token, it must be rent-exempt. This value logs the rent-exempt reserve which must remain in the balance until the account is closed.","title":"rent_exempt_reserve"},{"location":"spl/token/core/#spl.token.core.MintInfo","text":"Information about the mint. Source code in spl/token/core.py class MintInfo ( NamedTuple ): \"\"\"Information about the mint.\"\"\" mint_authority : Optional [ Pubkey ] \"\"\"\"Optional authority used to mint new tokens. The mint authority may only be provided during mint creation. If no mint authority is present then the mint has a fixed supply and no further tokens may be minted. \"\"\" supply : int \"\"\"Total supply of tokens.\"\"\" decimals : int \"\"\"Number of base 10 digits to the right of the decimal place.\"\"\" is_initialized : bool \"\"\"Is this mint initialized.\"\"\" freeze_authority : Optional [ Pubkey ] \"\"\" Optional authority to freeze token accounts.\"\"\"","title":"MintInfo"},{"location":"spl/token/core/#spl.token.core.MintInfo.decimals","text":"Number of base 10 digits to the right of the decimal place.","title":"decimals"},{"location":"spl/token/core/#spl.token.core.MintInfo.freeze_authority","text":"Optional authority to freeze token accounts.","title":"freeze_authority"},{"location":"spl/token/core/#spl.token.core.MintInfo.is_initialized","text":"Is this mint initialized.","title":"is_initialized"},{"location":"spl/token/core/#spl.token.core.MintInfo.mint_authority","text":"\"Optional authority used to mint new tokens. The mint authority may only be provided during mint creation. If no mint authority is present then the mint has a fixed supply and no further tokens may be minted.","title":"mint_authority"},{"location":"spl/token/core/#spl.token.core.MintInfo.supply","text":"Total supply of tokens.","title":"supply"},{"location":"spl/token/instructions/","text":"Instructions spl.token.instructions SPL token instructions. ApproveCheckedParams ApproveChecked token transaction params. Source code in spl/token/instructions.py class ApproveCheckedParams ( NamedTuple ): \"\"\"ApproveChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" delegate : Pubkey \"\"\"Delegate account authorized to perform a transfer of tokens from the source account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Maximum number of tokens the delegate may transfer.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" amount : int Maximum number of tokens the delegate may transfer. decimals : int Amount decimals. delegate : Pubkey Delegate account authorized to perform a transfer of tokens from the source account. mint : Pubkey Public key of the minter account. owner : Pubkey Owner of the source account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig. source : Pubkey Source account. ApproveParams Approve token transaction params. Source code in spl/token/instructions.py class ApproveParams ( NamedTuple ): \"\"\"Approve token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" delegate : Pubkey \"\"\"Delegate account authorized to perform a transfer of tokens from the source account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Maximum number of tokens the delegate may transfer.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" amount : int Maximum number of tokens the delegate may transfer. delegate : Pubkey Delegate account authorized to perform a transfer of tokens from the source account. owner : Pubkey Owner of the source account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig. source : Pubkey Source account. AuthorityType Specifies the authority type for SetAuthority instructions. Source code in spl/token/instructions.py class AuthorityType ( IntEnum ): \"\"\"Specifies the authority type for SetAuthority instructions.\"\"\" MINT_TOKENS = 0 \"\"\"\"Authority to mint new tokens.\"\"\" FREEZE_ACCOUNT = 1 \"\"\"Authority to freeze any account associated with the Mint.\"\"\" ACCOUNT_OWNER = 2 \"\"\"Owner of a given token account.\"\"\" CLOSE_ACCOUNT = 3 \"\"\"Authority to close a token account.\"\"\" ACCOUNT_OWNER Owner of a given token account. CLOSE_ACCOUNT Authority to close a token account. FREEZE_ACCOUNT Authority to freeze any account associated with the Mint. MINT_TOKENS \"Authority to mint new tokens. BurnCheckedParams BurnChecked token transaction params. Source code in spl/token/instructions.py class BurnCheckedParams ( NamedTuple ): \"\"\"BurnChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" account : Pubkey \"\"\"Account to burn tokens from.\"\"\" owner : Pubkey \"\"\"Owner of the account.\"\"\" amount : int \"\"\"Amount to burn.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\" account : Pubkey Account to burn tokens from. amount : int Amount to burn. decimals : int Amount decimals. mint : Pubkey Public key of the minter account. owner : Pubkey Owner of the account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig BurnParams Burn token transaction params. Source code in spl/token/instructions.py class BurnParams ( NamedTuple ): \"\"\"Burn token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to burn tokens from.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" owner : Pubkey \"\"\"Owner of the account.\"\"\" amount : int \"\"\"Amount to burn.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\" account : Pubkey Account to burn tokens from. amount : int Amount to burn. mint : Pubkey Public key of the minter account. owner : Pubkey Owner of the account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig CloseAccountParams Close token account transaction params. Source code in spl/token/instructions.py class CloseAccountParams ( NamedTuple ): \"\"\"Close token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Address of account to close.\"\"\" dest : Pubkey \"\"\"Address of account to receive the remaining balance of the closed account.\"\"\" owner : Pubkey \"\"\"Owner of the account.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\" account : Pubkey Address of account to close. dest : Pubkey Address of account to receive the remaining balance of the closed account. owner : Pubkey Owner of the account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig FreezeAccountParams Freeze token account transaction params. Source code in spl/token/instructions.py class FreezeAccountParams ( NamedTuple ): \"\"\"Freeze token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to freeze.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" authority : Pubkey \"\"\"Mint freeze authority\"\"\" multi_signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `authority` is a multiSig\"\"\" account : Pubkey Account to freeze. authority : Pubkey Mint freeze authority mint : Pubkey Public key of the minter account. multi_signers : List [ solders . pubkey . Pubkey ] Signing accounts if authority is a multiSig program_id : Pubkey SPL Token program account. InitializeAccountParams Initialize token account transaction params. Source code in spl/token/instructions.py class InitializeAccountParams ( NamedTuple ): \"\"\"Initialize token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Public key of the new account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" owner : Pubkey \"\"\"Owner of the new account.\"\"\" account : Pubkey Public key of the new account. mint : Pubkey Public key of the minter account. owner : Pubkey Owner of the new account. program_id : Pubkey SPL Token program account. InitializeMintParams Initialize token mint transaction params. Source code in spl/token/instructions.py class InitializeMintParams ( NamedTuple ): \"\"\"Initialize token mint transaction params.\"\"\" decimals : int \"\"\"Number of base 10 digits to the right of the decimal place.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" mint_authority : Pubkey \"\"\"The authority/multisignature to mint tokens.\"\"\" freeze_authority : Optional [ Pubkey ] = None \"\"\"The freeze authority/multisignature of the mint.\"\"\" decimals : int Number of base 10 digits to the right of the decimal place. freeze_authority : Optional [ solders . pubkey . Pubkey ] The freeze authority/multisignature of the mint. mint : Pubkey Public key of the minter account. mint_authority : Pubkey The authority/multisignature to mint tokens. program_id : Pubkey SPL Token program account. InitializeMultisigParams Initialize multisig token account transaction params. Source code in spl/token/instructions.py class InitializeMultisigParams ( NamedTuple ): \"\"\"Initialize multisig token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" multisig : Pubkey \"\"\"New multisig account address.\"\"\" m : int \"\"\"The number of signers (M) required to validate this multisignature account.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Addresses of multisig signers.\"\"\" m : int The number of signers (M) required to validate this multisignature account. multisig : Pubkey New multisig account address. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Addresses of multisig signers. MintToCheckedParams MintToChecked token transaction params. Source code in spl/token/instructions.py class MintToCheckedParams ( NamedTuple ): \"\"\"MintToChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" dest : Pubkey \"\"\"Public key of the account to mint to.\"\"\" mint_authority : Pubkey \"\"\"The mint authority.\"\"\" amount : int \"\"\"Amount to mint.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `mint_authority` is a multiSig.\"\"\" amount : int Amount to mint. decimals : int Amount decimals. dest : Pubkey Public key of the account to mint to. mint : Pubkey Public key of the minter account. mint_authority : Pubkey The mint authority. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if mint_authority is a multiSig. MintToParams Mint token transaction params. Source code in spl/token/instructions.py class MintToParams ( NamedTuple ): \"\"\"Mint token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" dest : Pubkey \"\"\"Public key of the account to mint to.\"\"\" mint_authority : Pubkey \"\"\"The mint authority.\"\"\" amount : int \"\"\"Amount to mint.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `mint_authority` is a multiSig.\"\"\" amount : int Amount to mint. dest : Pubkey Public key of the account to mint to. mint : Pubkey Public key of the minter account. mint_authority : Pubkey The mint authority. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if mint_authority is a multiSig. RevokeParams Revoke token transaction params. Source code in spl/token/instructions.py class RevokeParams ( NamedTuple ): \"\"\"Revoke token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Source account for which transfer authority is being revoked.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" account : Pubkey Source account for which transfer authority is being revoked. owner : Pubkey Owner of the source account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig. SetAuthorityParams Set token authority transaction params. Source code in spl/token/instructions.py class SetAuthorityParams ( NamedTuple ): \"\"\"Set token authority transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Public key of the token account.\"\"\" authority : AuthorityType \"\"\"The type of authority to update.\"\"\" current_authority : Pubkey \"\"\"Current authority of the specified type.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `current_authority` is a multiSig.\"\"\" new_authority : Optional [ Pubkey ] = None \"\"\"New authority of the account.\"\"\" account : Pubkey Public key of the token account. authority : AuthorityType The type of authority to update. current_authority : Pubkey Current authority of the specified type. new_authority : Optional [ solders . pubkey . Pubkey ] New authority of the account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if current_authority is a multiSig. SyncNativeParams BurnChecked token transaction params. Source code in spl/token/instructions.py class SyncNativeParams ( NamedTuple ): \"\"\"BurnChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to sync.\"\"\" account : Pubkey Account to sync. program_id : Pubkey SPL Token program account. ThawAccountParams Thaw token account transaction params. Source code in spl/token/instructions.py class ThawAccountParams ( NamedTuple ): \"\"\"Thaw token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to thaw.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" authority : Pubkey \"\"\"Mint freeze authority\"\"\" multi_signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `authority` is a multiSig\"\"\" account : Pubkey Account to thaw. authority : Pubkey Mint freeze authority mint : Pubkey Public key of the minter account. multi_signers : List [ solders . pubkey . Pubkey ] Signing accounts if authority is a multiSig program_id : Pubkey SPL Token program account. TransferCheckedParams TransferChecked token transaction params. Source code in spl/token/instructions.py class TransferCheckedParams ( NamedTuple ): \"\"\"TransferChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" dest : Pubkey \"\"\"Destination account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Number of tokens to transfer.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" amount : int Number of tokens to transfer. decimals : int Amount decimals. dest : Pubkey Destination account. mint : Pubkey Public key of the minter account. owner : Pubkey Owner of the source account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig. source : Pubkey Source account. TransferParams Transfer token transaction params. Source code in spl/token/instructions.py class TransferParams ( NamedTuple ): \"\"\"Transfer token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" dest : Pubkey \"\"\"Destination account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Number of tokens to transfer.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\" amount : int Number of tokens to transfer. dest : Pubkey Destination account. owner : Pubkey Owner of the source account. program_id : Pubkey SPL Token program account. signers : List [ solders . pubkey . Pubkey ] Signing accounts if owner is a multiSig. source : Pubkey Source account. approve ( params ) Creates a transaction instruction to approve a delegate. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> delegate , owner , source , token = pubkeys >>> params = ApproveParams ( ... amount = 123 , ... delegate = delegate , ... owner = owner , ... program_id = token , ... source = source ... ) >>> type ( approve ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The approve instruction. Source code in spl/token/instructions.py def approve ( params : ApproveParams ) -> Instruction : \"\"\"Creates a transaction instruction to approve a delegate. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> delegate, owner, source, token = pubkeys >>> params = ApproveParams( ... amount=123, ... delegate=delegate, ... owner=owner, ... program_id=token, ... source=source ... ) >>> type(approve(params)) <class 'solders.instruction.Instruction'> Returns: The approve instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . APPROVE , \"args\" : { \"amount\" : params . amount }}) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . delegate , is_signer = False , is_writable = False ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) approve_checked ( params ) This instruction differs from approve in that the token mint and decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 5 )] >>> delegate , mint , owner , source , token = pubkeys >>> params = ApproveCheckedParams ( ... amount = 1000 , ... decimals = 6 , ... delegate = delegate , ... mint = mint , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( approve_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The approve-checked instruction. Source code in spl/token/instructions.py def approve_checked ( params : ApproveCheckedParams ) -> Instruction : \"\"\"This instruction differs from `approve` in that the token mint and decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(5)] >>> delegate, mint, owner, source, token = pubkeys >>> params = ApproveCheckedParams( ... amount=1000, ... decimals=6, ... delegate=delegate, ... mint=mint, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(approve_checked(params)) <class 'solders.instruction.Instruction'> Returns: The approve-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . APPROVE2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . delegate , is_signer = False , is_writable = False ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) burn ( params ) Creates a transaction instruction to burns tokens by removing them from an account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , owner , token = pubkeys >>> params = BurnParams ( ... amount = 123 , account = account , mint = mint , owner = owner , program_id = token , ... ) >>> type ( burn ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The burn instruction. Source code in spl/token/instructions.py def burn ( params : BurnParams ) -> Instruction : \"\"\"Creates a transaction instruction to burns tokens by removing them from an account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, owner, token = pubkeys >>> params = BurnParams( ... amount=123, account=account, mint=mint, owner=owner, program_id=token, ... ) >>> type(burn(params)) <class 'solders.instruction.Instruction'> Returns: The burn instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . BURN , \"args\" : { \"amount\" : params . amount }}) return __burn_instruction ( params , data ) burn_checked ( params ) This instruction differs from burn in that the decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , owner , token = pubkeys >>> params = BurnCheckedParams ( ... amount = 123 , account = account , decimals = 6 , mint = mint , owner = owner , program_id = token , ... ) >>> type ( burn_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The burn-checked instruction. Source code in spl/token/instructions.py def burn_checked ( params : BurnCheckedParams ) -> Instruction : \"\"\"This instruction differs from `burn` in that the decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, owner, token = pubkeys >>> params = BurnCheckedParams( ... amount=123, account=account, decimals=6, mint=mint, owner=owner, program_id=token, ... ) >>> type(burn_checked(params)) <class 'solders.instruction.Instruction'> Returns: The burn-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . BURN2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) return __burn_instruction ( params , data ) close_account ( params ) Creates a transaction instruction to close an account by transferring all its SOL to the destination account. Non-native accounts may only be closed if its token amount is zero. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , dest , owner , token = pubkeys >>> params = CloseAccountParams ( ... account = account , dest = dest , owner = owner , program_id = token ) >>> type ( close_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The close-account instruction. Source code in spl/token/instructions.py def close_account ( params : CloseAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to close an account by transferring all its SOL to the destination account. Non-native accounts may only be closed if its token amount is zero. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, dest, owner, token = pubkeys >>> params = CloseAccountParams( ... account=account, dest=dest, owner=owner, program_id=token) >>> type(close_account(params)) <class 'solders.instruction.Instruction'> Returns: The close-account instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . CLOSE_ACCOUNT , \"args\" : None }) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) create_associated_token_account ( payer , owner , mint ) Creates a transaction instruction to create an associated token account. Returns: Type Description Instruction The instruction to create the associated token account. Source code in spl/token/instructions.py def create_associated_token_account ( payer : Pubkey , owner : Pubkey , mint : Pubkey ) -> Instruction : \"\"\"Creates a transaction instruction to create an associated token account. Returns: The instruction to create the associated token account. \"\"\" associated_token_address = get_associated_token_address ( owner , mint ) return Instruction ( accounts = [ AccountMeta ( pubkey = payer , is_signer = True , is_writable = True ), AccountMeta ( pubkey = associated_token_address , is_signer = False , is_writable = True ), AccountMeta ( pubkey = owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = SYS_PROGRAM_ID , is_signer = False , is_writable = False ), AccountMeta ( pubkey = TOKEN_PROGRAM_ID , is_signer = False , is_writable = False ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ], program_id = ASSOCIATED_TOKEN_PROGRAM_ID , data = bytes ( 0 ), ) decode_approve ( instruction ) Decode a approve token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description ApproveParams The decoded instruction. Source code in spl/token/instructions.py def decode_approve ( instruction : Instruction ) -> ApproveParams : \"\"\"Decode a approve token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . APPROVE ) return ApproveParams ( program_id = instruction . program_id , source = instruction . accounts [ 0 ] . pubkey , delegate = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], amount = parsed_data . args . amount , ) decode_approve_checked ( instruction ) Decode a approve_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description ApproveCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_approve_checked ( instruction : Instruction ) -> ApproveCheckedParams : \"\"\"Decode a approve_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 4 , InstructionType . APPROVE2 ) return ApproveCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , source = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , delegate = instruction . accounts [ 2 ] . pubkey , owner = instruction . accounts [ 3 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 4 :]], ) decode_burn ( instruction ) Decode a burn token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description BurnParams The decoded instruction. Source code in spl/token/instructions.py def decode_burn ( instruction : Instruction ) -> BurnParams : \"\"\"Decode a burn token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . BURN ) return BurnParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_burn_checked ( instruction ) Decode a burn_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description BurnCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_burn_checked ( instruction : Instruction ) -> BurnCheckedParams : \"\"\"Decode a burn_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . BURN2 ) return BurnCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_close_account ( instruction ) Decode a close account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description CloseAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_close_account ( instruction : Instruction ) -> CloseAccountParams : \"\"\"Decode a close account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . CLOSE_ACCOUNT ) return CloseAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_freeze_account ( instruction ) Decode a freeze account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description FreezeAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_freeze_account ( instruction : Instruction ) -> FreezeAccountParams : \"\"\"Decode a freeze account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . FREEZE_ACCOUNT ) return FreezeAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , authority = instruction . accounts [ 2 ] . pubkey , multi_signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_initialize_account ( instruction ) Decode an initialize account token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description InitializeAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_account ( instruction : Instruction ) -> InitializeAccountParams : \"\"\"Decode an initialize account token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 4 , InstructionType . INITIALIZE_ACCOUNT ) return InitializeAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , ) decode_initialize_mint ( instruction ) Decode an initialize mint token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description InitializeMintParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_mint ( instruction : Instruction ) -> InitializeMintParams : \"\"\"Decode an initialize mint token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . INITIALIZE_MINT ) return InitializeMintParams ( decimals = parsed_data . args . decimals , program_id = instruction . program_id , mint = instruction . accounts [ 0 ] . pubkey , mint_authority = Pubkey ( parsed_data . args . mint_authority ), freeze_authority = Pubkey ( parsed_data . args . freeze_authority ) if parsed_data . args . freeze_authority_option else None , ) decode_initialize_multisig ( instruction ) Decode an initialize multisig account token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description InitializeMultisigParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_multisig ( instruction : Instruction ) -> InitializeMultisigParams : \"\"\"Decode an initialize multisig account token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . INITIALIZE_MULTISIG ) num_signers = parsed_data . args . m validate_instruction_keys ( instruction , 2 + num_signers ) return InitializeMultisigParams ( program_id = instruction . program_id , multisig = instruction . accounts [ 0 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ - num_signers :]], m = num_signers , ) decode_mint_to ( instruction ) Decode a mint to token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description MintToParams The decoded instruction. Source code in spl/token/instructions.py def decode_mint_to ( instruction : Instruction ) -> MintToParams : \"\"\"Decode a mint to token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . MINT_TO ) return MintToParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , mint = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , mint_authority = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_mint_to_checked ( instruction ) Decode a mintTo2 token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description MintToCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_mint_to_checked ( instruction : Instruction ) -> MintToCheckedParams : \"\"\"Decode a mintTo2 token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . MINT_TO2 ) return MintToCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , mint = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , mint_authority = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_revoke ( instruction ) Decode a revoke token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description RevokeParams The decoded instruction. Source code in spl/token/instructions.py def decode_revoke ( instruction : Instruction ) -> RevokeParams : \"\"\"Decode a revoke token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 2 , InstructionType . REVOKE ) return RevokeParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , owner = instruction . accounts [ 1 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 2 :]], ) decode_set_authority ( instruction ) Decode a set authority token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description SetAuthorityParams The decoded instruction. Source code in spl/token/instructions.py def decode_set_authority ( instruction : Instruction ) -> SetAuthorityParams : \"\"\"Decode a set authority token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . SET_AUTHORITY ) return SetAuthorityParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , authority = AuthorityType ( parsed_data . args . authority_type ), new_authority = Pubkey ( parsed_data . args . new_authority ) if parsed_data . args . new_authority_option else None , current_authority = instruction . accounts [ 1 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 2 :]], ) decode_sync_native ( instruction ) Decode a burn_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description SyncNativeParams The decoded instruction. Source code in spl/token/instructions.py def decode_sync_native ( instruction : Instruction ) -> SyncNativeParams : \"\"\"Decode a burn_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" return SyncNativeParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , ) decode_thaw_account ( instruction ) Decode a thaw account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description ThawAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_thaw_account ( instruction : Instruction ) -> ThawAccountParams : \"\"\"Decode a thaw account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . THAW_ACCOUNT ) return ThawAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , authority = instruction . accounts [ 2 ] . pubkey , multi_signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], ) decode_transfer ( instruction ) Decode a transfer token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description TransferParams The decoded instruction. Source code in spl/token/instructions.py def decode_transfer ( instruction : Instruction ) -> TransferParams : \"\"\"Decode a transfer token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . TRANSFER ) return TransferParams ( program_id = instruction . program_id , source = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], amount = parsed_data . args . amount , ) decode_transfer_checked ( instruction ) Decode a transfer_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description TransferCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_transfer_checked ( instruction : Instruction ) -> TransferCheckedParams : \"\"\"Decode a transfer_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 4 , InstructionType . TRANSFER2 ) return TransferCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , source = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , dest = instruction . accounts [ 2 ] . pubkey , owner = instruction . accounts [ 3 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 4 :]], ) freeze_account ( params ) Creates a transaction instruction to freeze an initialized account using the mint's freeze_authority (if set). Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , authority , token = pubkeys >>> params = FreezeAccountParams ( ... account = account , mint = mint , authority = authority , program_id = token ) >>> type ( freeze_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The freeze-account instruction. Source code in spl/token/instructions.py def freeze_account ( params : FreezeAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to freeze an initialized account using the mint's freeze_authority (if set). Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, authority, token = pubkeys >>> params = FreezeAccountParams( ... account=account, mint=mint, authority=authority, program_id=token) >>> type(freeze_account(params)) <class 'solders.instruction.Instruction'> Returns: The freeze-account instruction. \"\"\" return __freeze_or_thaw_instruction ( params , InstructionType . FREEZE_ACCOUNT ) get_associated_token_address ( owner , mint ) Derives the associated token address for the given wallet address and token mint. Returns: Type Description Pubkey The public key of the derived associated token address. Source code in spl/token/instructions.py def get_associated_token_address ( owner : Pubkey , mint : Pubkey ) -> Pubkey : \"\"\"Derives the associated token address for the given wallet address and token mint. Returns: The public key of the derived associated token address. \"\"\" key , _ = Pubkey . find_program_address ( seeds = [ bytes ( owner ), bytes ( TOKEN_PROGRAM_ID ), bytes ( mint )], program_id = ASSOCIATED_TOKEN_PROGRAM_ID , ) return key initialize_account ( params ) Creates a transaction instruction to initialize a new account to hold tokens. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , owner , token = pubkeys >>> params = InitializeAccountParams ( ... account = account , ... mint = mint , ... owner = owner , ... program_id = token , ... ) >>> type ( initialize_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to initialize the account. Source code in spl/token/instructions.py def initialize_account ( params : InitializeAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to initialize a new account to hold tokens. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, owner, token = pubkeys >>> params = InitializeAccountParams( ... account=account, ... mint=mint, ... owner=owner, ... program_id=token, ... ) >>> type(initialize_account(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to initialize the account. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . INITIALIZE_ACCOUNT , \"args\" : None }) return Instruction ( accounts = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ], program_id = params . program_id , data = data , ) initialize_mint ( params ) Creates a transaction instruction to initialize a new mint newly. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> from spl.token.constants import TOKEN_PROGRAM_ID >>> from solders.pubkey import Pubkey >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> mint_account , mint_authority , freeze_authority , owner = pubkeys >>> params = InitializeMintParams ( ... decimals = 6 , ... freeze_authority = freeze_authority , ... mint = mint_account , ... mint_authority = mint_authority , ... program_id = TOKEN_PROGRAM_ID , ... ) >>> type ( initialize_mint ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to initialize the mint. Source code in spl/token/instructions.py def initialize_mint ( params : InitializeMintParams ) -> Instruction : \"\"\"Creates a transaction instruction to initialize a new mint newly. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> from spl.token.constants import TOKEN_PROGRAM_ID >>> from solders.pubkey import Pubkey >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i +1]) for i in range(4)] >>> mint_account, mint_authority, freeze_authority, owner = pubkeys >>> params = InitializeMintParams( ... decimals=6, ... freeze_authority=freeze_authority, ... mint=mint_account, ... mint_authority=mint_authority, ... program_id=TOKEN_PROGRAM_ID, ... ) >>> type(initialize_mint(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to initialize the mint. \"\"\" freeze_authority , opt = ( params . freeze_authority , 1 ) if params . freeze_authority else ( Pubkey ([ 0 ] * 31 + [ 0 ]), 0 ) data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . INITIALIZE_MINT , \"args\" : { \"decimals\" : params . decimals , \"mint_authority\" : bytes ( params . mint_authority ), \"freeze_authority_option\" : opt , \"freeze_authority\" : bytes ( freeze_authority ), }, } ) return Instruction ( accounts = [ AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = True ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ], program_id = params . program_id , data = data , ) initialize_multisig ( params ) Creates a transaction instruction to initialize a multisignature account with N provided signers. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> m = 2 # Two signers >>> signers = [ Pubkey ([ 0 ] * 31 + [ i ]) for i in range ( m )] >>> leading_zeros = [ 0 ] * 31 >>> multisig_account , token = Pubkey ( leading_zeros + [ 1 ]), Pubkey ( leading_zeros + [ 2 ]) >>> params = InitializeMultisigParams ( ... m = m , ... multisig = multisig_account , ... signers = signers , ... program_id = token , ... ) >>> type ( initialize_multisig ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to initialize the multisig. Source code in spl/token/instructions.py def initialize_multisig ( params : InitializeMultisigParams ) -> Instruction : \"\"\"Creates a transaction instruction to initialize a multisignature account with N provided signers. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> m = 2 # Two signers >>> signers = [Pubkey([0] * 31 + [i]) for i in range(m)] >>> leading_zeros = [0] * 31 >>> multisig_account, token = Pubkey(leading_zeros + [1]), Pubkey(leading_zeros + [2]) >>> params = InitializeMultisigParams( ... m=m, ... multisig=multisig_account, ... signers=signers, ... program_id=token, ... ) >>> type(initialize_multisig(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to initialize the multisig. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . INITIALIZE_MULTISIG , \"args\" : { \"m\" : params . m }, } ) keys = [ AccountMeta ( pubkey = params . multisig , is_signer = False , is_writable = True ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ] for signer in params . signers : keys . append ( AccountMeta ( pubkey = signer , is_signer = False , is_writable = False )) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) mint_to ( params ) Creates a transaction instruction to mint new tokens to an account. The native mint does not support minting. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> dest , mint , mint_authority , token = pubkeys >>> params = MintToParams ( ... amount = 123 , ... dest = dest , ... mint = mint , ... mint_authority = mint_authority , ... program_id = token , ... ) >>> type ( mint_to ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The mint-to instruction. Source code in spl/token/instructions.py def mint_to ( params : MintToParams ) -> Instruction : \"\"\"Creates a transaction instruction to mint new tokens to an account. The native mint does not support minting. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> dest, mint, mint_authority, token = pubkeys >>> params = MintToParams( ... amount=123, ... dest=dest, ... mint=mint, ... mint_authority=mint_authority, ... program_id=token, ... ) >>> type(mint_to(params)) <class 'solders.instruction.Instruction'> Returns: The mint-to instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . MINT_TO , \"args\" : { \"amount\" : params . amount }}) return __mint_to_instruction ( params , data ) mint_to_checked ( params ) This instruction differs from mint_to in that the decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> dest , mint , mint_authority , token = pubkeys >>> params = MintToCheckedParams ( ... amount = 123 , ... decimals = 6 , ... dest = dest , ... mint = mint , ... mint_authority = mint_authority , ... program_id = token , ... ) >>> type ( mint_to_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The mint-to-checked instruction. Source code in spl/token/instructions.py def mint_to_checked ( params : MintToCheckedParams ) -> Instruction : \"\"\"This instruction differs from `mint_to` in that the decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> dest, mint, mint_authority, token = pubkeys >>> params = MintToCheckedParams( ... amount=123, ... decimals=6, ... dest=dest, ... mint=mint, ... mint_authority=mint_authority, ... program_id=token, ... ) >>> type(mint_to_checked(params)) <class 'solders.instruction.Instruction'> Returns: The mint-to-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . MINT_TO2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) return __mint_to_instruction ( params , data ) revoke ( params ) Creates a transaction instruction that revokes delegate authority for a given account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 3 )] >>> account , owner , token = pubkeys >>> params = RevokeParams ( ... account = account , owner = owner , program_id = token ... ) >>> type ( revoke ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The revoke instruction. Source code in spl/token/instructions.py def revoke ( params : RevokeParams ) -> Instruction : \"\"\"Creates a transaction instruction that revokes delegate authority for a given account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(3)] >>> account, owner, token = pubkeys >>> params = RevokeParams( ... account=account, owner=owner, program_id=token ... ) >>> type(revoke(params)) <class 'solders.instruction.Instruction'> Returns: The revoke instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . REVOKE , \"args\" : None }) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True )] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) set_authority ( params ) Creates a transaction instruction to sets a new authority of a mint or account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , current_authority , new_authority , token = pubkeys >>> params = SetAuthorityParams ( ... account = account , ... authority = AuthorityType . ACCOUNT_OWNER , ... current_authority = current_authority , ... new_authority = new_authority , ... program_id = token , ... ) >>> type ( set_authority ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The set authority instruction. Source code in spl/token/instructions.py def set_authority ( params : SetAuthorityParams ) -> Instruction : \"\"\"Creates a transaction instruction to sets a new authority of a mint or account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, current_authority, new_authority, token = pubkeys >>> params = SetAuthorityParams( ... account=account, ... authority=AuthorityType.ACCOUNT_OWNER, ... current_authority=current_authority, ... new_authority=new_authority, ... program_id=token, ... ) >>> type(set_authority(params)) <class 'solders.instruction.Instruction'> Returns: The set authority instruction. \"\"\" new_authority , opt = ( params . new_authority , 1 ) if params . new_authority else ( Pubkey ([ 0 ] * 31 + [ 0 ]), 0 ) data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . SET_AUTHORITY , \"args\" : { \"authority_type\" : params . authority , \"new_authority_option\" : opt , \"new_authority\" : bytes ( new_authority ), }, } ) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True )] __add_signers ( keys , params . current_authority , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) sync_native ( params ) Syncs the amount field with the number of lamports of the account. Examples: >>> account = Pubkey . default () >>> params = SyncNativeParams ( ... program_id = TOKEN_PROGRAM_ID , account = account , ... ) >>> type ( sync_native ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The sync-native instruction. Source code in spl/token/instructions.py def sync_native ( params : SyncNativeParams ) -> Instruction : \"\"\"Syncs the amount field with the number of lamports of the account. Example: >>> account = Pubkey.default() >>> params = SyncNativeParams( ... program_id=TOKEN_PROGRAM_ID, account=account, ... ) >>> type(sync_native(params)) <class 'solders.instruction.Instruction'> Returns: The sync-native instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . SYNC_NATIVE , \"args\" : {}, } ) return __sync_native_instruction ( params , data ) thaw_account ( params ) Creates a transaction instruction to thaw a frozen account using the Mint's freeze_authority (if set). Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , authority , token = pubkeys >>> params = ThawAccountParams ( ... account = account , mint = mint , authority = authority , program_id = token ) >>> type ( thaw_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The thaw-account instruction. Source code in spl/token/instructions.py def thaw_account ( params : ThawAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to thaw a frozen account using the Mint's freeze_authority (if set). Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, authority, token = pubkeys >>> params = ThawAccountParams( ... account=account, mint=mint, authority=authority, program_id=token) >>> type(thaw_account(params)) <class 'solders.instruction.Instruction'> Returns: The thaw-account instruction. \"\"\" return __freeze_or_thaw_instruction ( params , InstructionType . THAW_ACCOUNT ) transfer ( params ) Creates a transaction instruction to transfers tokens from one account to another. Either directly or via a delegate. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> dest , owner , source , token = pubkeys >>> params = TransferParams ( ... amount = 1000 , ... dest = dest , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( transfer ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The transfer instruction. Source code in spl/token/instructions.py def transfer ( params : TransferParams ) -> Instruction : \"\"\"Creates a transaction instruction to transfers tokens from one account to another. Either directly or via a delegate. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> dest, owner, source, token = pubkeys >>> params = TransferParams( ... amount=1000, ... dest=dest, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(transfer(params)) <class 'solders.instruction.Instruction'> Returns: The transfer instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . TRANSFER , \"args\" : { \"amount\" : params . amount }, } ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data ) transfer_checked ( params ) This instruction differs from transfer in that the token mint and decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 5 )] >>> dest , mint , owner , source , token = pubkeys >>> params = TransferCheckedParams ( ... amount = 1000 , ... decimals = 6 , ... dest = dest , ... mint = mint , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( transfer_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The transfer-checked instruction. Source code in spl/token/instructions.py def transfer_checked ( params : TransferCheckedParams ) -> Instruction : \"\"\"This instruction differs from `transfer` in that the token mint and decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(5)] >>> dest, mint, owner, source, token = pubkeys >>> params = TransferCheckedParams( ... amount=1000, ... decimals=6, ... dest=dest, ... mint=mint, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(transfer_checked(params)) <class 'solders.instruction.Instruction'> Returns: The transfer-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . TRANSFER2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"Instructions"},{"location":"spl/token/instructions/#instructions","text":"","title":"Instructions"},{"location":"spl/token/instructions/#spl.token.instructions","text":"SPL token instructions.","title":"instructions"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams","text":"ApproveChecked token transaction params. Source code in spl/token/instructions.py class ApproveCheckedParams ( NamedTuple ): \"\"\"ApproveChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" delegate : Pubkey \"\"\"Delegate account authorized to perform a transfer of tokens from the source account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Maximum number of tokens the delegate may transfer.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"ApproveCheckedParams"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.amount","text":"Maximum number of tokens the delegate may transfer.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.decimals","text":"Amount decimals.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.delegate","text":"Delegate account authorized to perform a transfer of tokens from the source account.","title":"delegate"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveCheckedParams.source","text":"Source account.","title":"source"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams","text":"Approve token transaction params. Source code in spl/token/instructions.py class ApproveParams ( NamedTuple ): \"\"\"Approve token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" delegate : Pubkey \"\"\"Delegate account authorized to perform a transfer of tokens from the source account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Maximum number of tokens the delegate may transfer.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"ApproveParams"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.amount","text":"Maximum number of tokens the delegate may transfer.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.delegate","text":"Delegate account authorized to perform a transfer of tokens from the source account.","title":"delegate"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.ApproveParams.source","text":"Source account.","title":"source"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType","text":"Specifies the authority type for SetAuthority instructions. Source code in spl/token/instructions.py class AuthorityType ( IntEnum ): \"\"\"Specifies the authority type for SetAuthority instructions.\"\"\" MINT_TOKENS = 0 \"\"\"\"Authority to mint new tokens.\"\"\" FREEZE_ACCOUNT = 1 \"\"\"Authority to freeze any account associated with the Mint.\"\"\" ACCOUNT_OWNER = 2 \"\"\"Owner of a given token account.\"\"\" CLOSE_ACCOUNT = 3 \"\"\"Authority to close a token account.\"\"\"","title":"AuthorityType"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType.ACCOUNT_OWNER","text":"Owner of a given token account.","title":"ACCOUNT_OWNER"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType.CLOSE_ACCOUNT","text":"Authority to close a token account.","title":"CLOSE_ACCOUNT"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType.FREEZE_ACCOUNT","text":"Authority to freeze any account associated with the Mint.","title":"FREEZE_ACCOUNT"},{"location":"spl/token/instructions/#spl.token.instructions.AuthorityType.MINT_TOKENS","text":"\"Authority to mint new tokens.","title":"MINT_TOKENS"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams","text":"BurnChecked token transaction params. Source code in spl/token/instructions.py class BurnCheckedParams ( NamedTuple ): \"\"\"BurnChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" account : Pubkey \"\"\"Account to burn tokens from.\"\"\" owner : Pubkey \"\"\"Owner of the account.\"\"\" amount : int \"\"\"Amount to burn.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\"","title":"BurnCheckedParams"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.account","text":"Account to burn tokens from.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.amount","text":"Amount to burn.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.decimals","text":"Amount decimals.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.owner","text":"Owner of the account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.BurnCheckedParams.signers","text":"Signing accounts if owner is a multiSig","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams","text":"Burn token transaction params. Source code in spl/token/instructions.py class BurnParams ( NamedTuple ): \"\"\"Burn token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to burn tokens from.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" owner : Pubkey \"\"\"Owner of the account.\"\"\" amount : int \"\"\"Amount to burn.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\"","title":"BurnParams"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.account","text":"Account to burn tokens from.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.amount","text":"Amount to burn.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.owner","text":"Owner of the account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.BurnParams.signers","text":"Signing accounts if owner is a multiSig","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams","text":"Close token account transaction params. Source code in spl/token/instructions.py class CloseAccountParams ( NamedTuple ): \"\"\"Close token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Address of account to close.\"\"\" dest : Pubkey \"\"\"Address of account to receive the remaining balance of the closed account.\"\"\" owner : Pubkey \"\"\"Owner of the account.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig\"\"\"","title":"CloseAccountParams"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.account","text":"Address of account to close.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.dest","text":"Address of account to receive the remaining balance of the closed account.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.owner","text":"Owner of the account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.CloseAccountParams.signers","text":"Signing accounts if owner is a multiSig","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams","text":"Freeze token account transaction params. Source code in spl/token/instructions.py class FreezeAccountParams ( NamedTuple ): \"\"\"Freeze token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to freeze.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" authority : Pubkey \"\"\"Mint freeze authority\"\"\" multi_signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `authority` is a multiSig\"\"\"","title":"FreezeAccountParams"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.account","text":"Account to freeze.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.authority","text":"Mint freeze authority","title":"authority"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.multi_signers","text":"Signing accounts if authority is a multiSig","title":"multi_signers"},{"location":"spl/token/instructions/#spl.token.instructions.FreezeAccountParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams","text":"Initialize token account transaction params. Source code in spl/token/instructions.py class InitializeAccountParams ( NamedTuple ): \"\"\"Initialize token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Public key of the new account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" owner : Pubkey \"\"\"Owner of the new account.\"\"\"","title":"InitializeAccountParams"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.account","text":"Public key of the new account.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.owner","text":"Owner of the new account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeAccountParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams","text":"Initialize token mint transaction params. Source code in spl/token/instructions.py class InitializeMintParams ( NamedTuple ): \"\"\"Initialize token mint transaction params.\"\"\" decimals : int \"\"\"Number of base 10 digits to the right of the decimal place.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" mint_authority : Pubkey \"\"\"The authority/multisignature to mint tokens.\"\"\" freeze_authority : Optional [ Pubkey ] = None \"\"\"The freeze authority/multisignature of the mint.\"\"\"","title":"InitializeMintParams"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.decimals","text":"Number of base 10 digits to the right of the decimal place.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.freeze_authority","text":"The freeze authority/multisignature of the mint.","title":"freeze_authority"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.mint_authority","text":"The authority/multisignature to mint tokens.","title":"mint_authority"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMintParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams","text":"Initialize multisig token account transaction params. Source code in spl/token/instructions.py class InitializeMultisigParams ( NamedTuple ): \"\"\"Initialize multisig token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" multisig : Pubkey \"\"\"New multisig account address.\"\"\" m : int \"\"\"The number of signers (M) required to validate this multisignature account.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Addresses of multisig signers.\"\"\"","title":"InitializeMultisigParams"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.m","text":"The number of signers (M) required to validate this multisignature account.","title":"m"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.multisig","text":"New multisig account address.","title":"multisig"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.InitializeMultisigParams.signers","text":"Addresses of multisig signers.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams","text":"MintToChecked token transaction params. Source code in spl/token/instructions.py class MintToCheckedParams ( NamedTuple ): \"\"\"MintToChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" dest : Pubkey \"\"\"Public key of the account to mint to.\"\"\" mint_authority : Pubkey \"\"\"The mint authority.\"\"\" amount : int \"\"\"Amount to mint.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `mint_authority` is a multiSig.\"\"\"","title":"MintToCheckedParams"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.amount","text":"Amount to mint.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.decimals","text":"Amount decimals.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.dest","text":"Public key of the account to mint to.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.mint_authority","text":"The mint authority.","title":"mint_authority"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.MintToCheckedParams.signers","text":"Signing accounts if mint_authority is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams","text":"Mint token transaction params. Source code in spl/token/instructions.py class MintToParams ( NamedTuple ): \"\"\"Mint token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" dest : Pubkey \"\"\"Public key of the account to mint to.\"\"\" mint_authority : Pubkey \"\"\"The mint authority.\"\"\" amount : int \"\"\"Amount to mint.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `mint_authority` is a multiSig.\"\"\"","title":"MintToParams"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.amount","text":"Amount to mint.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.dest","text":"Public key of the account to mint to.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.mint_authority","text":"The mint authority.","title":"mint_authority"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.MintToParams.signers","text":"Signing accounts if mint_authority is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams","text":"Revoke token transaction params. Source code in spl/token/instructions.py class RevokeParams ( NamedTuple ): \"\"\"Revoke token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Source account for which transfer authority is being revoked.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"RevokeParams"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.account","text":"Source account for which transfer authority is being revoked.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.RevokeParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams","text":"Set token authority transaction params. Source code in spl/token/instructions.py class SetAuthorityParams ( NamedTuple ): \"\"\"Set token authority transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Public key of the token account.\"\"\" authority : AuthorityType \"\"\"The type of authority to update.\"\"\" current_authority : Pubkey \"\"\"Current authority of the specified type.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `current_authority` is a multiSig.\"\"\" new_authority : Optional [ Pubkey ] = None \"\"\"New authority of the account.\"\"\"","title":"SetAuthorityParams"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.account","text":"Public key of the token account.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.authority","text":"The type of authority to update.","title":"authority"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.current_authority","text":"Current authority of the specified type.","title":"current_authority"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.new_authority","text":"New authority of the account.","title":"new_authority"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.SetAuthorityParams.signers","text":"Signing accounts if current_authority is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.SyncNativeParams","text":"BurnChecked token transaction params. Source code in spl/token/instructions.py class SyncNativeParams ( NamedTuple ): \"\"\"BurnChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to sync.\"\"\"","title":"SyncNativeParams"},{"location":"spl/token/instructions/#spl.token.instructions.SyncNativeParams.account","text":"Account to sync.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.SyncNativeParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams","text":"Thaw token account transaction params. Source code in spl/token/instructions.py class ThawAccountParams ( NamedTuple ): \"\"\"Thaw token account transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" account : Pubkey \"\"\"Account to thaw.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" authority : Pubkey \"\"\"Mint freeze authority\"\"\" multi_signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `authority` is a multiSig\"\"\"","title":"ThawAccountParams"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.account","text":"Account to thaw.","title":"account"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.authority","text":"Mint freeze authority","title":"authority"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.multi_signers","text":"Signing accounts if authority is a multiSig","title":"multi_signers"},{"location":"spl/token/instructions/#spl.token.instructions.ThawAccountParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams","text":"TransferChecked token transaction params. Source code in spl/token/instructions.py class TransferCheckedParams ( NamedTuple ): \"\"\"TransferChecked token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" mint : Pubkey \"\"\"Public key of the minter account.\"\"\" dest : Pubkey \"\"\"Destination account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Number of tokens to transfer.\"\"\" decimals : int \"\"\"Amount decimals.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"TransferCheckedParams"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.amount","text":"Number of tokens to transfer.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.decimals","text":"Amount decimals.","title":"decimals"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.dest","text":"Destination account.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.mint","text":"Public key of the minter account.","title":"mint"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.TransferCheckedParams.source","text":"Source account.","title":"source"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams","text":"Transfer token transaction params. Source code in spl/token/instructions.py class TransferParams ( NamedTuple ): \"\"\"Transfer token transaction params.\"\"\" program_id : Pubkey \"\"\"SPL Token program account.\"\"\" source : Pubkey \"\"\"Source account.\"\"\" dest : Pubkey \"\"\"Destination account.\"\"\" owner : Pubkey \"\"\"Owner of the source account.\"\"\" amount : int \"\"\"Number of tokens to transfer.\"\"\" signers : List [ Pubkey ] = [] \"\"\"Signing accounts if `owner` is a multiSig.\"\"\"","title":"TransferParams"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.amount","text":"Number of tokens to transfer.","title":"amount"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.dest","text":"Destination account.","title":"dest"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.owner","text":"Owner of the source account.","title":"owner"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.program_id","text":"SPL Token program account.","title":"program_id"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.signers","text":"Signing accounts if owner is a multiSig.","title":"signers"},{"location":"spl/token/instructions/#spl.token.instructions.TransferParams.source","text":"Source account.","title":"source"},{"location":"spl/token/instructions/#spl.token.instructions.approve","text":"Creates a transaction instruction to approve a delegate. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> delegate , owner , source , token = pubkeys >>> params = ApproveParams ( ... amount = 123 , ... delegate = delegate , ... owner = owner , ... program_id = token , ... source = source ... ) >>> type ( approve ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The approve instruction. Source code in spl/token/instructions.py def approve ( params : ApproveParams ) -> Instruction : \"\"\"Creates a transaction instruction to approve a delegate. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> delegate, owner, source, token = pubkeys >>> params = ApproveParams( ... amount=123, ... delegate=delegate, ... owner=owner, ... program_id=token, ... source=source ... ) >>> type(approve(params)) <class 'solders.instruction.Instruction'> Returns: The approve instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . APPROVE , \"args\" : { \"amount\" : params . amount }}) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . delegate , is_signer = False , is_writable = False ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"approve()"},{"location":"spl/token/instructions/#spl.token.instructions.approve_checked","text":"This instruction differs from approve in that the token mint and decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 5 )] >>> delegate , mint , owner , source , token = pubkeys >>> params = ApproveCheckedParams ( ... amount = 1000 , ... decimals = 6 , ... delegate = delegate , ... mint = mint , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( approve_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The approve-checked instruction. Source code in spl/token/instructions.py def approve_checked ( params : ApproveCheckedParams ) -> Instruction : \"\"\"This instruction differs from `approve` in that the token mint and decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(5)] >>> delegate, mint, owner, source, token = pubkeys >>> params = ApproveCheckedParams( ... amount=1000, ... decimals=6, ... delegate=delegate, ... mint=mint, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(approve_checked(params)) <class 'solders.instruction.Instruction'> Returns: The approve-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . APPROVE2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . delegate , is_signer = False , is_writable = False ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"approve_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.burn","text":"Creates a transaction instruction to burns tokens by removing them from an account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , owner , token = pubkeys >>> params = BurnParams ( ... amount = 123 , account = account , mint = mint , owner = owner , program_id = token , ... ) >>> type ( burn ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The burn instruction. Source code in spl/token/instructions.py def burn ( params : BurnParams ) -> Instruction : \"\"\"Creates a transaction instruction to burns tokens by removing them from an account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, owner, token = pubkeys >>> params = BurnParams( ... amount=123, account=account, mint=mint, owner=owner, program_id=token, ... ) >>> type(burn(params)) <class 'solders.instruction.Instruction'> Returns: The burn instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . BURN , \"args\" : { \"amount\" : params . amount }}) return __burn_instruction ( params , data )","title":"burn()"},{"location":"spl/token/instructions/#spl.token.instructions.burn_checked","text":"This instruction differs from burn in that the decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , owner , token = pubkeys >>> params = BurnCheckedParams ( ... amount = 123 , account = account , decimals = 6 , mint = mint , owner = owner , program_id = token , ... ) >>> type ( burn_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The burn-checked instruction. Source code in spl/token/instructions.py def burn_checked ( params : BurnCheckedParams ) -> Instruction : \"\"\"This instruction differs from `burn` in that the decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, owner, token = pubkeys >>> params = BurnCheckedParams( ... amount=123, account=account, decimals=6, mint=mint, owner=owner, program_id=token, ... ) >>> type(burn_checked(params)) <class 'solders.instruction.Instruction'> Returns: The burn-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . BURN2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) return __burn_instruction ( params , data )","title":"burn_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.close_account","text":"Creates a transaction instruction to close an account by transferring all its SOL to the destination account. Non-native accounts may only be closed if its token amount is zero. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , dest , owner , token = pubkeys >>> params = CloseAccountParams ( ... account = account , dest = dest , owner = owner , program_id = token ) >>> type ( close_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The close-account instruction. Source code in spl/token/instructions.py def close_account ( params : CloseAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to close an account by transferring all its SOL to the destination account. Non-native accounts may only be closed if its token amount is zero. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, dest, owner, token = pubkeys >>> params = CloseAccountParams( ... account=account, dest=dest, owner=owner, program_id=token) >>> type(close_account(params)) <class 'solders.instruction.Instruction'> Returns: The close-account instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . CLOSE_ACCOUNT , \"args\" : None }) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"close_account()"},{"location":"spl/token/instructions/#spl.token.instructions.create_associated_token_account","text":"Creates a transaction instruction to create an associated token account. Returns: Type Description Instruction The instruction to create the associated token account. Source code in spl/token/instructions.py def create_associated_token_account ( payer : Pubkey , owner : Pubkey , mint : Pubkey ) -> Instruction : \"\"\"Creates a transaction instruction to create an associated token account. Returns: The instruction to create the associated token account. \"\"\" associated_token_address = get_associated_token_address ( owner , mint ) return Instruction ( accounts = [ AccountMeta ( pubkey = payer , is_signer = True , is_writable = True ), AccountMeta ( pubkey = associated_token_address , is_signer = False , is_writable = True ), AccountMeta ( pubkey = owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = SYS_PROGRAM_ID , is_signer = False , is_writable = False ), AccountMeta ( pubkey = TOKEN_PROGRAM_ID , is_signer = False , is_writable = False ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ], program_id = ASSOCIATED_TOKEN_PROGRAM_ID , data = bytes ( 0 ), )","title":"create_associated_token_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_approve","text":"Decode a approve token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description ApproveParams The decoded instruction. Source code in spl/token/instructions.py def decode_approve ( instruction : Instruction ) -> ApproveParams : \"\"\"Decode a approve token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . APPROVE ) return ApproveParams ( program_id = instruction . program_id , source = instruction . accounts [ 0 ] . pubkey , delegate = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], amount = parsed_data . args . amount , )","title":"decode_approve()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_approve_checked","text":"Decode a approve_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description ApproveCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_approve_checked ( instruction : Instruction ) -> ApproveCheckedParams : \"\"\"Decode a approve_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 4 , InstructionType . APPROVE2 ) return ApproveCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , source = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , delegate = instruction . accounts [ 2 ] . pubkey , owner = instruction . accounts [ 3 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 4 :]], )","title":"decode_approve_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_burn","text":"Decode a burn token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description BurnParams The decoded instruction. Source code in spl/token/instructions.py def decode_burn ( instruction : Instruction ) -> BurnParams : \"\"\"Decode a burn token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . BURN ) return BurnParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_burn()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_burn_checked","text":"Decode a burn_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description BurnCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_burn_checked ( instruction : Instruction ) -> BurnCheckedParams : \"\"\"Decode a burn_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . BURN2 ) return BurnCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_burn_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_close_account","text":"Decode a close account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description CloseAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_close_account ( instruction : Instruction ) -> CloseAccountParams : \"\"\"Decode a close account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . CLOSE_ACCOUNT ) return CloseAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_close_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_freeze_account","text":"Decode a freeze account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description FreezeAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_freeze_account ( instruction : Instruction ) -> FreezeAccountParams : \"\"\"Decode a freeze account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . FREEZE_ACCOUNT ) return FreezeAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , authority = instruction . accounts [ 2 ] . pubkey , multi_signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_freeze_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_initialize_account","text":"Decode an initialize account token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description InitializeAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_account ( instruction : Instruction ) -> InitializeAccountParams : \"\"\"Decode an initialize account token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 4 , InstructionType . INITIALIZE_ACCOUNT ) return InitializeAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , )","title":"decode_initialize_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_initialize_mint","text":"Decode an initialize mint token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description InitializeMintParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_mint ( instruction : Instruction ) -> InitializeMintParams : \"\"\"Decode an initialize mint token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . INITIALIZE_MINT ) return InitializeMintParams ( decimals = parsed_data . args . decimals , program_id = instruction . program_id , mint = instruction . accounts [ 0 ] . pubkey , mint_authority = Pubkey ( parsed_data . args . mint_authority ), freeze_authority = Pubkey ( parsed_data . args . freeze_authority ) if parsed_data . args . freeze_authority_option else None , )","title":"decode_initialize_mint()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_initialize_multisig","text":"Decode an initialize multisig account token instruction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description InitializeMultisigParams The decoded instruction. Source code in spl/token/instructions.py def decode_initialize_multisig ( instruction : Instruction ) -> InitializeMultisigParams : \"\"\"Decode an initialize multisig account token instruction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . INITIALIZE_MULTISIG ) num_signers = parsed_data . args . m validate_instruction_keys ( instruction , 2 + num_signers ) return InitializeMultisigParams ( program_id = instruction . program_id , multisig = instruction . accounts [ 0 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ - num_signers :]], m = num_signers , )","title":"decode_initialize_multisig()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_mint_to","text":"Decode a mint to token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description MintToParams The decoded instruction. Source code in spl/token/instructions.py def decode_mint_to ( instruction : Instruction ) -> MintToParams : \"\"\"Decode a mint to token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . MINT_TO ) return MintToParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , mint = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , mint_authority = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_mint_to()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_mint_to_checked","text":"Decode a mintTo2 token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description MintToCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_mint_to_checked ( instruction : Instruction ) -> MintToCheckedParams : \"\"\"Decode a mintTo2 token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . MINT_TO2 ) return MintToCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , mint = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , mint_authority = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_mint_to_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_revoke","text":"Decode a revoke token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description RevokeParams The decoded instruction. Source code in spl/token/instructions.py def decode_revoke ( instruction : Instruction ) -> RevokeParams : \"\"\"Decode a revoke token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 2 , InstructionType . REVOKE ) return RevokeParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , owner = instruction . accounts [ 1 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 2 :]], )","title":"decode_revoke()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_set_authority","text":"Decode a set authority token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description SetAuthorityParams The decoded instruction. Source code in spl/token/instructions.py def decode_set_authority ( instruction : Instruction ) -> SetAuthorityParams : \"\"\"Decode a set authority token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 2 , InstructionType . SET_AUTHORITY ) return SetAuthorityParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , authority = AuthorityType ( parsed_data . args . authority_type ), new_authority = Pubkey ( parsed_data . args . new_authority ) if parsed_data . args . new_authority_option else None , current_authority = instruction . accounts [ 1 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 2 :]], )","title":"decode_set_authority()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_sync_native","text":"Decode a burn_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description SyncNativeParams The decoded instruction. Source code in spl/token/instructions.py def decode_sync_native ( instruction : Instruction ) -> SyncNativeParams : \"\"\"Decode a burn_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" return SyncNativeParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , )","title":"decode_sync_native()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_thaw_account","text":"Decode a thaw account token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description ThawAccountParams The decoded instruction. Source code in spl/token/instructions.py def decode_thaw_account ( instruction : Instruction ) -> ThawAccountParams : \"\"\"Decode a thaw account token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" _ = __parse_and_validate_instruction ( instruction , 3 , InstructionType . THAW_ACCOUNT ) return ThawAccountParams ( program_id = instruction . program_id , account = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , authority = instruction . accounts [ 2 ] . pubkey , multi_signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], )","title":"decode_thaw_account()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_transfer","text":"Decode a transfer token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description TransferParams The decoded instruction. Source code in spl/token/instructions.py def decode_transfer ( instruction : Instruction ) -> TransferParams : \"\"\"Decode a transfer token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 3 , InstructionType . TRANSFER ) return TransferParams ( program_id = instruction . program_id , source = instruction . accounts [ 0 ] . pubkey , dest = instruction . accounts [ 1 ] . pubkey , owner = instruction . accounts [ 2 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 3 :]], amount = parsed_data . args . amount , )","title":"decode_transfer()"},{"location":"spl/token/instructions/#spl.token.instructions.decode_transfer_checked","text":"Decode a transfer_checked token transaction and retrieve the instruction params. Parameters: Name Type Description Default instruction Instruction The instruction to decode. required Returns: Type Description TransferCheckedParams The decoded instruction. Source code in spl/token/instructions.py def decode_transfer_checked ( instruction : Instruction ) -> TransferCheckedParams : \"\"\"Decode a transfer_checked token transaction and retrieve the instruction params. Args: instruction: The instruction to decode. Returns: The decoded instruction. \"\"\" parsed_data = __parse_and_validate_instruction ( instruction , 4 , InstructionType . TRANSFER2 ) return TransferCheckedParams ( program_id = instruction . program_id , amount = parsed_data . args . amount , decimals = parsed_data . args . decimals , source = instruction . accounts [ 0 ] . pubkey , mint = instruction . accounts [ 1 ] . pubkey , dest = instruction . accounts [ 2 ] . pubkey , owner = instruction . accounts [ 3 ] . pubkey , signers = [ signer . pubkey for signer in instruction . accounts [ 4 :]], )","title":"decode_transfer_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.freeze_account","text":"Creates a transaction instruction to freeze an initialized account using the mint's freeze_authority (if set). Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , authority , token = pubkeys >>> params = FreezeAccountParams ( ... account = account , mint = mint , authority = authority , program_id = token ) >>> type ( freeze_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The freeze-account instruction. Source code in spl/token/instructions.py def freeze_account ( params : FreezeAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to freeze an initialized account using the mint's freeze_authority (if set). Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, authority, token = pubkeys >>> params = FreezeAccountParams( ... account=account, mint=mint, authority=authority, program_id=token) >>> type(freeze_account(params)) <class 'solders.instruction.Instruction'> Returns: The freeze-account instruction. \"\"\" return __freeze_or_thaw_instruction ( params , InstructionType . FREEZE_ACCOUNT )","title":"freeze_account()"},{"location":"spl/token/instructions/#spl.token.instructions.get_associated_token_address","text":"Derives the associated token address for the given wallet address and token mint. Returns: Type Description Pubkey The public key of the derived associated token address. Source code in spl/token/instructions.py def get_associated_token_address ( owner : Pubkey , mint : Pubkey ) -> Pubkey : \"\"\"Derives the associated token address for the given wallet address and token mint. Returns: The public key of the derived associated token address. \"\"\" key , _ = Pubkey . find_program_address ( seeds = [ bytes ( owner ), bytes ( TOKEN_PROGRAM_ID ), bytes ( mint )], program_id = ASSOCIATED_TOKEN_PROGRAM_ID , ) return key","title":"get_associated_token_address()"},{"location":"spl/token/instructions/#spl.token.instructions.initialize_account","text":"Creates a transaction instruction to initialize a new account to hold tokens. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , owner , token = pubkeys >>> params = InitializeAccountParams ( ... account = account , ... mint = mint , ... owner = owner , ... program_id = token , ... ) >>> type ( initialize_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to initialize the account. Source code in spl/token/instructions.py def initialize_account ( params : InitializeAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to initialize a new account to hold tokens. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, owner, token = pubkeys >>> params = InitializeAccountParams( ... account=account, ... mint=mint, ... owner=owner, ... program_id=token, ... ) >>> type(initialize_account(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to initialize the account. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . INITIALIZE_ACCOUNT , \"args\" : None }) return Instruction ( accounts = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . owner , is_signer = False , is_writable = False ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ], program_id = params . program_id , data = data , )","title":"initialize_account()"},{"location":"spl/token/instructions/#spl.token.instructions.initialize_mint","text":"Creates a transaction instruction to initialize a new mint newly. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> from spl.token.constants import TOKEN_PROGRAM_ID >>> from solders.pubkey import Pubkey >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> mint_account , mint_authority , freeze_authority , owner = pubkeys >>> params = InitializeMintParams ( ... decimals = 6 , ... freeze_authority = freeze_authority , ... mint = mint_account , ... mint_authority = mint_authority , ... program_id = TOKEN_PROGRAM_ID , ... ) >>> type ( initialize_mint ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to initialize the mint. Source code in spl/token/instructions.py def initialize_mint ( params : InitializeMintParams ) -> Instruction : \"\"\"Creates a transaction instruction to initialize a new mint newly. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> from spl.token.constants import TOKEN_PROGRAM_ID >>> from solders.pubkey import Pubkey >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i +1]) for i in range(4)] >>> mint_account, mint_authority, freeze_authority, owner = pubkeys >>> params = InitializeMintParams( ... decimals=6, ... freeze_authority=freeze_authority, ... mint=mint_account, ... mint_authority=mint_authority, ... program_id=TOKEN_PROGRAM_ID, ... ) >>> type(initialize_mint(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to initialize the mint. \"\"\" freeze_authority , opt = ( params . freeze_authority , 1 ) if params . freeze_authority else ( Pubkey ([ 0 ] * 31 + [ 0 ]), 0 ) data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . INITIALIZE_MINT , \"args\" : { \"decimals\" : params . decimals , \"mint_authority\" : bytes ( params . mint_authority ), \"freeze_authority_option\" : opt , \"freeze_authority\" : bytes ( freeze_authority ), }, } ) return Instruction ( accounts = [ AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = True ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ], program_id = params . program_id , data = data , )","title":"initialize_mint()"},{"location":"spl/token/instructions/#spl.token.instructions.initialize_multisig","text":"Creates a transaction instruction to initialize a multisignature account with N provided signers. This instruction requires no signers and MUST be included within the same Transaction as the system program's CreateInstruction that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Examples: >>> m = 2 # Two signers >>> signers = [ Pubkey ([ 0 ] * 31 + [ i ]) for i in range ( m )] >>> leading_zeros = [ 0 ] * 31 >>> multisig_account , token = Pubkey ( leading_zeros + [ 1 ]), Pubkey ( leading_zeros + [ 2 ]) >>> params = InitializeMultisigParams ( ... m = m , ... multisig = multisig_account , ... signers = signers , ... program_id = token , ... ) >>> type ( initialize_multisig ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The instruction to initialize the multisig. Source code in spl/token/instructions.py def initialize_multisig ( params : InitializeMultisigParams ) -> Instruction : \"\"\"Creates a transaction instruction to initialize a multisignature account with N provided signers. This instruction requires no signers and MUST be included within the same Transaction as the system program's `CreateInstruction` that creates the account being initialized. Otherwise another party can acquire ownership of the uninitialized account. Example: >>> m = 2 # Two signers >>> signers = [Pubkey([0] * 31 + [i]) for i in range(m)] >>> leading_zeros = [0] * 31 >>> multisig_account, token = Pubkey(leading_zeros + [1]), Pubkey(leading_zeros + [2]) >>> params = InitializeMultisigParams( ... m=m, ... multisig=multisig_account, ... signers=signers, ... program_id=token, ... ) >>> type(initialize_multisig(params)) <class 'solders.instruction.Instruction'> Returns: The instruction to initialize the multisig. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . INITIALIZE_MULTISIG , \"args\" : { \"m\" : params . m }, } ) keys = [ AccountMeta ( pubkey = params . multisig , is_signer = False , is_writable = True ), AccountMeta ( pubkey = RENT , is_signer = False , is_writable = False ), ] for signer in params . signers : keys . append ( AccountMeta ( pubkey = signer , is_signer = False , is_writable = False )) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"initialize_multisig()"},{"location":"spl/token/instructions/#spl.token.instructions.mint_to","text":"Creates a transaction instruction to mint new tokens to an account. The native mint does not support minting. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> dest , mint , mint_authority , token = pubkeys >>> params = MintToParams ( ... amount = 123 , ... dest = dest , ... mint = mint , ... mint_authority = mint_authority , ... program_id = token , ... ) >>> type ( mint_to ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The mint-to instruction. Source code in spl/token/instructions.py def mint_to ( params : MintToParams ) -> Instruction : \"\"\"Creates a transaction instruction to mint new tokens to an account. The native mint does not support minting. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> dest, mint, mint_authority, token = pubkeys >>> params = MintToParams( ... amount=123, ... dest=dest, ... mint=mint, ... mint_authority=mint_authority, ... program_id=token, ... ) >>> type(mint_to(params)) <class 'solders.instruction.Instruction'> Returns: The mint-to instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . MINT_TO , \"args\" : { \"amount\" : params . amount }}) return __mint_to_instruction ( params , data )","title":"mint_to()"},{"location":"spl/token/instructions/#spl.token.instructions.mint_to_checked","text":"This instruction differs from mint_to in that the decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> dest , mint , mint_authority , token = pubkeys >>> params = MintToCheckedParams ( ... amount = 123 , ... decimals = 6 , ... dest = dest , ... mint = mint , ... mint_authority = mint_authority , ... program_id = token , ... ) >>> type ( mint_to_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The mint-to-checked instruction. Source code in spl/token/instructions.py def mint_to_checked ( params : MintToCheckedParams ) -> Instruction : \"\"\"This instruction differs from `mint_to` in that the decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> dest, mint, mint_authority, token = pubkeys >>> params = MintToCheckedParams( ... amount=123, ... decimals=6, ... dest=dest, ... mint=mint, ... mint_authority=mint_authority, ... program_id=token, ... ) >>> type(mint_to_checked(params)) <class 'solders.instruction.Instruction'> Returns: The mint-to-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . MINT_TO2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) return __mint_to_instruction ( params , data )","title":"mint_to_checked()"},{"location":"spl/token/instructions/#spl.token.instructions.revoke","text":"Creates a transaction instruction that revokes delegate authority for a given account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 3 )] >>> account , owner , token = pubkeys >>> params = RevokeParams ( ... account = account , owner = owner , program_id = token ... ) >>> type ( revoke ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The revoke instruction. Source code in spl/token/instructions.py def revoke ( params : RevokeParams ) -> Instruction : \"\"\"Creates a transaction instruction that revokes delegate authority for a given account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(3)] >>> account, owner, token = pubkeys >>> params = RevokeParams( ... account=account, owner=owner, program_id=token ... ) >>> type(revoke(params)) <class 'solders.instruction.Instruction'> Returns: The revoke instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ({ \"instruction_type\" : InstructionType . REVOKE , \"args\" : None }) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True )] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"revoke()"},{"location":"spl/token/instructions/#spl.token.instructions.set_authority","text":"Creates a transaction instruction to sets a new authority of a mint or account. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , current_authority , new_authority , token = pubkeys >>> params = SetAuthorityParams ( ... account = account , ... authority = AuthorityType . ACCOUNT_OWNER , ... current_authority = current_authority , ... new_authority = new_authority , ... program_id = token , ... ) >>> type ( set_authority ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The set authority instruction. Source code in spl/token/instructions.py def set_authority ( params : SetAuthorityParams ) -> Instruction : \"\"\"Creates a transaction instruction to sets a new authority of a mint or account. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, current_authority, new_authority, token = pubkeys >>> params = SetAuthorityParams( ... account=account, ... authority=AuthorityType.ACCOUNT_OWNER, ... current_authority=current_authority, ... new_authority=new_authority, ... program_id=token, ... ) >>> type(set_authority(params)) <class 'solders.instruction.Instruction'> Returns: The set authority instruction. \"\"\" new_authority , opt = ( params . new_authority , 1 ) if params . new_authority else ( Pubkey ([ 0 ] * 31 + [ 0 ]), 0 ) data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . SET_AUTHORITY , \"args\" : { \"authority_type\" : params . authority , \"new_authority_option\" : opt , \"new_authority\" : bytes ( new_authority ), }, } ) keys = [ AccountMeta ( pubkey = params . account , is_signer = False , is_writable = True )] __add_signers ( keys , params . current_authority , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"set_authority()"},{"location":"spl/token/instructions/#spl.token.instructions.sync_native","text":"Syncs the amount field with the number of lamports of the account. Examples: >>> account = Pubkey . default () >>> params = SyncNativeParams ( ... program_id = TOKEN_PROGRAM_ID , account = account , ... ) >>> type ( sync_native ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The sync-native instruction. Source code in spl/token/instructions.py def sync_native ( params : SyncNativeParams ) -> Instruction : \"\"\"Syncs the amount field with the number of lamports of the account. Example: >>> account = Pubkey.default() >>> params = SyncNativeParams( ... program_id=TOKEN_PROGRAM_ID, account=account, ... ) >>> type(sync_native(params)) <class 'solders.instruction.Instruction'> Returns: The sync-native instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . SYNC_NATIVE , \"args\" : {}, } ) return __sync_native_instruction ( params , data )","title":"sync_native()"},{"location":"spl/token/instructions/#spl.token.instructions.thaw_account","text":"Creates a transaction instruction to thaw a frozen account using the Mint's freeze_authority (if set). Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> account , mint , authority , token = pubkeys >>> params = ThawAccountParams ( ... account = account , mint = mint , authority = authority , program_id = token ) >>> type ( thaw_account ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The thaw-account instruction. Source code in spl/token/instructions.py def thaw_account ( params : ThawAccountParams ) -> Instruction : \"\"\"Creates a transaction instruction to thaw a frozen account using the Mint's freeze_authority (if set). Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> account, mint, authority, token = pubkeys >>> params = ThawAccountParams( ... account=account, mint=mint, authority=authority, program_id=token) >>> type(thaw_account(params)) <class 'solders.instruction.Instruction'> Returns: The thaw-account instruction. \"\"\" return __freeze_or_thaw_instruction ( params , InstructionType . THAW_ACCOUNT )","title":"thaw_account()"},{"location":"spl/token/instructions/#spl.token.instructions.transfer","text":"Creates a transaction instruction to transfers tokens from one account to another. Either directly or via a delegate. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 4 )] >>> dest , owner , source , token = pubkeys >>> params = TransferParams ( ... amount = 1000 , ... dest = dest , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( transfer ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The transfer instruction. Source code in spl/token/instructions.py def transfer ( params : TransferParams ) -> Instruction : \"\"\"Creates a transaction instruction to transfers tokens from one account to another. Either directly or via a delegate. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(4)] >>> dest, owner, source, token = pubkeys >>> params = TransferParams( ... amount=1000, ... dest=dest, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(transfer(params)) <class 'solders.instruction.Instruction'> Returns: The transfer instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . TRANSFER , \"args\" : { \"amount\" : params . amount }, } ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"transfer()"},{"location":"spl/token/instructions/#spl.token.instructions.transfer_checked","text":"This instruction differs from transfer in that the token mint and decimals value is asserted by the caller. Examples: >>> leading_zeros = [ 0 ] * 31 >>> pubkeys = [ Pubkey ( leading_zeros + [ i + 1 ]) for i in range ( 5 )] >>> dest , mint , owner , source , token = pubkeys >>> params = TransferCheckedParams ( ... amount = 1000 , ... decimals = 6 , ... dest = dest , ... mint = mint , ... owner = owner , ... program_id = token , ... source = source , ... ) >>> type ( transfer_checked ( params )) < class ' solders . instruction . Instruction '> Returns: Type Description Instruction The transfer-checked instruction. Source code in spl/token/instructions.py def transfer_checked ( params : TransferCheckedParams ) -> Instruction : \"\"\"This instruction differs from `transfer` in that the token mint and decimals value is asserted by the caller. Example: >>> leading_zeros = [0] * 31 >>> pubkeys = [Pubkey(leading_zeros + [i + 1]) for i in range(5)] >>> dest, mint, owner, source, token = pubkeys >>> params = TransferCheckedParams( ... amount=1000, ... decimals=6, ... dest=dest, ... mint=mint, ... owner=owner, ... program_id=token, ... source=source, ... ) >>> type(transfer_checked(params)) <class 'solders.instruction.Instruction'> Returns: The transfer-checked instruction. \"\"\" data = INSTRUCTIONS_LAYOUT . build ( { \"instruction_type\" : InstructionType . TRANSFER2 , \"args\" : { \"amount\" : params . amount , \"decimals\" : params . decimals }, } ) keys = [ AccountMeta ( pubkey = params . source , is_signer = False , is_writable = True ), AccountMeta ( pubkey = params . mint , is_signer = False , is_writable = False ), AccountMeta ( pubkey = params . dest , is_signer = False , is_writable = True ), ] __add_signers ( keys , params . owner , params . signers ) return Instruction ( accounts = keys , program_id = params . program_id , data = data )","title":"transfer_checked()"}]}